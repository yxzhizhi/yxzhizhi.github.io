<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yxzhizhiの博客</title>
  
  <subtitle>必须从过去的错误学习教训而非依赖过去的成功</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yxzhizhi.github.io/"/>
  <updated>2020-07-15T13:44:19.900Z</updated>
  <id>https://yxzhizhi.github.io/</id>
  
  <author>
    <name>zhanghuo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python-gui</title>
    <link href="https://yxzhizhi.github.io/2020/07/15/python-gui/"/>
    <id>https://yxzhizhi.github.io/2020/07/15/python-gui/</id>
    <published>2020-07-15T13:44:19.000Z</published>
    <updated>2020-07-15T13:44:19.900Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>firefox dev</title>
    <link href="https://yxzhizhi.github.io/2020/05/01/firefox-dev/"/>
    <id>https://yxzhizhi.github.io/2020/05/01/firefox-dev/</id>
    <published>2020-04-30T16:22:24.000Z</published>
    <updated>2020-06-04T14:48:35.722Z</updated>
    
    <content type="html"><![CDATA[<p>about:config<br>跨域访问：设置signed.applets.codebase_principal_support=true<br>允许k加载本地文件：设置security.fileuri.strict_origin_policy=false<br>privacy.file_unique_origin=false</p><hr><h3 id="设置最小版本"><a href="#设置最小版本" class="headerlink" title="设置最小版本"></a>设置最小版本</h3><p>“browser_specific_settings”: {<br>    “gecko”: {<br>      “strict_min_version”: “54.0a1”<br>    }<br>  },</p><h3 id="设置侧边栏-图标、标题、页面"><a href="#设置侧边栏-图标、标题、页面" class="headerlink" title="设置侧边栏　图标、标题、页面"></a>设置侧边栏　图标、标题、页面</h3><p>“sidebar_action”: {<br>    “default_icon”: “icons/star.png”,<br>    “default_title” : “Annotator”,<br>    “default_panel”: “sidebar/panel.html”<br>  },</p><h3 id="设置权限-存储、tabs"><a href="#设置权限-存储、tabs" class="headerlink" title="设置权限　存储、tabs"></a>设置权限　存储、tabs</h3><p>“permissions”: [“storage”, “tabs”],  </p><h3 id="按钮事件-按钮"><a href="#按钮事件-按钮" class="headerlink" title="按钮事件　按钮"></a>按钮事件　按钮</h3><p>“browser_action”: {<br>    “default_icon”: “icons/beasts-32.png”,<br>    “theme_icons”: [{<br>        “light”: “icons/beasts-32-light.png”,<br>        “dark”: “icons/beasts-32.png”,<br>        “size”: 32<br>    }],<br>    “default_title”: “Beastify”,<br>    “default_popup”: “popup/choose_beast.html”<br>  },</p><h3 id="页面事件-url后面"><a href="#页面事件-url后面" class="headerlink" title="页面事件　url后面"></a>页面事件　url后面</h3><p>“page_action”: {<br>    “default_icon”: “icons/off.svg”,<br>    “browser_style”: true<br>  },</p><h3 id="后台活动"><a href="#后台活动" class="headerlink" title="后台活动"></a>后台活动</h3><p>“background”: {<br>    “scripts”: [“background.js”]<br>  },</p><p>/*<br>Update content when a new tab becomes active.　在窗口激活时添加监听动作＝updateContent<br>*/<br>browser.tabs.onActivated.addListener(updateContent);</p><p>在打开的tab中查询激活窗口<br>browser.tabs.query({windowId: myWindowId, active: true})<br>.then((tabs) =&gt; {<br>return browser.storage.local.get(tabs[0].url);// 获取本地存储中的tab地址，根据地址获取内容<br>})<br>.then((storedInfo) =&gt; {<br>contentBox.textContent = storedInfo[Object.keys(storedInfo)[0]];//得到内容后<br>});<br>//定义静态资源内容<br>“web_accessible_resources”: [<br>    “beasts/<em>.jpg”<br>]<br>###　给后台发送消息　<br>browser.tabs.sendMessage(tabs[0].id, {<br>    command: “beastify”,<br>    beastURL: url<br>});<br>/*</em>　当窗口打开时，给页面注入js文件</p><ul><li>When the popup loads, inject a content script into the active tab,</li><li>and add a click handler.</li><li>If we couldn’t inject the script, handle the error.</li><li>/<br>browser.tabs.executeScript({file: “/content_scripts/beastify.js”})<br>.then(listenForClicks)<br>.catch(reportExecuteScriptError);</li></ul><p>/**　在注入js中　监听消息事件</p><ul><li>Listen for messages from the background script.</li><li>Call “beastify()” or “reset()”.</li><li>/<br>browser.runtime.onMessage.addListener((message) =&gt; {<br>if (message.command === “beastify”) {<br>   insertBeast(message.beastURL);<br>} else if (message.command === “reset”) {<br>   removeExistingBeasts();<br>}<br>});<br>注入内容脚本<br>“content_scripts”: [<br>{<br>   “matches”: [“<em>://</em>.mozilla.org/*”],<br>   “js”: [“borderify.js”]<br>}<br>],</li></ul><p>侧边栏页面：browser.tabs　window.addEventListener<br>后台js: browser.tabs browser.pageAction<br>窗口页面：browser.tabs　browser.tabs.sendMessage<br>注入js:　browser.runtime.onMessage　</p><p>事例：<br>annotate-page＝给页面添加注释　打开侧边栏、给活动页面添加注释，再次打开时可显示注释信息[使用本地存储、获取tab地址]<br>apply-css＝添加样式　在url后面添加按钮，后台编写事件给页面增加删除样式[增加样式、删除样式]<br>beastify＝添加扩展按钮　，打开按钮下页面，页面上提供按钮修改页面显示内容，并可恢复原始内容[窗口与注入js通讯]<br>bookmark-it＝创建书签，删除、查找，监控tab修改，流程browserAction<br>borderify＝通过配置注入脚本并配置页面规则<br>alarms＝闹钟<br>Content script registration＝脚本注册，侧边栏输入脚本内容，可注入到当前页面中</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;about:config&lt;br&gt;跨域访问：设置signed.applets.codebase_principal_support=true&lt;br&gt;允许k加载本地文件：设置security.fileuri.strict_origin_policy=false&lt;br&gt;privacy.file_unique_origin=false&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;设置最小版本&quot;&gt;&lt;a href=&quot;#设置最小版本&quot; class=&quot;headerlink&quot; title=&quot;设置最小版本&quot;&gt;&lt;/a&gt;设置最小版本&lt;/h3&gt;&lt;p&gt;“browser_specific_settings”: {&lt;br&gt;    “gecko”: {&lt;br&gt;      “strict_min_version”: “54.0a1”&lt;br&gt;    }&lt;br&gt;  },&lt;/p&gt;
&lt;h3 id=&quot;设置侧边栏-图标、标题、页面&quot;&gt;&lt;a href=&quot;#设置侧边栏-图标、标题、页面&quot; class=&quot;headerlink&quot; title=&quot;设置侧边栏　图标、标题、页面&quot;&gt;&lt;/a&gt;设置侧边栏　图标、标题、页面&lt;/h3&gt;&lt;p&gt;“sidebar_action”: {&lt;br&gt;    “default_icon”: “icons/star.png”,&lt;br&gt;    “default_title” : “Annotator”,&lt;br&gt;    “default_panel”: “sidebar/panel.html”&lt;br&gt;  },&lt;/p&gt;
&lt;h3 id=&quot;设置权限-存储、tabs&quot;&gt;&lt;a href=&quot;#设置权限-存储、tabs&quot; class=&quot;headerlink&quot; title=&quot;设置权限　存储、tabs&quot;&gt;&lt;/a&gt;设置权限　存储、tabs&lt;/h3&gt;&lt;p&gt;“permissions”: [“storage”, “tabs”],  &lt;/p&gt;
&lt;h3 id=&quot;按钮事件-按钮&quot;&gt;&lt;a href=&quot;#按钮事件-按钮&quot; class=&quot;headerlink&quot; title=&quot;按钮事件　按钮&quot;&gt;&lt;/a&gt;按钮事件　按钮&lt;/h3&gt;&lt;p&gt;“browser_action”: {&lt;br&gt;    “default_icon”: “icons/beasts-32.png”,&lt;br&gt;    “theme_icons”: [{&lt;br&gt;        “light”: “icons/beasts-32-light.png”,&lt;br&gt;        “dark”: “icons/beasts-32.png”,&lt;br&gt;        “size”: 32&lt;br&gt;    }],&lt;br&gt;    “default_title”: “Beastify”,&lt;br&gt;    “default_popup”: “popup/choose_beast.html”&lt;br&gt;  },&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker Flink</title>
    <link href="https://yxzhizhi.github.io/2020/04/19/Docker-Flink/"/>
    <id>https://yxzhizhi.github.io/2020/04/19/Docker-Flink/</id>
    <published>2020-04-19T03:27:40.000Z</published>
    <updated>2020-04-19T03:27:40.917Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>windows node 环境安装</title>
    <link href="https://yxzhizhi.github.io/2020/04/19/windows10%20node%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <id>https://yxzhizhi.github.io/2020/04/19/windows10%20node%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</id>
    <published>2020-04-19T03:27:40.000Z</published>
    <updated>2021-07-10T08:47:14.692Z</updated>
    
    <content type="html"><![CDATA[<p>使用 nvs 管理本地 Node.js 版本</p><h3 id="Linux-macOS-环境"><a href="#Linux-macOS-环境" class="headerlink" title="Linux / macOS 环境"></a>Linux / macOS 环境</h3><p>通过 Git Clone 对应的项目即可。</p><p>$ export NVS_HOME=”$HOME/.nvs”<br>$ git clone <a href="https://github.com/jasongin/nvs">https://github.com/jasongin/nvs</a> –depth=1 “$NVS_HOME”<br>$ . “$NVS_HOME/nvs.sh” install</p><h3 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h3><p>由于 Windows 环境配置比较复杂，所以还是推荐使用 msi 文件完成初始化工作。</p><p>访问 nvs/releases 下载最新版本的 nvs.msi，然后双击安装即可。</p><h2 id="配置镜像地址"><a href="#配置镜像地址" class="headerlink" title="配置镜像地址"></a>配置镜像地址</h2><p>在国内由于大家都懂的原因，需要把对应的镜像地址修改下：</p><p>$ nvs remote node <a href="https://npm.taobao.org/mirrors/node/">https://npm.taobao.org/mirrors/node/</a><br>$ nvs remote<br>default             node<br>chakracore          <a href="https://github.com/nodejs/node-chakracore/releases/">https://github.com/nodejs/node-chakracore/releases/</a><br>chakracore-nightly  <a href="https://nodejs.org/download/chakracore-nightly/">https://nodejs.org/download/chakracore-nightly/</a><br>nightly             <a href="https://nodejs.org/download/nightly/">https://nodejs.org/download/nightly/</a><br>node                <a href="https://nodejs.org/dist/">https://nodejs.org/dist/</a></p><h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p>通过以下命令，即可非常简单的安装 Node.js 最新的 LTS 版本。</p><h1 id="安装最新的-LTS-版本"><a href="#安装最新的-LTS-版本" class="headerlink" title="安装最新的 LTS 版本"></a>安装最新的 LTS 版本</h1><p>$ nvs add lts</p><h1 id="配置为默认版本"><a href="#配置为默认版本" class="headerlink" title="配置为默认版本"></a>配置为默认版本</h1><p>$ nvs link lts<br>安装其他版本：</p><h1 id="安装其他版本尝尝鲜"><a href="#安装其他版本尝尝鲜" class="headerlink" title="安装其他版本尝尝鲜"></a>安装其他版本尝尝鲜</h1><p>$ nvs add 12</p><h1 id="查看已安装的版本"><a href="#查看已安装的版本" class="headerlink" title="查看已安装的版本"></a>查看已安装的版本</h1><p>$ nvs ls</p><h1 id="在当前-Shell-切换版本"><a href="#在当前-Shell-切换版本" class="headerlink" title="在当前 Shell 切换版本"></a>在当前 Shell 切换版本</h1><p>$ nvs use 12<br>更多指令参见 nvs –help 。</p><h2 id="共用-npm-全局模块"><a href="#共用-npm-全局模块" class="headerlink" title="共用 npm 全局模块"></a>共用 npm 全局模块</h2><p>使用 nvs 时，默认的 prefix 是当前激活的 Node.js 版本的安装路径。</p><p>带来一个问题是：切换版本之后，之前安装全局命令模块需要重新安装，非常不方便。</p><p>解决方案是配置统一的全局模块安装路径到 ~/.npm-global，如下：</p><p>$ mkdir -p ~/.npm-global<br>$ npm config set prefix ~/.npm-global<br>还需配置环境变量到 ~/.bashrc 或 ~/.zshrc 文件里面：</p><p>$ echo “export PATH=~/.npm-global/bin:$PATH” &gt;&gt; ~/.zshrc<br>$ source ~/.zshrc</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 nvs 管理本地 Node.js 版本&lt;/p&gt;
&lt;h3 id=&quot;Linux-macOS-环境&quot;&gt;&lt;a href=&quot;#Linux-macOS-环境&quot; class=&quot;headerlink&quot; title=&quot;Linux / macOS 环境&quot;&gt;&lt;/a&gt;Linux / macOS 环境&lt;/h3&gt;&lt;p&gt;通过 Git Clone 对应的项目即可。&lt;/p&gt;
&lt;p&gt;$ export NVS_HOME=”$HOME/.nvs”&lt;br&gt;$ git clone &lt;a href=&quot;https://github.com/jasongin/nvs&quot;&gt;https://github.com/jasongin/nvs&lt;/a&gt; –depth=1 “$NVS_HOME”&lt;br&gt;$ . “$NVS_HOME/nvs.sh” install&lt;/p&gt;
&lt;h3 id=&quot;Windows-环境&quot;&gt;&lt;a href=&quot;#Windows-环境&quot; class=&quot;headerlink&quot; title=&quot;Windows 环境&quot;&gt;&lt;/a&gt;Windows 环境&lt;/h3&gt;&lt;p&gt;由于 Windows 环境配置比较复杂，所以还是推荐使用 msi 文件完成初始化工作。&lt;/p&gt;
&lt;p&gt;访问 nvs/releases 下载最新版本的 nvs.msi，然后双击安装即可。&lt;/p&gt;
&lt;h2 id=&quot;配置镜像地址&quot;&gt;&lt;a href=&quot;#配置镜像地址&quot; class=&quot;headerlink&quot; title=&quot;配置镜像地址&quot;&gt;&lt;/a&gt;配置镜像地址&lt;/h2&gt;&lt;p&gt;在国内由于大家都懂的原因，需要把对应的镜像地址修改下：&lt;/p&gt;
&lt;p&gt;$ nvs remote node &lt;a href=&quot;https://npm.taobao.org/mirrors/node/&quot;&gt;https://npm.taobao.org/mirrors/node/&lt;/a&gt;&lt;br&gt;$ nvs remote&lt;br&gt;default             node&lt;br&gt;chakracore          &lt;a href=&quot;https://github.com/nodejs/node-chakracore/releases/&quot;&gt;https://github.com/nodejs/node-chakracore/releases/&lt;/a&gt;&lt;br&gt;chakracore-nightly  &lt;a href=&quot;https://nodejs.org/download/chakracore-nightly/&quot;&gt;https://nodejs.org/download/chakracore-nightly/&lt;/a&gt;&lt;br&gt;nightly             &lt;a href=&quot;https://nodejs.org/download/nightly/&quot;&gt;https://nodejs.org/download/nightly/&lt;/a&gt;&lt;br&gt;node                &lt;a href=&quot;https://nodejs.org/dist/&quot;&gt;https://nodejs.org/dist/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker spark+hadoop</title>
    <link href="https://yxzhizhi.github.io/2020/04/19/docker-spark-hadoop/"/>
    <id>https://yxzhizhi.github.io/2020/04/19/docker-spark-hadoop/</id>
    <published>2020-04-19T03:27:27.000Z</published>
    <updated>2020-04-19T03:27:27.285Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vritubox-ubuntu-init</title>
    <link href="https://yxzhizhi.github.io/2020/04/19/vritubox-ubuntu-init/"/>
    <id>https://yxzhizhi.github.io/2020/04/19/vritubox-ubuntu-init/</id>
    <published>2020-04-19T01:40:58.000Z</published>
    <updated>2020-04-19T04:03:36.952Z</updated>
    
    <content type="html"><![CDATA[<p>init_net_10.0.2.15</p><pre><code>vim /etc/network/interfacesauto eth0iface eth0 inet static    address 10.0.2.15gateway 10.0.2.1netmask 255.255.255.0dns-nameservers 8.8.8.8--auto eth0#etho为通常的Ubuntu的网关名称，有时也会改变，可通过ifconfig命令查看，有时会出现如ens160,ens33等名称iface eth0 inet static#设置IP为静止IP,address 192.168.1.103#你想设置的静态IP地址netmask 255.255.255.0#子网掩码，通常为255.255.255.0#network 192.168.1.0broadcast 192.168.1.255 #广播地址，可以通过ifconfig查看现有的。，gateway 192.168.1.8#网关, #netstat -r 命令或者   nm-tool   查看现有的# dns-* options are implemented by the resolvconf package, if installeddns-nameservers 61.139.2.69#国内常见的dns解析，#dns-search localhostdns-nameservers 8.8.8.8#谷歌dns解析，但是速度较慢sudo service networking restart/etc/init.d/networking restartsudo ifconfig eth0 down sudo ifconfig eth0 upebvim /etc/resolvconf/resolv.conf.d/basenameserver 8.8.8.8VBox无界面启动VBoxManage startvm name  --type headless关机VBoxManage controlvm name poweroff</code></pre><p>init&amp;ssh&amp;ssl&amp;ssh免密码快速登录配置</p><pre><code>apt install openssh* opensslnetstat -lnt | grep 22service sshd restartssh zhanghuo@localhost -p 21522--ssh免密码快速登录配置ssh-keygen -t rsascp -P21522 ./id_rsa.pub zhanghuo@localhost:~ssh -p21522 zhanghuo@localhostremote:cat id_rsa.pub &gt; ~/.ssh/authorized_keysssh -p21522 zhanghuo@localhostvi ～/.ssh/configHost v21522HostName localhostPort 21522User zhanghuoIdentityFile ~/.ssh/id_rsa.pub:wq# ssh-copy-id -i ~/.ssh/id_rsa.pub v21522ssh v21522</code></pre><p>oraclelinux7&amp;centos7</p><pre><code>cd /etc/sysconfig/network-scriptsip addr / ifconfig 没有此命令sudo vi ifcfg-enp0s3 /ens33BOOTPROTO=&quot;static&quot;         # 使用静态IP地址，默认为dhcpIPADDR=&quot;10.0.3.15&quot;   # 设置的静态IP地址NETMASK=&quot;255.255.255.0&quot;    # 子网掩码GATEWAY=&quot;10.0.3.1&quot;    # 网关地址DNS1=&quot;8.8.8.8&quot;       # DNS服务器ONBOOT=&quot;yes&quot;             #是否开机启用:wqservice network restarthostnamectl set-hostname zhanghuovim /etc/hosts10.0.3.15 zhanghuoping www.baidu.com</code></pre><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h4 id="firewall命令"><a href="#firewall命令" class="headerlink" title="firewall命令"></a>firewall命令</h4><p>firewall-cmd –zone=public –add-port=3306/tcp –permanent<br>#对外开放3306端口，供外部的计算机访问<br>#该命令方式添加的端口，可在/etc/firewalld/zones中的对应配置文件中得到体现</p><p>systemctl restart firewalld #重启防火漆<br>说明：<br>firewall-cmd：Linux中提供的操作firewall的工具。<br>–zone：指定作用域。<br>–add-port=80/tcp：添加的端口，格式为：端口/通讯协议。<br>–permanent：表示永久生效，没有此参数重启后会失效。</p><h4 id="直接修改配置文件"><a href="#直接修改配置文件" class="headerlink" title="直接修改配置文件"></a>直接修改配置文件</h4><p>/etc/firewalld/zones/public.xml 文件的默认内容为：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;zone&gt;  &lt;short&gt;Public&lt;/short&gt;  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;  &lt;service name=&quot;dhcpv6-client&quot;/&gt;  &lt;service name=&quot;ssh&quot;/&gt;&lt;/zone&gt;</code></pre><p>修改该配置文件，来添加3306端口。修改后的内容为：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;zone&gt;  &lt;short&gt;Public&lt;/short&gt;  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;  &lt;service name=&quot;dhcpv6-client&quot;/&gt;  &lt;service name=&quot;ssh&quot;/&gt;  &lt;port protocol=&quot;tcp&quot; port=&quot;3306&quot;/&gt;&lt;/zone&gt;</code></pre><hr><h4 id="firewall常用命令"><a href="#firewall常用命令" class="headerlink" title="firewall常用命令"></a>firewall常用命令</h4><h4 id="查看firewall的状态"><a href="#查看firewall的状态" class="headerlink" title="查看firewall的状态"></a>查看firewall的状态</h4><pre><code>service firewalld status或systemctl status firewalld或firewall-cmd --state</code></pre><h4 id="启动、停止、重启"><a href="#启动、停止、重启" class="headerlink" title="启动、停止、重启"></a>启动、停止、重启</h4><pre><code>service firewalld start或systemctl start firewalld# 启动service firewalld stop或systemctl stop firewalld# 停止service firewalld restart或systemctl restart firewalld# 重启</code></pre><h4 id="开机自启动的关闭与开启"><a href="#开机自启动的关闭与开启" class="headerlink" title="开机自启动的关闭与开启"></a>开机自启动的关闭与开启</h4><pre><code>systemctl disable firewalld# 关闭开机自启动systemctl enable firewalld# 开启开机自启动2.4 查看防火墙的规则firewall-cmd --list-all </code></pre><p>开放22端口，默认已经开放ssh服务</p><pre><code>sudo firewall-cmd --zone=public --add-port=22/tcp --permanentsudo service firewalld restart</code></pre><p>vritubox 全局设定，创建nat网络并配置端口映射<br>ssh zhanghuo@localhost -p 21522<br>ssh zhanghuo@localhost -p 31522<br>ssh zhanghuo@localhost -p 51522</p><p>–ssh免密码快速登录配置</p><p>vi ～/.ssh/config<br>Host v21522<br>HostName localhost<br>Port 21522<br>User zhanghuo<br>IdentityFile ~/.ssh/id_rsa.pub</p><p>Host v31522<br>HostName localhost<br>Port 31522<br>User zhanghuo<br>IdentityFile ~/.ssh/id_rsa.pub</p><p>Host v51522<br>HostName localhost<br>Port 51522<br>User zhanghuo<br>IdentityFile ~/.ssh/id_rsa.pub</p><p>:wq</p><p>ssh-keygen -t rsa #存在id_rsa.pub则可不再执行</p><p>ssh-copy-id -i ~/.ssh/id_rsa.pub v31522<br>ssh-copy-id -i ~/.ssh/id_rsa.pub -p 31522 zhanghuo@localhost</p><p>ssh v31522</p><p>ssh-copy-id -i ~/.ssh/id_rsa.pub v51522</p><p>ssh v31522</p><hr><pre><code>vim /etc/ssh/sshd_config#PermitRootLogin yes#RSAAuthentication yes#PubkeyAuthentication yes将这三个配置打开 并进行对应的配置 全为yes</code></pre><p>DevStack|DevStack|21622</p><p>VBox无界面启动-DevStack<br>VBoxManage startvm DevStack  –type headless<br>ssh DevStack<br>关机<br>VBoxManage controlvm DevStack poweroff</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;init_net_10.0.2.15&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim /etc/network/interfaces
auto eth0
iface eth0 inet static    
address 10.0.2.15
gateway 10.0.2.1
netmask 255.255.255.0
dns-nameservers 8.8.8.8
--
auto eth0#etho为通常的Ubuntu的网关名称，有时也会改变，可通过ifconfig命令查看，有时会出现如ens160,ens33等名称
iface eth0 inet static#设置IP为静止IP,
address 192.168.1.103#你想设置的静态IP地址
netmask 255.255.255.0#子网掩码，通常为255.255.255.0
#network 192.168.1.0
broadcast 192.168.1.255 #广播地址，可以通过ifconfig查看现有的。，
gateway 192.168.1.8#网关, #netstat -r 命令或者   nm-tool   查看现有的
# dns-* options are implemented by the resolvconf package, if installed
dns-nameservers 61.139.2.69#国内常见的dns解析，
#dns-search localhost
dns-nameservers 8.8.8.8#谷歌dns解析，但是速度较慢


sudo service networking restart
/etc/init.d/networking restart
sudo ifconfig eth0 down 
sudo ifconfig eth0 up
eb

vim /etc/resolvconf/resolv.conf.d/base
nameserver 8.8.8.8

VBox无界面启动
VBoxManage startvm name  --type headless
关机
VBoxManage controlvm name poweroff
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;init&amp;amp;ssh&amp;amp;ssl&amp;amp;ssh免密码快速登录配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt install openssh* openssl
netstat -lnt | grep 22
service sshd restart

ssh zhanghuo@localhost -p 21522

--ssh免密码快速登录配置
ssh-keygen -t rsa
scp -P21522 ./id_rsa.pub zhanghuo@localhost:~
ssh -p21522 zhanghuo@localhost
remote:cat id_rsa.pub &amp;gt; ~/.ssh/authorized_keys
ssh -p21522 zhanghuo@localhost


vi ～/.ssh/config
Host v21522
HostName localhost
Port 21522
User zhanghuo
IdentityFile ~/.ssh/id_rsa.pub

:wq

# ssh-copy-id -i ~/.ssh/id_rsa.pub v21522
ssh v21522
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;oraclelinux7&amp;amp;centos7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd /etc/sysconfig/network-scripts
ip addr / ifconfig 没有此命令
sudo vi ifcfg-enp0s3 /ens33

BOOTPROTO=&amp;quot;static&amp;quot;         # 使用静态IP地址，默认为dhcp
IPADDR=&amp;quot;10.0.3.15&amp;quot;   # 设置的静态IP地址
NETMASK=&amp;quot;255.255.255.0&amp;quot;    # 子网掩码
GATEWAY=&amp;quot;10.0.3.1&amp;quot;    # 网关地址
DNS1=&amp;quot;8.8.8.8&amp;quot;       # DNS服务器

ONBOOT=&amp;quot;yes&amp;quot;             #是否开机启用
:wq

service network restart
hostnamectl set-hostname zhanghuo
vim /etc/hosts
10.0.3.15 zhanghuo

ping www.baidu.com
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;防火墙&quot;&gt;&lt;a href=&quot;#防火墙&quot; class=&quot;headerlink&quot; title=&quot;防火墙&quot;&gt;&lt;/a&gt;防火墙&lt;/h3&gt;&lt;h4 id=&quot;firewall命令&quot;&gt;&lt;a href=&quot;#firewall命令&quot; class=&quot;headerlink&quot; title=&quot;firewall命令&quot;&gt;&lt;/a&gt;firewall命令&lt;/h4&gt;&lt;p&gt;firewall-cmd –zone=public –add-port=3306/tcp –permanent&lt;br&gt;#对外开放3306端口，供外部的计算机访问&lt;br&gt;#该命令方式添加的端口，可在/etc/firewalld/zones中的对应配置文件中得到体现&lt;/p&gt;
&lt;p&gt;systemctl restart firewalld #重启防火漆&lt;br&gt;说明：&lt;br&gt;firewall-cmd：Linux中提供的操作firewall的工具。&lt;br&gt;–zone：指定作用域。&lt;br&gt;–add-port=80/tcp：添加的端口，格式为：端口/通讯协议。&lt;br&gt;–permanent：表示永久生效，没有此参数重启后会失效。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ubuntu 删除软件</title>
    <link href="https://yxzhizhi.github.io/2020/04/18/ubuntu-%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6/"/>
    <id>https://yxzhizhi.github.io/2020/04/18/ubuntu-%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6/</id>
    <published>2020-04-18T11:51:25.000Z</published>
    <updated>2020-04-18T11:52:20.944Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu apt-get彻底卸载软件包<br>原创享学IT 最后发布于2016-04-28 18:09:48 阅读数 228448  收藏<br>展开<br>如果你关注搜索到这篇文章，那么我可以合理怀疑你被apt-get的几个卸载命令有点搞晕了。</p><p>apt-get的卸载相关的命令有remove/purge/autoremove/clean/autoclean等。具体来说：</p><p>apt-get purge / apt-get –purge remove<br>删除已安装包（不保留配置文件)。<br>如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文件</p><p>apt-get autoremove<br>删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</p><p>apt-get remove<br>删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</p><p>apt-get autoclean<br>APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。</p><p>apt-get clean<br>使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。</p><p>那么如何彻底卸载软件呢？<br>具体来说可以运行如下命令：</p><h1 id="删除软件及其配置文件"><a href="#删除软件及其配置文件" class="headerlink" title="删除软件及其配置文件"></a>删除软件及其配置文件</h1><p>apt-get –purge remove <package></p><h1 id="删除没用的依赖包"><a href="#删除没用的依赖包" class="headerlink" title="删除没用的依赖包"></a>删除没用的依赖包</h1><p>apt-get autoremove <package></p><h1 id="此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理："><a href="#此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：" class="headerlink" title="此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理："></a>此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：</h1><p>dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P<br>当然如果要删除暂存的软件安装包，也可以再使用clean命令。<br>————————————————</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu apt-get彻底卸载软件包&lt;br&gt;原创享学IT 最后发布于2016-04-28 18:09:48 阅读数 228448  收藏&lt;br&gt;展开&lt;br&gt;如果你关注搜索到这篇文章，那么我可以合理怀疑你被apt-get的几个卸载命令有点搞晕了。&lt;/p&gt;
&lt;p&gt;apt-get的卸载相关的命令有remove/purge/autoremove/clean/autoclean等。具体来说：&lt;/p&gt;
&lt;p&gt;apt-get purge / apt-get –purge remove&lt;br&gt;删除已安装包（不保留配置文件)。&lt;br&gt;如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文件&lt;/p&gt;
&lt;p&gt;apt-get autoremove&lt;br&gt;删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。&lt;/p&gt;
&lt;p&gt;apt-get remove&lt;br&gt;删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。&lt;/p&gt;
&lt;p&gt;apt-get autoclean&lt;br&gt;APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。&lt;/p&gt;
&lt;p&gt;apt-get clean&lt;br&gt;使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。&lt;/p&gt;
&lt;p&gt;那么如何彻底卸载软件呢？&lt;br&gt;具体来说可以运行如下命令：&lt;/p&gt;
&lt;h1 id=&quot;删除软件及其配置文件&quot;&gt;&lt;a href=&quot;#删除软件及其配置文件&quot; class=&quot;headerlink&quot; title=&quot;删除软件及其配置文件&quot;&gt;&lt;/a&gt;删除软件及其配置文件&lt;/h1&gt;&lt;p&gt;apt-get –purge remove &lt;package&gt;&lt;/package&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>openstack 部署方式</title>
    <link href="https://yxzhizhi.github.io/2020/04/18/openstack-%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/"/>
    <id>https://yxzhizhi.github.io/2020/04/18/openstack-%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/</id>
    <published>2020-04-18T09:33:23.000Z</published>
    <updated>2020-04-19T12:20:56.116Z</updated>
    
    <content type="html"><![CDATA[<p>对于每一个刚接触到OpenStack的新人而言，安装无疑是最困难的，同时这也客观上提高了大家学习OpenStack云计算的技术门槛。想一想，自己3年前网上偶然接触到OpenStack时，一头茫然，手动搭建一个多节点环境时居然用了3个星期。</p><p>时至今日，真是感触颇多，从某种角度而言，也很庆幸当时自己并未因困难而放弃OpenStack，否则，应该是去做其他领域了吧！</p><p>言归正传，咱们就来数落数落部署OpenStack都有哪些方式吧。这里，我们根据使用者群体的不同类型来进行分类和归纳：</p><p>个人使用方面</p><p>DevStack</p><p>无疑，在可预见的未来时间内，DevStack仍将是众多开发者们的首选安装方式或工具。该方式主要是通过配置参数，执行shell脚本来安装一个OpenStack的开发环境。</p><p>Github: <a href="https://github.com/openstack-dev/devstack">https://github.com/openstack-dev/devstack</a></p><p>Wiki: <a href="https://wiki.openstack.org/wiki/DevStack">https://wiki.openstack.org/wiki/DevStack</a></p><p>Rdo</p><p>Rdo是由Red Hat开源的一款部署OpenStack的工具，同DevStack一样，支持单节点和多节点部署。但Rdo只支持CentOS系列的操作系统。需要注意的是，该项目并不属于OpenStack官方社区项目。</p><p>Docs：<a href="https://www.rdoproject.org/install/quickstart">https://www.rdoproject.org/install/quickstart</a></p><p>手动部署</p><p>手动部署all-in-one、multi-node、multi-HA-node环境。</p><p>其他</p><p>企业、团体方面</p><p>1.Puppet</p><p>Puppet由Ruby语言编写。应当说，Puppet是进入OpenStack自动化部署中的早期一批项目，历史还算悠久。目前，它的活跃开发群体们是Red hat、 Mirantis、UnitedStack等。</p><p>2.Red</p><p>hat自从收购Ansible之后，如今仍然保持强势劲头在Puppet</p><p>OpenStack项目中的Commit数量和质量，其技术实力不容小觑；Mirantis出品的Fuel部署工具中，大量的模块代码便使用的是</p><p>Puppet。就国内而言，UnitedStack是Puppet社区贡献和使用的最大用户。</p><p>Github：</p><p><a href="https://github.com/openstack/puppet-keystone">https://github.com/openstack/puppet-keystone</a></p><p>Governance：</p><p>Wiki：</p><p><a href="https://wiki.openstack.org/wiki/Puppet">https://wiki.openstack.org/wiki/Puppet</a></p><p>3.Ansible</p><p>Ansible</p><p>是新近出现的自动化运维工具，已被Red</p><p>Hat收购。基于Python开发，集合了众多运维工具（puppet、cfengine、chef、saltstack等）的优点，实现了批量系统配</p><p>置、批量程序部署、批量运行命令等功能，它一方面总结了Puppet的设计上的得失，另一方面也改进了很多设计。比如是基于SSH方式工作，故而不需要在被控端安装客户端。使得在和OpenStack结合上没有历史包袱，更加能够轻装上阵，未来发展潜力不容小觑号称是“你一直寻找的下一代Iaas”的</p><p>Zstack，使用到的部署工具也是基于Ansible。</p><p>Openstack-ansible项目，最早是由老牌Rackspace公司在Launchpad官网上注册。</p><p>在最新的Ansible OpenStack项目社区Commit贡献中，Rackspace也可谓是遥遥领先，而紧随其后的是Red Hat、国内九州云等公司。</p><p>Github：<a href="https://github.com/openstack/openstack-ansible">https://github.com/openstack/openstack-ansible</a></p><ol start="4"><li>SaltStack</li></ol><p>SaltStack</p><p>也是一款开源的自动化部署工具，基于Python开发，实现了批量系统配置、批量程序部署、批量运行命令等功能，和Ansible也是挺相近的。不同之一</p><p>是，由于SaltStack的master和minion认证机制和工作方式，需要在被控端安装minion客户端，在加之其他原因，自然和</p><p>Ansible相比，其优缺点便很明显了。</p><p>需要注意的是，使用Saltstack部署OpenStack，并不属于OpenStack社区项目。目前，主要还是处于用户自研自用的阶段。据笔者所知，目前国内的携程应该是使用Saltstack部署OpenStack规模最大的用户。</p><p>Saltstack部署OpenStack示例：<a href="https://github.com/luckpenguin/saltstack_openstack">https://github.com/luckpenguin/saltstack_openstack</a></p><p>Saltstack部署OpenStack模块：</p><p>5.TripleO</p><p>Tripleo 项目最早由HP于2013.4在launchpad上注册BP。用于完成OpenStack的安装与部署。TripleO全称“OpenStack On OpenStack”，</p><p>意思即为“云上云”，可以简单理解为利用OpenStack来部署OpenStack，即首先基于V2P(和P2V相反，也就是指</p><p>把虚拟机的镜像迁移到物理机上)的理念事先准备好一些OpenStack节点（计算、存储、控制节点）的镜像，然后利用已有openstack环境的裸机</p><p>服务Ironic项目去部署裸机，软件安装部分的diskimage-builder，最后通过Heat项目和镜像内的DevOps工具(Puppet Or Chef)再在裸机上配置运行openstack。</p><p>和其他部署工具不同的是，TripleO利用OpenStack本来的基础设施来部署OpenStack，基于Nova、 Neutron、Ironic和Heat，来自动化部署和伸缩OpenStack集群。</p><p>应</p><p>当确切的说，TripleO项目属于当前OpenStack社区主推的“Big Tent”开发模式下的big tent project（OpenStack下的项目分为三种，core project: nova/neutron等核心项目，big tent project: 非核心项目，但也被OpenStack 基金会接受；第三种就是其它项目，只是放在OpenStack下，但是社区还没有接受）。</p><p>在该项目的社区Commit贡献上，Red hat可谓是遥遥领先，而紧随其后的是IBM等公司。</p><p>Wiki：<a href="https://wiki.openstack.org/wiki/TripleO">https://wiki.openstack.org/wiki/TripleO</a></p><p>6.Kolla</p><p>在国内一些互联网资料上，常看到关于kolla是TripleO项目的一部分这样的描述，其实是不准确的。真实的是，Kolla项目起源于Tripleo项</p><p>目，时至今日，与它没有任何关系（虽然它们的目标都是做自动化部署，但走的道路却不同）。比之于Tripleo和其他部署工具，Kolla走的是</p><p>docker容器部署路线。</p><p>kolla项目起源于TripleO项目，聚焦于使用docker容器部署OpenStack服务。该项目由</p><p>Cisco于2014年9月提出，是OpenStack的孵化项目。当前Kolla项目在Kollaglue</p><p>repo提供了以下服务的docker镜像。 # docker search kollaglue</p><p>Kolla的优势和使用场景，体现在如下几个方面：</p><p>原子性的升级或者回退OpenStack部署；</p><p>基于组件升级OpenStack；</p><p>基于组件回退OpenStack；</p><p>这里，我们予以拆分来理解：</p><p>Kolla的最终目标是为OpenStack的每一个服务都创建一个对应的Docker Image，通过Docker</p><p>Image将升级的粒度减小到Service级别，从而使升级时，对OpenStack影响能达到最小，并且一旦升级失败，也很容易回滚。升级只需要三</p><p>步：Pull新版本的容器镜像，停止老版本的容器服务，然后启动新版本容器。回滚也不需要重新安装包了，直接启动老版本容器服务就行，非常方便。</p><p>Kolla是通过Docker Compose来部署OpenStack集群的，现在主要是针对裸机部署的，所以在部署Docker Container时，默认的网络配置都是Host模式。</p><p>首先，只需要通过一个命令就可以把管理节点部署完成，这个命令是调用Docker Compose来部署OpenStack的所有服务，然后我们可以在每一个计算节点上通过Docker Compose安装计算节点需要的服务，就能部署一个OpenStack集群。因为Kolla的Docker</p><p>Image粒度很小，它针对每个OpenStack服务都有特定的Image，所以我们也可以通过Docker</p><p>Run来操作某个具体的OpenStack服务。</p><p>7.Fuel</p><p>Fuel 是针对OpenStack生产环境目标</p><p>（非开源）设计的一个端到端”一键部署“的工具，大量采用了Python、Ruby和JavaScript等语言。其功能含盖自动的PXE方式的操作系统</p><p>安装，DHCP服务，Orchestration服务 和puppet 配置管理相关服务等，此外还有OpenStack关键业务健康检查和log</p><p>实时查看等非常好用的服务。</p><p>Fuel，这款让很多人即爱且痛的工具，在国内外都很盛名。爱的原因是，它确实很棒；痛的原因是，要想彻底掌握</p><p>它，可不是一件容易事（各个模块集成度高、使用技术复杂）。既然提到Fuel，自然不能不提它的父母——Mirantis。Mirantis是一家技术实</p><p>力非常雄厚的OpenStack服务集成商，他是社区贡献排名前5名中唯一一个靠OpenStack软件和服务盈利的公司。同时，Fuel的版本节奏也很</p><p>快，平均每半年就能提供一个相对稳定的社区版。</p><p>从和笔者接触到的一些情况来看，国内研究、使用Fuel的个人、群体还是为数不少的。不少国内OpenStack初创公司的安装包就是基于Fuel去修改的。</p><hr><p>DevStack<br>手动部署all-in-one、multi-node、multi-HA-node环境。</p><p>Ansible<br>TripleO<br>Kolla-docker<br>Fuel<br><a href="https://www.bookstack.cn/read/deployopenstackwithpuppet/deployment_tool-packstack.md">https://www.bookstack.cn/read/deployopenstackwithpuppet/deployment_tool-packstack.md</a></p><h2 id="Devstack-安装配置"><a href="#Devstack-安装配置" class="headerlink" title="Devstack 安装配置"></a>Devstack 安装配置</h2><p>创建stack用户<br>为了系统的安全，DevStack最好不要在root用户下直接运行，因此需要创建一个专门的用户stack，该用户需要有免密码sudo权限，配置如下:</p><pre><code>su rootadduser stackecho &quot;stack ALL=(ALL) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers # 建议使用visudosu stack</code></pre><p>如果已经下载了DevStack代码，DevStack也提供了一个专门的脚本创建stack用户，该脚本位于devstack/tools/create-stack-user.sh，直接运行该脚本即可。<br>最后请务必检查当前工作用户为stack，并且能够不输入密码执行sudo命令。</p><ol><li>使用国内的镜像源<br>对于Ubuntu系统就是修改APT源，比如阿里云镜像源，只需要修改/etc/apt/source.list配置文件即可，替换为需要使用的镜像源。如：</li></ol><p>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-security main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-updates main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-backports main restricted universe multiverse<br>2. 使用国内的pip源<br>只需要在当前家目录.pip目录创建pip.conf配置文件，以使用阿里云为例，配置文件内容如下：</p><p>cat ~/.pip/pip.conf<br>[global]<br>index-url = <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>[install]<br>trusted-host=mirrors.aliyun.com<br>3.修改OpenStack源码地址<br>DevStack默认会从git.openstack.org下拉取代码，国内访问速度很慢，建议替换为github地址或者国内的trystack仓库，在[[local|localrc]]配置下增加以下配置项：</p><p>GIT_BASE=<a href="http://git.trystack.cn">http://git.trystack.cn</a><br>如果你本地已经有最新的OpenStack源码了，也可以指定你本地的源码路径，比如使用本地的Nova源代码并且使用new_feature分支:</p><p>[[local|localrc]]<br>NOVA_REPO=/home/int32bit/nova<br>NOVA_BRANCH=new_feature<br>需要注意的是，国内源存在同步滞后，可能包不兼容或者下载某些包失败问题，出现这种情况时只需要重新替换原来的镜像源，然后重新运行./stack.sh即可。</p><p><a href="https://docs.openstack.org/devstack/latest/">https://docs.openstack.org/devstack/latest/</a></p><p>安装Linux ¶<br>从干净，最小程度地安装Linux系统开始。DevStack尝试支持Ubuntu的两个最新LTS版本，最新/当前的Fedora版本，CentOS / RHEL 7以及Debian和OpenSUSE。</p><p>如果您没有偏好，Ubuntu 18.04（Bionic Beaver）将会是测试最多的，并且可能会做得最流畅。</p><p>添加堆栈用户（可选）¶<br>DevStack应该以启用了sudo的非root用户身份运行（通常可以正常登录到云映像，例如“ ubuntu”或“ cloud-user”）。</p><p>如果您不使用云映像，则可以创建一个单独的堆栈用户来运行DevStack</p><p>$ sudo useradd -s /bin/bash -d /opt/stack -m stack<br>由于此用户将对您的系统进行许多更改，因此它应该具有sudo特权：</p><p>$ echo “stack ALL=(ALL) NOPASSWD: ALL” | sudo tee /etc/sudoers.d/stack<br>$ sudo su - stack<br>下载DevStack ¶<br>$ git clone <a href="https://opendev.org/openstack/devstack">https://opendev.org/openstack/devstack</a><br>$ cd devstack<br>存储devstack库包含一个脚本，该脚本安装OpenStack和用于配置文件的模板。</p><p>创建local.conf中¶<br>local.conf在devstack git repo的根目录下创建一个具有四个密码的文件。</p><p>[[local|localrc]]<br>ADMIN_PASSWORD=secret<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD<br>这是开始使用DevStack所需的最低配置。</p><p> 注意</p><p>devstack存储库中local.conf的samples目录下有一个示例文件。</p><p>开始安装¶<br>$ ./stack.sh<br>这将需要15-20分钟，具体取决于您的互联网连接速度。在此过程中将安装许多git树和软件包。</p><p>二、环境准备<br>2.1 安装虚拟机Ubuntu<br>本例选用ubuntu16.04-server版本。<br>虚拟机配置：内存4G，磁盘：50GB<br>网络：桥接<br>设置用户名：stack，用户名可自由设置。</p><p>具体安装步骤后续再具体介绍。<br>安装好虚拟机后，启动虚拟机。</p><p>2.2 环境配置<br>2.2.1 给用户stack添加sudo权限<br>echo “stack ALL=(ALL) NOPASSWD: ALL” | sudo tee /etc/sudoers.d/stack<br>2.2.2 配置网卡<br>sudo vi /etc/network/interfaces</p><p>如上图示，设置静态IP。具体IP根据自己的主机环境来设置。<br>设置完后，记得重启网络：sudo /etc/init.d/networking restart。<br>如果更新失败，则重启虚拟机。</p><p>2.2.3 更换Ubuntu源<br>sudo vi /etc/apt/source.list</p><p>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial main restricted<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial-updates main restricted<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a>  xenial universe<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a>  xenial-updates universe<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial multiverse<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial-updates multiverse<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial-backports main restricted universe multiverse<br>deb <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> xenial-security main restricted<br>deb <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> xenial-security universe<br>deb <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> xenial-security multiverse  </p><p>2.2.4 更换pip源<br>创建文件：/home/stack/pip/pip.conf，其内容为：</p><p>[global]<br>index-url = <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>trusted-host = pypi.douban.com  </p><p>2.2.5 安装ssh：sudo apt-get install ssh<br>2.2.6 安装git：<br>sudo apt-get install git</p><p>2.2.7 安装python:<br>sudo apt-get install python</p><p>2.3 准备安装工具devstack<br>2.3.1 下载<br>git clone <a href="https://git.openstack.org/openstack-dev/devstack">https://git.openstack.org/openstack-dev/devstack</a><br>或者<br>git clone <a href="https://github.com/openstack-dev/devstack">https://github.com/openstack-dev/devstack</a><br>2.3.2 切换分支<br>cd devstack<br>git checkout stable/queens</p><p>2.3.4 配置devstack<br>在devstack目录下创建local.conf文件，内容如下：</p><p>[[local|localrc]]<br>ADMIN_PASSWORD=admin<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD</p><h1 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h1><p>KEYSTONE_BRANCH=stable/queens<br>NOVA_BRANCH=stable/queens<br>NEUTRON_BRANCH=stable/queens<br>SWIFT_BRANCH=stable/queens<br>GLANCE_BRANCH=stable/queens<br>CINDER_BRANCH=stable/queens</p><h1 id="Use-mirror"><a href="#Use-mirror" class="headerlink" title="Use mirror"></a>Use mirror</h1><p>GIT_BASE=<a href="http://git.trystack.cn">http://git.trystack.cn</a><br>NOVNC_REPO=<a href="http://git.trystack.cn/kanaka/noVNC.git">http://git.trystack.cn/kanaka/noVNC.git</a><br>SPICE_REPO=<a href="http://git.trystack.cn/git/spice/spice-html5.git">http://git.trystack.cn/git/spice/spice-html5.git</a></p><h1 id="Enable-heat-services"><a href="#Enable-heat-services" class="headerlink" title="Enable heat services"></a>Enable heat services</h1><p>enable_service h-eng h-api h-api-cfn h-api-cw</p><h1 id="Enable-heat-plugin"><a href="#Enable-heat-plugin" class="headerlink" title="Enable heat plugin"></a>Enable heat plugin</h1><p>enable_plugin heat <a href="http://git.trystack.cn/openstack/heat.git">http://git.trystack.cn/openstack/heat.git</a> stable/queens</p><p>IMAGE_URL_SITE=”<a href="http://download.fedoraproject.org&quot;">http://download.fedoraproject.org&quot;</a><br>IMAGE_URL_PATH=”/pub/fedora/linux/releases/25/CloudImages/x86_64/images/“<br>IMAGE_URL_FILE=”Fedora-Cloud-Base-25-1.3.x86_64.qcow2”<br>IMAGE_URLS+=”,”$IMAGE_URL_SITE$IMAGE_URL_PATH$IMAGE_URL_FILE</p><h1 id="Service-Dashboard-IP"><a href="#Service-Dashboard-IP" class="headerlink" title="Service/Dashboard IP"></a>Service/Dashboard IP</h1><p>FLOATING_RANGE=192.168.1.224/27<br>HOST_IP=172.20.10.6<br>FLAT_INTERFACE=enp0s3  </p><p>说明：172.20.10.6是虚拟机的IP地址。</p><p>三、安装OpenStack<br>切换到stack用户，在devstack目录下，执行脚本：./stack.sh，然后就是耐心等待。根据网络状况，等待从半小时到几个小时。<br>安装成功的提示：</p><p><a href="https://www.cnblogs.com/rhjeans/p/11328346.html">https://www.cnblogs.com/rhjeans/p/11328346.html</a></p><p>k8s:</p><p>docker login –username=17780517563 registry.cn-hangzhou.aliyuncs.com</p><p>docker tag gcr.io/google_containers/etcd:2.0.12 registry.cn-hangzhou.aliyuncs.com/huo_public/etcd:2.0.12<br>docker push registry.cn-hangzhou.aliyuncs.com/huo_public/etcd:2.0.12<br>docker images –digests<br>docker pull registry.cn-hangzhou.aliyuncs.com/lixin0120/kubernetes_etcd:3.3.10</p><p>docker run –net=host -d gcr.io/google_containers/etcd:2.0.12 /usr/local/bin/etcd –addr=127.0.0.1:4001 –bind-addr=0.0.0.0:4001 –data-dir=/var/etcd/data<br>CentOS 7</p><pre><code>sudo cp -n /lib/systemd/system/docker.service /etc/systemd/system/docker.servicesudo sed -i &quot;s|ExecStart=/usr/bin/docker daemon|ExecStart=/usr/bin/docker daemon --registry-mirror=https://s75dbt4b.mirror.aliyuncs.com|g&quot; /etc/systemd/system/docker.servicesudo sed -i &quot;s|ExecStart=/usr/bin/dockerd|ExecStart=/usr/bin/dockerd --registry-mirror=https://s75dbt4b.mirror.aliyuncs.com|g&quot; /etc/systemd/system/docker.servicesudo systemctl daemon-reloadsudo service docker restart      </code></pre><p>docker run –net=host -d registry.cn-hangzhou.aliyuncs.com/lixin0120/kubernetes_etcd:3.3.10 /usr/local/bin/etcd –addr=127.0.0.1:4001 –bind-addr=0.0.0.0:4001 –data-dir=/var/etcd/data</p><p>第一步：运行Etcd</p><p>docker run –net=host -d gcr.io/google_containers/etcd:2.0.12 /usr/local/bin/etcd –addr=127.0.0.1:4001 –bind-addr=0.0.0.0:4001 –data-dir=/var/etcd/data</p><p>docker run –net=host -d registry.cn-hangzhou.aliyuncs.com/lixin0120/kubernetes_etcd:3.3.10 /usr/local/bin/etcd –addr=127.0.0.1:4001 –bind-addr=0.0.0.0:4001 –data-dir=/var/etcd/data</p><p>第二步：启动master</p><h1 id="docker-pull-registry-cn-hangzhou-aliyuncs-com-google-kubernetes-container-kubernetes-v1-9-6"><a href="#docker-pull-registry-cn-hangzhou-aliyuncs-com-google-kubernetes-container-kubernetes-v1-9-6" class="headerlink" title="docker pull registry.cn-hangzhou.aliyuncs.com/google-kubernetes-container/kubernetes:v1.9.6"></a>docker pull registry.cn-hangzhou.aliyuncs.com/google-kubernetes-container/kubernetes:v1.9.6</h1><p>docker pull  registry.cn-hangzhou.aliyuncs.com/kubernetes-zy/hyperkube:v1.11.3<br>docker run <br>    –volume=/:/rootfs:ro <br>    –volume=/sys:/sys:ro <br>    –volume=/dev:/dev <br>    –volume=/var/lib/docker/:/var/lib/docker:ro <br>    –volume=/var/lib/kubelet/:/var/lib/kubelet:rw <br>    –volume=/var/run:/var/run:rw <br>    –net=host <br>    –pid=host <br>    –privileged=true <br>    -d <br>    registry.cn-hangzhou.aliyuncs.com/kubernetes-zy/hyperkube:v1.11.3 <br>    /hyperkube kubelet –containerized –hostname-override=”127.0.0.1” –address=”0.0.0.0” –api-servers=<a href="http://localhost:8080">http://localhost:8080</a> –config=/etc/kubernetes/manifests</p><p>这一步实际上运行的是 kubelet ，并启动了一个包含其他master组件的[pod](../userguide/pods.md）。</p><p>第三步：运行service proxy</p><p>docker run -d –net=host –privileged registry.cn-hangzhou.aliyuncs.com/kubernetes-zy/hyperkube:v1.11.3 /hyperkube proxy –master=<a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a> –v=2<br>测试<br>此时你应该已经运行起了一个Kubernetes集群。你可以下载kubectl二进制程序进行测试：</p><p>(OS X) (linux)<br>注意： 再OS/X上你需要通过ssh设置端口转发：</p><p>boot2docker ssh -L8080:localhost:8080<br>列出集群中的节点：</p><p>kubectl get nodes<br>应该输出以下内容：</p><p>NAME LABELS STATUS<br>127.0.0.1 Ready<br>如果你运行了不同的Kubernetes集群，你可能需要指定 -s <a href="http://localhost:8080">http://localhost:8080</a> 选项来访问本地集群。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于每一个刚接触到OpenStack的新人而言，安装无疑是最困难的，同时这也客观上提高了大家学习OpenStack云计算的技术门槛。想一想，自己3年前网上偶然接触到OpenStack时，一头茫然，手动搭建一个多节点环境时居然用了3个星期。&lt;/p&gt;
&lt;p&gt;时至今日，真是感触颇多，从某种角度而言，也很庆幸当时自己并未因困难而放弃OpenStack，否则，应该是去做其他领域了吧！&lt;/p&gt;
&lt;p&gt;言归正传，咱们就来数落数落部署OpenStack都有哪些方式吧。这里，我们根据使用者群体的不同类型来进行分类和归纳：&lt;/p&gt;
&lt;p&gt;个人使用方面&lt;/p&gt;
&lt;p&gt;DevStack&lt;/p&gt;
&lt;p&gt;无疑，在可预见的未来时间内，DevStack仍将是众多开发者们的首选安装方式或工具。该方式主要是通过配置参数，执行shell脚本来安装一个OpenStack的开发环境。&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/openstack-dev/devstack&quot;&gt;https://github.com/openstack-dev/devstack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Wiki: &lt;a href=&quot;https://wiki.openstack.org/wiki/DevStack&quot;&gt;https://wiki.openstack.org/wiki/DevStack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rdo&lt;/p&gt;
&lt;p&gt;Rdo是由Red Hat开源的一款部署OpenStack的工具，同DevStack一样，支持单节点和多节点部署。但Rdo只支持CentOS系列的操作系统。需要注意的是，该项目并不属于OpenStack官方社区项目。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="https://yxzhizhi.github.io/2020/04/12/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>https://yxzhizhi.github.io/2020/04/12/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2020-04-12T07:10:04.000Z</published>
    <updated>2020-04-12T14:18:04.021Z</updated>
    
    <content type="html"><![CDATA[<h3 id="私有云平台环境-OpenStack-CloudStack"><a href="#私有云平台环境-OpenStack-CloudStack" class="headerlink" title="私有云平台环境 OpenStack\CloudStack"></a>私有云平台环境 OpenStack\CloudStack</h3><h3 id="Istio-是当前Service-Mesh领域最完善的解决方案"><a href="#Istio-是当前Service-Mesh领域最完善的解决方案" class="headerlink" title="Istio 是当前Service Mesh领域最完善的解决方案"></a>Istio 是当前Service Mesh领域最完善的解决方案</h3><p>![<a href="https://www.servicemesher.com/blog/supergloo-a-service-mesh-orchestrator/]">https://www.servicemesher.com/blog/supergloo-a-service-mesh-orchestrator/]</a><br>[<a href="https://blog.csdn.net/weixin_38669561/article/details/88944460]">https://blog.csdn.net/weixin_38669561/article/details/88944460]</a><br>[<a href="https://blog.csdn.net/lQ1NS259ej3OKYvK4Jf/article/details/82880131]">https://blog.csdn.net/lQ1NS259ej3OKYvK4Jf/article/details/82880131]</a><br>[<a href="https://cloud.tencent.com/developer/article/1356425]">https://cloud.tencent.com/developer/article/1356425]</a></p><p>第一种方法可以是一种基本的方法，其中Kubernetes与OpenStack共存来管理容器。它提供了良好的性能，但你不能通过单个pane来管理统一的基础设施资源。这会导致与跨工作负载规划和设计策略的相关问题。此外，很难诊断任何影响运行资源性能的问题。</p><p>第二种方法是在OpenStack管理的VM中运行Kubernetes集群。这使得基于OpenStack的基础设施能够在集中管理的OpenStack控制系统中利用kubernetes的优点。此外，它还允许OpenStack环境中的容器具有全功能的多租户和安全性优势。然而，这会导致性能滞后，需要额外的工作流程来管理托管Kubernetes的VM。</p><p>第三种方法是一种创新的方法，倾向于完全云原生环境。在这种方法中，OpenStack可以替换Kubernetes来管理容器和VM。工作负载完全利用了硬件加速器、智能网卡等。通过这种方法，可以为任何数据中心提供带有容器工作负载的集成VNS解决方案，但这需要改进OpenStack中的网络功能（SFC、Provider Networks、Segmentation）。</p><p>LinkedIn上Michiel Manten写了一篇非常不错的帖子。他说，容器和VM各有缺点。两者都有自己的用例和编排工具。如果将OpenStack和Kubernetes恰当地结合起来，在VM中运行一些工作负载，从而在服务器和容器中获得隔离的好处，那么OpenStack和Kubernetes将相得益彰。实现这种组合的一种方法是在OpenStack中的VM中运行Kubernetes集群，这样可以消除容器的安全隐患，同时利用VM的可靠性和弹性。</p><p>OpenStack支持目前使用的大多数企业存储和网络系统。在OpenStack上运行Kubernetes可以实现容器与IT基础设施的无缝集成。无论你是想用裸机或VM运行容器化应用程序，OpenStack都允许你以最适合业务的方式运行容器。</p><p>ESContainer\Mirantis </p><h3 id="k8s-docker-大数据环境"><a href="#k8s-docker-大数据环境" class="headerlink" title="k8s docker 大数据环境"></a>k8s docker 大数据环境</h3><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><h4 id="OpenStack-环境安装"><a href="#OpenStack-环境安装" class="headerlink" title="OpenStack 环境安装"></a>OpenStack 环境安装</h4><p>宿主机系统:ubuntu 18.04<br>虚拟机系统kvm：模拟多台主机<br>centos7-min-1908 1C1G 10G<br>centos7-min-1908 1C1G 10G</p><p>2.虚拟机环境配置</p><p>连接网络:CentOS最小安装不会自己联网，需要稍微配置一下</p><pre><code class="bash">vi /etc/sysconfig/network-scripts/ifcfg-eth0/ens33 # 将ONBOOT条目修改为：ONBOOT=yesservice network restart # 重启网络service sshd restart# 便于我们使用ssh连接服务器，以使用复制粘贴的方法输入命令yum install -y net-tools wget  #安装网络工具</code></pre><pre><code class="bash">ifconfig[192.168.122.48]ssh root@ip</code></pre><p>换源:虽然CentOS可以自动判断最快的源，但是为了以防万一，我们将源换为阿里云。</p><pre><code class="bash">yum install -y net-tools wget curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo curl -o /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo</code></pre><p>安装openstack源<br>阿里云只保存最近几个版本的openstack，所以需要我们手动确认最新版是哪个，前往<a href="https://mirrors.aliyun.com/centos/7/cloud/x86_64/查看openstack版本。版本号采用字母表命名法，我选的是train版">https://mirrors.aliyun.com/centos/7/cloud/x86_64/查看openstack版本。版本号采用字母表命名法，我选的是train版</a><br><a href="http://mirrors.aliyun.com/centos/7.7.1908/cloud/x86_64/">http://mirrors.aliyun.com/centos/7.7.1908/cloud/x86_64/</a><br><a href="http://mirrors.aliyun.com/centos/7/cloud/x86_64/">http://mirrors.aliyun.com/centos/7/cloud/x86_64/</a></p><pre><code class="bash"># 添加源cat &gt; /etc/yum.repos.d/openstack-train.repo &lt;&lt; EOF[openstack-train]name=openstacktrainbaseurl=https://mirrors.aliyun.com/centos/7/cloud/x86_64/openstack-train/failovermethod=priorityenabled=1gpgcheck=0EOF# 查看源cat /etc/yum.repos.d/openstack-train.repo# 更新系统软件 yum clean all &amp;&amp; yum makecache# 设置环境变量：vi /etc/environment# 添加内容：LANG=en_US.utf-8LC_ALL=en_US.utf-8# 禁用各种安全机制systemctl stop firewalldsystemctl disable firewalldsystemctl stop NetworkManagersystemctl disable NetworkManagervi /etc/selinux/config    SELINUX=disabledsetenforce 0getenforce</code></pre><pre><code class="bash">hostnamectl set-hostname controller &amp;&amp; bash</code></pre><p><a href="http://mirrors.aliyun.com/centos/7/cloud/x86_64/openstack-train/">http://mirrors.aliyun.com/centos/7/cloud/x86_64/openstack-train/</a></p><p>备份虚拟机</p><p>多合一（AIO）构建是一种执行OpenStack-Ansible构建的好方法：<br><a href="https://docs.openstack.org/openstack-ansible/latest/user/aio/quickstart.html">https://docs.openstack.org/openstack-ansible/latest/user/aio/quickstart.html</a></p><p>oVirt<br>[<a href="https://blog.csdn.net/bbwangj/article/details/80263654?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3]">https://blog.csdn.net/bbwangj/article/details/80263654?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3]</a></p><h4 id="进行安装"><a href="#进行安装" class="headerlink" title="进行安装"></a>进行安装</h4><pre><code class="bash">yum search all openstack-trainyum install -y centos-release-openstack-trainpackstack --allinone# 持续一小时左右，会报错，报错之后服务器部署好了，但还不能访问面板# 我们需要使用报错生成的应答文件再次安装packstack --answer-file packstack-answers# 这里的时间随你的安装时间而变化.txt</code></pre><pre><code>tar -zxvf openstack-ansible-stable_train.tar.gz scripts/bootstrap-ansible.shscripts/bootstrap-aio.sh# cd /opt/openstack-ansible/playbooks# openstack-ansible setup-hosts.yml# openstack-ansible setup-infrastructure.yml# openstack-ansible setup-openstack.yml</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;私有云平台环境-OpenStack-CloudStack&quot;&gt;&lt;a href=&quot;#私有云平台环境-OpenStack-CloudStack&quot; class=&quot;headerlink&quot; title=&quot;私有云平台环境 OpenStack\CloudStack&quot;&gt;&lt;/a&gt;私有云平台环境 OpenStack\CloudStack&lt;/h3&gt;&lt;h3 id=&quot;Istio-是当前Service-Mesh领域最完善的解决方案&quot;&gt;&lt;a href=&quot;#Istio-是当前Service-Mesh领域最完善的解决方案&quot; class=&quot;headerlink&quot; title=&quot;Istio 是当前Service Mesh领域最完善的解决方案&quot;&gt;&lt;/a&gt;Istio 是当前Service Mesh领域最完善的解决方案&lt;/h3&gt;&lt;p&gt;![&lt;a href=&quot;https://www.servicemesher.com/blog/supergloo-a-service-mesh-orchestrator/]&quot;&gt;https://www.servicemesher.com/blog/supergloo-a-service-mesh-orchestrator/]&lt;/a&gt;&lt;br&gt;[&lt;a href=&quot;https://blog.csdn.net/weixin_38669561/article/details/88944460]&quot;&gt;https://blog.csdn.net/weixin_38669561/article/details/88944460]&lt;/a&gt;&lt;br&gt;[&lt;a href=&quot;https://blog.csdn.net/lQ1NS259ej3OKYvK4Jf/article/details/82880131]&quot;&gt;https://blog.csdn.net/lQ1NS259ej3OKYvK4Jf/article/details/82880131]&lt;/a&gt;&lt;br&gt;[&lt;a href=&quot;https://cloud.tencent.com/developer/article/1356425]&quot;&gt;https://cloud.tencent.com/developer/article/1356425]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一种方法可以是一种基本的方法，其中Kubernetes与OpenStack共存来管理容器。它提供了良好的性能，但你不能通过单个pane来管理统一的基础设施资源。这会导致与跨工作负载规划和设计策略的相关问题。此外，很难诊断任何影响运行资源性能的问题。&lt;/p&gt;
&lt;p&gt;第二种方法是在OpenStack管理的VM中运行Kubernetes集群。这使得基于OpenStack的基础设施能够在集中管理的OpenStack控制系统中利用kubernetes的优点。此外，它还允许OpenStack环境中的容器具有全功能的多租户和安全性优势。然而，这会导致性能滞后，需要额外的工作流程来管理托管Kubernetes的VM。&lt;/p&gt;
&lt;p&gt;第三种方法是一种创新的方法，倾向于完全云原生环境。在这种方法中，OpenStack可以替换Kubernetes来管理容器和VM。工作负载完全利用了硬件加速器、智能网卡等。通过这种方法，可以为任何数据中心提供带有容器工作负载的集成VNS解决方案，但这需要改进OpenStack中的网络功能（SFC、Provider Networks、Segmentation）。&lt;/p&gt;
&lt;p&gt;LinkedIn上Michiel Manten写了一篇非常不错的帖子。他说，容器和VM各有缺点。两者都有自己的用例和编排工具。如果将OpenStack和Kubernetes恰当地结合起来，在VM中运行一些工作负载，从而在服务器和容器中获得隔离的好处，那么OpenStack和Kubernetes将相得益彰。实现这种组合的一种方法是在OpenStack中的VM中运行Kubernetes集群，这样可以消除容器的安全隐患，同时利用VM的可靠性和弹性。&lt;/p&gt;
&lt;p&gt;OpenStack支持目前使用的大多数企业存储和网络系统。在OpenStack上运行Kubernetes可以实现容器与IT基础设施的无缝集成。无论你是想用裸机或VM运行容器化应用程序，OpenStack都允许你以最适合业务的方式运行容器。&lt;/p&gt;
&lt;p&gt;ESContainer\Mirantis &lt;/p&gt;
&lt;h3 id=&quot;k8s-docker-大数据环境&quot;&gt;&lt;a href=&quot;#k8s-docker-大数据环境&quot; class=&quot;headerlink&quot; title=&quot;k8s docker 大数据环境&quot;&gt;&lt;/a&gt;k8s docker 大数据环境&lt;/h3&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git常用</title>
    <link href="https://yxzhizhi.github.io/2020/04/09/git%E5%B8%B8%E7%94%A8/"/>
    <id>https://yxzhizhi.github.io/2020/04/09/git%E5%B8%B8%E7%94%A8/</id>
    <published>2020-04-09T13:23:54.000Z</published>
    <updated>2020-12-07T12:36:35.955Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="text">git clone只能clone远程库的master分支，无法clone所有分支，解决办法如下：1. 找一个干净目录，假设是git_work2. cd git_work3. git clone http://myrepo.xxx.com/project/.git ,这样在git_work目录下得到一个project子目录4. cd project5. git branch -a，列出所有分支名称如下：remotes/origin/devremotes/origin/release6. git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支7. git checkout -b release origin/release，作用参见上一步解释8. git checkout dev，切换回dev分支，并开始开发。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code class=&quot;text&quot;&gt;git clone只能clone远程库的master分支，无法clone所有分支，解决办法如下：
1. 找一个干净目录，假设是git_work
2. cd git_work
3. git clone http://myrepo.xxx.com/project/.git ,这样在git_work目录下得到一个project子目录
4. cd project
5. git branch -a，列出所有分支名称如下：
remotes/origin/dev
remotes/origin/release
6. git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支
7. git checkout -b release origin/release，作用参见上一步解释
8. git checkout dev，切换回dev分支，并开始开发。
&lt;/code&gt;&lt;/pre&gt;

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>conda 虚拟环境</title>
    <link href="https://yxzhizhi.github.io/2020/04/09/conda-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>https://yxzhizhi.github.io/2020/04/09/conda-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</id>
    <published>2020-04-09T03:55:04.000Z</published>
    <updated>2020-07-15T13:44:30.575Z</updated>
    
    <content type="html"><![CDATA[<p>无法加载文件 <strong>**</strong>.ps1，因为在此系统中禁止执行脚本。有关详细信息<br>在powershell中执行 set-ExecutionPolicy RemoteSigned</p><p>conda</p><p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。</p><p>安装可以下载一个科学计算包anaconda，怕麻烦的人可以直接安装，自带很多必须包</p><p>清华镜像下载地址，<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p><p>创建</p><p>conda create –name py3 python=3.7</p><p>使用<br>conda env list #查看当前存在的虚拟环境</p><p>source activate py3 #激活虚拟环境 activate py3 windows下</p><p>conda install numpy #安装包</p><p>source deactivate #退出虚拟环境</p><p>conda remove -n py3 –all #删除虚拟环境</p><p>1、首先在所在系统中安装Anaconda。可以打开命令行输入conda -V检验是否安装以及当前conda的版本。</p><p>2、conda常用的命令。</p><pre><code>1）conda list 查看安装了哪些包。2）conda env list 或 conda info -e 查看当前存在哪些虚拟环境3）conda update conda 检查更新当前conda4）conda --version 查询conda版本5）conda -h 查询conda的命令使用</code></pre><p>3、创建python虚拟环境。</p><pre><code> 使用 conda create -n your_env_name python=X.X（2.7、3.6等)命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。 注意：默认的情况下只安装了一些必须的包，并不会像我们安装anaconda时自动安装很多常用的包。要实现上面的功能，则须在末尾加上‘anaconda’，完整命令是：conda create -n your_env_name python=X.X anaconda</code></pre><p>4、使用激活(或切换不同python版本)的虚拟环境。</p><pre><code>打开命令行输入python --version可以检查当前python的版本。使用如下命令即可 激活你的虚拟环境(即将python的版本改变)。Linux:  source activate your_env_name(虚拟环境名称)Windows: activate your_env_name(虚拟环境名称)</code></pre><p>   这是再使用python –version可以检查当前python版本是否为想要的。</p><p>5、对虚拟环境中安装额外的包。</p><pre><code>使用命令conda install -n your_env_name [package]即可安装package到your_env_name中</code></pre><p>6、关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)。</p><p>   使用如下命令即可。</p><p>   Linux: source deactivate</p><p>   Windows: deactivate</p><p>7、删除虚拟环境。</p><p>   使用命令conda remove -n your_env_name(虚拟环境名称) –all， 即可删除。</p><p>8、删除环境中的某个包。</p><p>   使用命令conda remove –name your_env_name  package_name 即可。</p><pre><code class="bash">conda create -n rest_xops python=3.7.6source activate rest_xops # conda activate rest_xopsconda install -n rest_xops [package]source deactivate # conda deactivate# removeconda remove --name rest_xops package_nameconda remove -n rest_xops --all</code></pre><p>设置国内镜像<br>如果需要安装很多packages，你会发现conda下载的速度经常很慢，因为Anaconda.org的服务器在国外。所幸的是，清华TUNA镜像源有Anaconda仓库的镜像，我们将其加入conda的配置即可：</p><p>1 # 添加Anaconda的TUNA镜像<br>2 conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>3 # TUNA的help中镜像地址加有引号，需要去掉<br>4<br>5 # 设置搜索时显示通道地址<br>6 conda config –set show_channel_urls yes<br> 执行完上述命令后，会生成~/.condarc(Linux/Mac)或C:UsersUSER_NAME.condarc文件，记录着我们对conda的配置，直接手动创建、编辑该文件是相同的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无法加载文件 &lt;strong&gt;**&lt;/strong&gt;.ps1，因为在此系统中禁止执行脚本。有关详细信息&lt;br&gt;在powershell中执行 set-ExecutionPolicy RemoteSigned&lt;/p&gt;
&lt;p&gt;conda&lt;/p&gt;
&lt;p&gt;Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。&lt;/p&gt;
&lt;p&gt;安装可以下载一个科学计算包anaconda，怕麻烦的人可以直接安装，自带很多必须包&lt;/p&gt;
&lt;p&gt;清华镜像下载地址，&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;创建&lt;/p&gt;
&lt;p&gt;conda create –name py3 python=3.7&lt;/p&gt;
&lt;p&gt;使用&lt;br&gt;conda env list #查看当前存在的虚拟环境&lt;/p&gt;
&lt;p&gt;source activate py3 #激活虚拟环境 activate py3 windows下&lt;/p&gt;
&lt;p&gt;conda install numpy #安装包&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>django笔记</title>
    <link href="https://yxzhizhi.github.io/2020/04/07/django%E7%AC%94%E8%AE%B0/"/>
    <id>https://yxzhizhi.github.io/2020/04/07/django%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-07T09:11:48.000Z</published>
    <updated>2020-04-07T10:07:03.940Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Markdown 语法手册 （完整整理版）</title>
    <link href="https://yxzhizhi.github.io/2020/04/07/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C-%EF%BC%88%E5%AE%8C%E6%95%B4%E6%95%B4%E7%90%86%E7%89%88%EF%BC%89/"/>
    <id>https://yxzhizhi.github.io/2020/04/07/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C-%EF%BC%88%E5%AE%8C%E6%95%B4%E6%95%B4%E7%90%86%E7%89%88%EF%BC%89/</id>
    <published>2020-04-07T01:42:33.000Z</published>
    <updated>2020-04-07T05:24:00.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="最小只有六级标题"><a href="#最小只有六级标题" class="headerlink" title="最小只有六级标题"></a>最小只有六级标题</h6><p>加粗<strong>我被加粗了</strong><br>斜体<em>我倾斜了了</em><br>高亮==我高亮了==<br>上标#2^2^<br>下标H<del>2</del>o<br>代码引用（&gt;式）</p><blockquote><p>hello markdown!<br>hello markdown!</p><blockquote><p>hello markdown!<br>代码引用（```式）</p></blockquote></blockquote><pre><code class="python">print(&#39;hello nick&#39;)</code></pre><span id="more"></span><p>代码引入（<code>式）</code>print(‘hello nick’)`<br>插入链接（链接显示）#<br><a href="https://www.cnblogs.com/nickchen121/p/10718112.html">https://www.cnblogs.com/nickchen121/p/10718112.html</a><br>插入链接（链接描述显示）#<br><a href="https://www.cnblogs.com/nickchen121/p/10718112.html" title="nickchen博客">nickchen博客</a><br>插入图片（链接）#<br><img src="http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-%E6%90%9E%E7%AC%91%E7%BB%93%E6%9D%9F.jpg?x-oss-process=style/watermark" alt="数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark" title="描述信息"></p><p>插入图片（图片路径）#<br>绝对路径：.md文本同目录下图片的名字，如数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark</p><p>相对路径：图片在电脑中的路径地址，如\Users\nick\mac\desktop\数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark</p><p><img src="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-%E6%90%9E%E7%AC%91%E7%BB%93%E6%9D%9F.jpg?x-oss-process=style/watermark" alt="数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark" title="描述信息"></p><p><img src="%5CUsers%5Cnick%5Cmac%5Cdesktop%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-%E6%90%9E%E7%AC%91%E7%BB%93%E6%9D%9F.jpg?x-oss-process=style/watermark" alt="数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark" title="描述信息"></p><p>有序列表</p><ol><li>one</li><li>two </li><li>three<br>无序列表</li></ol><ul><li>one</li><li>two</li><li>three<br>分割线#</li></ul><hr><p>表格而且第二行必须得有，并且第二行的冒号代表对齐格式，分别为居中；右对齐；左对齐）：#<br>name | age | sex<br>:-:|:-|-:<br>tony|20|男<br>lucy|18|女</p><p>数学公式（行内嵌）#<br>内嵌数学公式<br>$sum_{i=1}^{10}f(i),,text{thanks}$<br>数学公式（块状）#<br>$$<br>sum_{i=1}^{10}f(i),,text{thanks}<br>$$</p><h3 id="Markdown-编辑器语法指南"><a href="#Markdown-编辑器语法指南" class="headerlink" title="Markdown 编辑器语法指南"></a>Markdown 编辑器语法指南</h3><p>如果你只想高亮语句中的某个函数名或关键字，可以使用 <code>function_name()</code> 实现</p><p>通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 ``` 包裹一段代码，并指定一种语言</p><pre><code class="javascript">$(document).ready(function () &#123;    alert(&#39;hello world&#39;);&#125;);</code></pre><p>支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir</p><p>也可以使用 4 空格缩进，再贴上代码，实现相同的的效果<br>    def g(x):<br>        yield from range(x, 0, -1)<br>    yield from range(x)<br>如你不需要代码高亮，可以用下面的方法禁用：</p><pre><code class="nohighlight">nohighlight</code></pre><p>标题<br>文章内容较多时，可以用标题分段：</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h2 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h2><h3 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h3><h2 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a>粗斜体</h2><p><em>斜体文本</em>    <em>斜体文本</em><br><strong>粗体文本</strong>    <strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong>    <strong><em>粗斜体文本</em></strong></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>文字链接 <a href="http://链接网址">链接名称</a><br>网址链接 <a href="http://链接网址">http://链接网址</a><br>高级链接技巧<br>这个链接用 1 作为网址变量 [Google][1].<br>这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].<br>然后在文档的结尾为变量赋值（网址）<br>  [1]: <a href="http://www.google.com/">http://www.google.com/</a><br>  [yahoo]: <a href="http://www.yahoo.com/">http://www.yahoo.com/</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h4 id="普通无序列表"><a href="#普通无序列表" class="headerlink" title="普通无序列表"></a>普通无序列表</h4><ul><li>列表文本前使用 [减号+空格]</li></ul><ul><li>列表文本前使用 [加号+空格]</li></ul><ul><li>列表文本前使用 [星号+空格]<h4 id="普通有序列表"><a href="#普通有序列表" class="headerlink" title="普通有序列表"></a>普通有序列表</h4></li></ul><ol><li><p>列表前使用 [数字+空格]</p></li><li><p>我们会自动帮你添加数字</p></li><li><p>不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3</p><h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4></li><li><p>列出所有元素：</p><ul><li>无序列表元素 A<ol><li>元素 A 的有序子列表</li></ol></li><li>前面加四个空格</li></ul></li><li><p>列表里的多段换行：<br> 前面必须加四个空格，<br> 这样换行，整体的格式不会乱</p></li><li><p>列表里引用：</p><blockquote><p>前面空一行<br>仍然需要在 &gt;  前面加四个空格</p></blockquote></li><li><p>列表里代码段：</p><pre><code> 前面四个空格，之后按代码语法 ``` 书写</code></pre><pre><code> 或者直接空八个，引入代码块</code></pre></li></ol><h2 id="普通引用"><a href="#普通引用" class="headerlink" title="普通引用"></a>普通引用</h2><blockquote><p>引用文本前使用 [大于号+空格]<br>折行可以不加，新起一行都要加上哦</p></blockquote><h2 id="引用里嵌套引用"><a href="#引用里嵌套引用" class="headerlink" title="引用里嵌套引用"></a>引用里嵌套引用</h2><blockquote><p>最外层引用</p><blockquote><p>多一个 &gt; 嵌套一层引用</p><blockquote><p>可以嵌套很多层</p></blockquote></blockquote></blockquote><h2 id="引用里嵌套列表"><a href="#引用里嵌套列表" class="headerlink" title="引用里嵌套列表"></a>引用里嵌套列表</h2><blockquote><ul><li>这是引用里嵌套的一个列表</li><li>还可以有子列表<ul><li>子列表需要从 - 之后延后四个空格开始</li></ul></li></ul></blockquote><h2 id="引用里嵌套代码块"><a href="#引用里嵌套代码块" class="headerlink" title="引用里嵌套代码块"></a>引用里嵌套代码块</h2><blockquote><pre><code>同样的，在前面加四个空格形成代码块</code></pre><pre><code>或者使用 ``` 形成代码块</code></pre></blockquote><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？<br><img src="http://%E5%9B%BE%E7%89%87%E7%BD%91%E5%9D%80" alt="图片名称"><br>当然，你也可以像网址那样对图片网址使用变量<br>这个链接用 1 作为网址变量 [Google][1].<br>然后在文档的结尾位变量赋值（网址）<br> [1]: <a href="http://www.google.com/logo.png">http://www.google.com/logo.png</a></p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>如果另起一行，只需在当前行结尾加 2 个空格<br>在当前行的结尾加 2 个空格<br>这行就会新起一行<br>如果是要起一个新段落，只需要空出一行即可。</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行：</p><p>前面的段落</p><hr><p>后面的段落</p><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><p>行内 HTML 元素<br>目前只支持部分段内 HTML 元素效果，包括 <kdb> <b> <i> <em> <sup> <sub> <br> ，如</p><h2 id="键位显示"><a href="#键位显示" class="headerlink" title="键位显示"></a>键位显示</h2><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑<br>代码块使用 <pre></pre> 元素同样可以形成代码块<br>粗斜体<b> Markdown 在此处同样适用，如 <em>加粗</em> </b><br>符号转义<br>如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 _ # * 进行避免。<br>_不想这里的文本变斜体_<br>**不想这里的文本被加粗**</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。<br>http://{url_of_the_fiddle}/embedded/[{tabs}/[{style}]]/<br><a href="https://gist.github.com/{gist_id}">https://gist.github.com/{gist_id}</a><br><a href="http://runjs.cn/detail/{id}">http://runjs.cn/detail/{id}</a><br><a href="http://v.youku.com/v_show/id_{video_id}.html">http://v.youku.com/v_show/id_{video_id}.html</a></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：<br>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$</p><p>$$<br>x \href{why-equal.html}{=} y^2 + 1<br>$$</p><p>同时也支持 HTML 属性，如：<br>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$</p><p>$$<br>(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p><h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><p><em>斜体</em>或<em>斜体</em><br><strong>粗体</strong><br><strong><em>加粗斜体</em></strong><br><del>删除线</del></p><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><p>第二种写法：</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题-1"><a href="#四级标题-1" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题-1"><a href="#五级标题-1" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>由于用了[TOC]标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p><h2 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h2><p>语法说明：</p><p>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。<br>代码：</p><p>欢迎来到<a href="http://blog.leanote.com/freewalk">梵居闹市</a><br>欢迎来到<a href="http://blog.leanote.com/freewalk" title="梵居闹市">梵居闹市</a></p><h2 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h2><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。<br>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。<br>代码：<br>我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]<br>[Leanote 笔记][2]是一个不错的[网站][]。<br>[1]:<a href="http://www.google.com">http://www.google.com</a> “Google”<br>[2]:<a href="http://www.leanote.com">http://www.leanote.com</a> “Leanote”<br>[3]:<a href="http://http://blog.leanote.com/freewalk">http://http://blog.leanote.com/freewalk</a> “梵居闹市”<br>[网站]:<a href="http://http://blog.leanote.com/freewalk">http://http://blog.leanote.com/freewalk</a></p><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br>代码：<br><a href="http://example.com/">http://example.com/</a><br><a href="mailto:&#97;&#100;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#x65;&#x78;&#97;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;">&#97;&#100;&#x64;&#x72;&#x65;&#115;&#115;&#64;&#x65;&#x78;&#97;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;</a></p><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。<br>注意： </p><ol><li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。 </li><li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li></ol><p>语法描述：<br>在你准备跳转到的指定标题后插入锚点{ #标记}，然后在文档的其它地方写上连接到锚点的链接。<br>代码：</p><h2 id="0-目录-index"><a href="#0-目录-index" class="headerlink" title="0. 目录{ #index}"></a>0. 目录{ #index}</h2><p>跳转到<a href="#index">目录</a></p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>使用 *，+，- 表示无序列表。<br>代码：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三<br>有序列表</li></ul><hr><p>有序列表则使用数字接着一个英文句点。<br>代码：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三<br>定义型列表</li></ol><hr><dl><dt>语法说明：<br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)<br>代码：<br>Markdown<br>:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）<br>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）<br>        代码块（左侧有八个不可见的空格）<br>列表缩进</dd></dl><hr><p>语法说明：<br>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：</p><p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br>但是如果你懒，那也行：<br>代码：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h2 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h2><p>语法说明：</p><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：</p><p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p><p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p><p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：<br>代码：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br> 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </li><li>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h2 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h2><p>语法说明：<br>如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>代码：</p><ul><li>阅读的方法:<blockquote><p>打开书本。<br>打开电灯。</p></blockquote></li></ul><h2 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h2><p>语法说明：<br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p><p>一列表项包含一个列表区块：</p><p>&lt;代码写在这&gt;</p><h2 id="一个特殊情况"><a href="#一个特殊情况" class="headerlink" title="一个特殊情况"></a>一个特殊情况</h2><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p><ol start="1986"><li>What a great season.<br>会显示成：</li></ol><p>What a great season.<br>换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p><p>1986. What a great season.<br>会显示成：</p><ol start="1986"><li>What a great season.</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>语法说明：</p><p>引用需要在被引用的文本前加上&gt;符号。</p><p>代码：</p><blockquote><p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.</p><p>无意义的占行文字3.<br>无意义的占行文字4.</p></blockquote><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：<br>代码：</p><blockquote><p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.<br>无意义的占行文字3.<br>无意义的占行文字4.<br>显示效果：</p></blockquote><p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.</p><p>无意义的占行文字3.<br>无意义的占行文字4.</p><h2 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h2><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：<br>代码：</p><blockquote><blockquote><blockquote><p>请问 Markdwon 怎么用？ - 小白<br>自己看教程！ - 愤青<br>教程在哪？ - 小白</p></blockquote></blockquote></blockquote><h2 id="引用其它要素"><a href="#引用其它要素" class="headerlink" title="引用其它要素"></a>引用其它要素</h2><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：<br>代码：</p><blockquote><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><p>return shell_exec(“echo $input | $markdown_script”);<br>7. 插入图像<br>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p><p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p><h2 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h2><p>语法说明：![图片Alt](图片地址 “图片Title”)<br>代码：<br>美丽花儿：<br><img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p><h2 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h2><p>语法说明：</p><p>在文档要插入图片的地方写![图片Alt][标记]</p><p>在文档的最后写上[标记]:图片地址 “Title”</p><p>代码：<br>美丽花儿：<br>![美丽花儿][flower]<br>[flower]:<a href="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg">http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg</a>  “美丽花儿”</p><h2 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h2><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p><p>效果参见最上方的目录</p><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>语法说明：</p><p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p><p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p><p>代码：</p><p>使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。<br>[^1]:Markdown是一种纯文本标记语言<br>[^2]:HyperText Markup Language 超文本标记语言<br>[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文<br>显示效果：</p><p>使用 Markdown1可以效率的书写文档, 直接转换成 HTML2, 你可以使用 Leanote3 编辑器进行书写。</p><p>注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</p><h2 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h2><p>$ 表示行内公式：<br>代码：</p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。<br>显示效果：</p><p>质能守恒方程可以用一个很简洁的方程式  来表达。</p><h2 id="表示整行公式："><a href="#表示整行公式：" class="headerlink" title="$$ 表示整行公式："></a>$$ 表示整行公式：</h2><p>代码：<br>$$\sum_{i=1}^n a_i=0$$<br>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$<br>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>代码：<br>flow<br>st=&gt;start: Start:&gt;<a href="https://www.zybuluo.com">https://www.zybuluo.com</a><br>io=&gt;inputoutput: verification<br>op=&gt;operation: Your Operation<br>cond=&gt;condition: Yes or No?<br>sub=&gt;subroutine: Your Subroutine<br>e=&gt;end<br>st-&gt;io-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;sub-&gt;io</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法说明：<br>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br>代码：<br>简单方式写表格：<br>学号|姓名|分数<br>-|-|-<br>小明|男|75<br>小红|女|79<br>小陆|男|92<br>原生方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr><tr><td>为表格第二列指定方向：</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>产品</th><th align="right">价格</th></tr></thead><tbody><tr><td>Leanote 高级账号</td><td align="right">60元/年</td></tr><tr><td>Leanote 超级账号</td><td align="right">120元/年</td></tr></tbody></table><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线</p><p>代码：</p><hr><hr><hr><hr><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。</p><p>语法说明：</p><p>插入行内代码，即插入一个单词或者一句代码的情况，使用<code>code</code>这样的形式插入。<br>插入多行代码，可以使用缩进或者“<code>code “</code>,具体看示例。<br>注意： 缩进式插入前方必须有空行</p><h2 id="行内式-2"><a href="#行内式-2" class="headerlink" title="行内式"></a>行内式</h2><p>代码：</p><p>C语言里的函数 <code>scanf()</code> 怎么使用？<br>缩进式多行代码</p><hr><p>缩进 4 个空格或是 1 个制表符<br>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。<br>代码：</p><pre><code>#include &lt;stdio.h&gt;int main(void)&#123;    printf(&quot;Hello world\n&quot;);&#125;</code></pre><h2 id="用六个-包裹多行代码"><a href="#用六个-包裹多行代码" class="headerlink" title="用六个`包裹多行代码"></a>用六个`包裹多行代码</h2><p>代码：</p><pre><code>#include &lt;stdio.h&gt;int main(void)&#123;    printf(&quot;Hello world\n&quot;);&#125;</code></pre><h2 id="HTML-原始码"><a href="#HTML-原始码" class="headerlink" title="HTML 原始码"></a>HTML 原始码</h2><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p><p>代码：</p><p>第一个例子：</p><div class="footer">   © 2004 Foo Corporation</div>第二个例子：<table>    <tr>        <th rowspan="2">值班人员</th>        <th>星期一</th>        <th>星期二</th>        <th>星期三</th>    </tr>    <tr>        <td>李强</td>        <td>张明</td>        <td>王平</td>    </tr></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Markdown基本语法&quot;&gt;&lt;a href=&quot;#Markdown基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown基本语法&quot;&gt;&lt;/a&gt;Markdown基本语法&lt;/h1&gt;&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h3&gt;&lt;h4 id=&quot;四级标题&quot;&gt;&lt;a href=&quot;#四级标题&quot; class=&quot;headerlink&quot; title=&quot;四级标题&quot;&gt;&lt;/a&gt;四级标题&lt;/h4&gt;&lt;h5 id=&quot;五级标题&quot;&gt;&lt;a href=&quot;#五级标题&quot; class=&quot;headerlink&quot; title=&quot;五级标题&quot;&gt;&lt;/a&gt;五级标题&lt;/h5&gt;&lt;h6 id=&quot;最小只有六级标题&quot;&gt;&lt;a href=&quot;#最小只有六级标题&quot; class=&quot;headerlink&quot; title=&quot;最小只有六级标题&quot;&gt;&lt;/a&gt;最小只有六级标题&lt;/h6&gt;&lt;p&gt;加粗&lt;strong&gt;我被加粗了&lt;/strong&gt;&lt;br&gt;斜体&lt;em&gt;我倾斜了了&lt;/em&gt;&lt;br&gt;高亮==我高亮了==&lt;br&gt;上标#2^2^&lt;br&gt;下标H&lt;del&gt;2&lt;/del&gt;o&lt;br&gt;代码引用（&amp;gt;式）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello markdown!&lt;br&gt;hello markdown!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;hello markdown!&lt;br&gt;代码引用（```式）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print(&amp;#39;hello nick&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java deploy to docker</title>
    <link href="https://yxzhizhi.github.io/2020/04/06/java-deploy-to-docker/"/>
    <id>https://yxzhizhi.github.io/2020/04/06/java-deploy-to-docker/</id>
    <published>2020-04-06T07:36:42.000Z</published>
    <updated>2020-04-07T09:08:26.731Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="ubuntu普通用户登录操作docker提示无权限的解决办法"><a href="#ubuntu普通用户登录操作docker提示无权限的解决办法" class="headerlink" title="ubuntu普通用户登录操作docker提示无权限的解决办法"></a>ubuntu普通用户登录操作docker提示无权限的解决办法</h1><pre><code class="bash">sudo groupadd dockersudo usermod -aG docker $&#123;USER&#125;newgrp docker     #更新用户组docker ps    #测试docker命令是否可以使用sudo正常使用#1 添加docker用户组(一般安装docker时会自动添加)sudo groupadd docker #2 将指定用户添加到docker用户组中 注:将USER替换为自己的用户名sudo gpasswd -a USER docker#3 重启docker服务sudo systemctl restart docker#4 退出SSH连接，重新登录</code></pre><span id="more"></span><h1 id="grep-正则"><a href="#grep-正则" class="headerlink" title="grep 正则"></a>grep 正则</h1><pre><code class="bash">1、或操作grep -E &#39;123|abc&#39; filename  // 找出文件（filename）中包含123或者包含abc的行egrep &#39;123|abc&#39; filename    // 用egrep同样可以实现awk &#39;/123|abc/&#39; filename   // awk 的实现方式2、与操作grep pattern1 files | grep pattern2 //显示既匹配 pattern1 又匹配 pattern2 的行。3、其他操作grep -i pattern files   //不区分大小写地搜索。默认情况区分大小写，grep -l pattern files   //只列出匹配的文件名，grep -L pattern files   //列出不匹配的文件名，grep -w pattern files  //只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），grep -C number pattern files //匹配的上下文分别显示[number]行，</code></pre><h1 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h1><pre><code class="bash"># 根据镜像id删除docker rm $(docker ps -a|grep -E &#39;1b9cf56dec97|4eb9989fc00f&#39;| awk &#39;&#123;print $1&#125;&#39;)docker rm $(docker ps -a|grep 1b9cf56dec97| awk &#39;&#123;print $1&#125;&#39;)# 删除未命名的容器[通常由dockfile文件执行run命令自动产生的中间镜像]docker rmi $(docker images | grep &quot;none&quot; | awk &#39;&#123;print $3&#125;&#39;)</code></pre><p>———————-;</p><h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><pre><code class="bash">1. 获取镜像    ```sudo docker pull oraclelinux```2. 后台运行    ```sudo docker run -itd --name oraclelinux_dev oraclelinux /bin/bash```3. 查询容器    ```sudo docker ps #47e0e5a52244 oraclelinux_dev```4. 进入容器    在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：    ```docker attach  $ sudo docker attach 47e0e5a52244```    注意： 如果从这个容器退出，会导致容器的停止。    docker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。    ```sudo docker exec -it 47e0e5a52244 /bin/bash```5. 导出容器    如果要导出本地某个容器，可以使用 docker export 命令。    ```docker export 47e0e5a52244 &gt; oraclelinux_dev.tar```6. 导入容器快照    可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 oraclelinux_dev.tar 导入到镜像 test/oraclelinux_dev:v1:    ```cat docker/oraclelinux_dev.tar | sudo docker import - dev/oraclelinux_dev:v1```    ```sudo docker import oraclelinux_dev dev/oraclelinux_dev```7. 下面的命令可以清理掉所有处于终止状态的容器。    ```docker container prune```</code></pre><h1 id="用Docker搭建Python的开发环境"><a href="#用Docker搭建Python的开发环境" class="headerlink" title="用Docker搭建Python的开发环境"></a>用Docker搭建Python的开发环境</h1><pre><code class="bash">sudo docker pull python:3.7.6cd /home/zhanghuo/PycharmProjects/db_manage_vuedocker run  -v /home/zhanghuo/PycharmProjects/db_manage_vue:/usr/src/db_manage_vue  -w /usr/src/db_manage_vue python:3.7.6 python ./manage.py runserver注意事项：-v 将主机的py文件目录挂载到容器中的/usr/src/db_manage_vue-w 指定容器的/usr/src/db_manage_vue目录为工作目录python ./manage.py runserver 用容器中的python命令来执行工作目录的pyth.pydockerfileFROM python:3.7.6COPY . /usr/src/db_manage_vueWORKDIR /usr/src/db_manage_vueRUN pip install -r requirements.txtENTRYPOINT [&quot;python&quot;]CMD [&quot;./manage.py runserver&quot;]-- 生成依赖包文件pip freeze &gt; requirements.txt创建镜像sudo docker build -t db_manage_vue/python .运行容器：docker run id/db_manage_vue/python### docker-compose</code></pre><h1 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker compose安装"></a>docker compose安装</h1><h2 id="参考daocloud的https-get-daocloud-io-install-compose"><a href="#参考daocloud的https-get-daocloud-io-install-compose" class="headerlink" title="参考daocloud的https://get.daocloud.io/#install-compose"></a>参考daocloud的<a href="https://get.daocloud.io/#install-compose">https://get.daocloud.io/#install-compose</a></h2><ol><li>github</li></ol><pre><code class="bash">https://github.com/docker/compose/releasescurl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-compose</code></pre><ol><li>daocloud<br>Docker Compose 存放在Git Hub，不太稳定。<br>你可以也通过执行下面的命令，高速安装Docker Compose。</li></ol><pre><code class="bash">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose</code></pre><p>你可以通过修改URL中的版本，可以自定义您的需要的版本。<br>3. 测试安装</p><pre><code class="bash">docker-compose --version</code></pre><h3 id="重命名镜像"><a href="#重命名镜像" class="headerlink" title="重命名镜像"></a>重命名镜像</h3><pre><code class="bash">docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）#例子docker tag ca1b6b825289 registry.cn-hangzhou.aliyuncs.com/xxxxxxx:v1.0</code></pre><h1 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h1><pre><code class="bash"> vi /etc/docker/daemon.json&#123;&quot;registry-mirrors&quot;: [&quot;https://s75dbt4b.mirror.aliyuncs.com&quot;]&#125;</code></pre><p>然后进入到 mysql 容器中将 django 数据库文件导入：</p><pre><code class="bash">#docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; mysql12674#nsenter --target 12674 --mount --uts --ipc --net --pidroot@91308514f209:/# cd /etc/mysql/conf.d/root@91308514f209:/etc/mysql/conf.d# mysql -uroot -p jianshu \&lt; jianshu.sql</code></pre><h1 id="docker-发布-django项目"><a href="#docker-发布-django项目" class="headerlink" title="docker 发布 django项目"></a>docker 发布 django项目</h1><pre><code class="bash">打包django项目先生成需要的python模块列表pip freeze &gt;req.txt然后打包程序tar cvf django1.tar ./django1scp到docker服务器的/python目录下解压确定基础镜像版本docker pull centos:7.3.1611运行此镜像docker run -d -i -v /python:/python -tcentos:7.3.1611-d为后台运行-v 为映射本地目录到docker中准备程序运行环境然后进入到运行的docker中，安装需要的软件包以及模块yum install xxxxpip install –r req.txt生成新镜像docker commit bd486b5df131 centos/django运行docker run -itd -p 8000:8000  -v /python:/python -w /python centos/django1python /python/django1/manage.py runserver 0.0.0.0:8000运行的时候使用docker export db509b5a599f &gt;django.tar然后在目标服务器cat django.tar | docker import -centos/django然后新建/python/将django1.tar项目文件传送到目录上，解压运行docker run -itd -p 8000:8000  -v /python:/python -w /python centos/djangopython /python/django1/manage.py runserver 0.0.0.0:8000查看项目库运行日志：docker logs fba7f2b32fb0 -f-docker 发布 django项目 end-</code></pre><pre><code class="bash">base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;chmod +x /usr/local/bin/docker-machine</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;ubuntu普通用户登录操作docker提示无权限的解决办法&quot;&gt;&lt;a href=&quot;#ubuntu普通用户登录操作docker提示无权限的解决办法&quot; class=&quot;headerlink&quot; title=&quot;ubuntu普通用户登录操作docker提示无权限的解决办法&quot;&gt;&lt;/a&gt;ubuntu普通用户登录操作docker提示无权限的解决办法&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;sudo groupadd docker
sudo usermod -aG docker $&amp;#123;USER&amp;#125;
newgrp docker     #更新用户组
docker ps    #测试docker命令是否可以使用sudo正常使用
#1 添加docker用户组(一般安装docker时会自动添加)
sudo groupadd docker 
#2 将指定用户添加到docker用户组中 注:将USER替换为自己的用户名
sudo gpasswd -a USER docker
#3 重启docker服务
sudo systemctl restart docker
#4 退出SSH连接，重新登录&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="java,docker" scheme="https://yxzhizhi.github.io/tags/java-docker/"/>
    
  </entry>
  
  <entry>
    <title>使用帮助文档</title>
    <link href="https://yxzhizhi.github.io/2020/04/05/%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>https://yxzhizhi.github.io/2020/04/05/%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2020-04-05T12:14:00.000Z</published>
    <updated>2020-04-05T13:33:24.511Z</updated>
    
    <content type="html"><![CDATA[<p>hexo</p><pre><code class="javascript">https://hexo.io/zh-cn/docs/</code></pre><span id="more"></span><p>Hexo-Next-主题优化</p><pre><code class="bash">https://www.jianshu.com/p/428244cd2caa</code></pre><p>Hexo+NexT（零）：最全Hexo+Next搭建博客教程</p><pre><code class="bash">https://blog.csdn.net/loze/article/details/94206726</code></pre><p>Hexo | NexT打造一个炫酷博客</p><pre><code class="bash">https://blog.csdn.net/u012294515/article/details/83094693?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;https://hexo.io/zh-cn/docs/
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>126mail</title>
    <link href="https://yxzhizhi.github.io/2020/04/05/126%E9%82%AE%E7%AE%B1/"/>
    <id>https://yxzhizhi.github.io/2020/04/05/126%E9%82%AE%E7%AE%B1/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-04-05T13:10:25.527Z</updated>
    
    <content type="html"><![CDATA[<pre><code>成功开启IMAP/SMTP服务，在第三方客户端登录时，登录密码输入以下授权密码DDOVIWIXCWQIEUFX授权密码只显示一次</code></pre><span id="more"></span>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;成功开启IMAP/SMTP服务，在第三方客户端登录时，登录密码输入以下授权密码
DDOVIWIXCWQIEUFX
授权密码只显示一次&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="mail" scheme="https://yxzhizhi.github.io/categories/mail/"/>
    
      <category term="back" scheme="https://yxzhizhi.github.io/categories/mail/back/"/>
    
    
      <category term="back" scheme="https://yxzhizhi.github.io/tags/back/"/>
    
  </entry>
  
  <entry>
    <title>eclipse/che</title>
    <link href="https://yxzhizhi.github.io/2020/04/05/Docker%E6%90%AD%E5%BB%BAMySQL%E6%9C%8D%E5%8A%A1/"/>
    <id>https://yxzhizhi.github.io/2020/04/05/Docker%E6%90%AD%E5%BB%BAMySQL%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-04-05T15:46:55.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker搭建MySQL服务"><a href="#Docker搭建MySQL服务" class="headerlink" title="Docker搭建MySQL服务"></a><a href="https://www.cnblogs.com/pwc1996/p/5425234.html">Docker搭建MySQL服务</a></h1><h1 id="Docker开源镜像"><a href="#Docker开源镜像" class="headerlink" title="Docker开源镜像"></a>Docker开源镜像</h1><p>前面我们已经安装好了Docker，也简单了解了Docker。那么我们可以尝试搭建一个MySQL服务。</p><p>要搭建服务就要启动服务容器，要创建容易就要有镜像，Docker提供了一个类似Github的开源平台，提供开源镜像，放心可靠。（毕竟大家都看着源码呢）</p><span id="more"></span><p><a href="https://hub.docker.com/">Docker开源镜像传送门</a></p><hr><h1 id="大概步骤"><a href="#大概步骤" class="headerlink" title="大概步骤"></a>大概步骤</h1><p><strong>1. 下载MySQL镜像</strong><br><strong>2. 创建运行容器</strong></p><blockquote><p>好像很简单是吧？</p></blockquote><hr><h1 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h1><h2 id="第零步，查看Docker-MySQL文档"><a href="#第零步，查看Docker-MySQL文档" class="headerlink" title="第零步，查看Docker MySQL文档"></a>第零步，查看Docker MySQL文档</h2><p>MySQL文档地址：<br><a href="https://hub.docker.com/_/mysql/">https://hub.docker.com/_/mysql/</a></p><hr><h2 id="第一步，拉取MySQL镜像"><a href="#第一步，拉取MySQL镜像" class="headerlink" title="第一步，拉取MySQL镜像"></a>第一步，拉取MySQL镜像</h2><pre><code>$ sudo docker pull mysql</code></pre><p>之后docker会自动拉取（下载）MySQL镜像。</p><p>等待同样是漫长的。。。</p><blockquote><p>注意，若提示拉取失败就重复几次，总有一次会成功的。。。没办法，墙内的人民很辛苦</p></blockquote><p>拉取成功后我们查看一下：</p><pre><code>$ sudo docker images</code></pre><p><img src="http://img.blog.csdn.net/20160317140105707" alt="01"></p><hr><h2 id="第二步，创建并启动一个MySQL容器"><a href="#第二步，创建并启动一个MySQL容器" class="headerlink" title="第二步，创建并启动一个MySQL容器"></a>第二步，创建并启动一个MySQL容器</h2><p>输入以下命令：</p><pre><code>$ sudo docker run --name pwc-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql</code></pre><p><img src="http://img.blog.csdn.net/20160317142223778" alt="02"></p><ul><li>–name：给新创建的容器命名，此处命名为<code>pwc-mysql</code></li><li>-e：配置信息，此处配置<code>mysql</code>的<code>root用户</code>的登陆密码</li><li>-p：端口映射，此处映射<code>主机3306端口</code>到<code>容器pwc-mysql的3306端口</code></li><li>-d：成功启动容器后输出容器的完整ID，例如上图 <code>73f8811f669ee...</code></li><li>最后一个<code>mysql</code>指的是<code>mysql镜像名字</code></li></ul><p><strong>到这里我们查看容器运行状态：</strong></p><pre><code>$ sudo docker ps</code></pre><p><img src="http://img.blog.csdn.net/20160317142325183" alt="03"></p><p>上图可以看到容器的简写ID，容器的源镜像，创建时间，状态，端口映射信息，容器名字等。</p><hr><h2 id="第三步，测试连接MySQL"><a href="#第三步，测试连接MySQL" class="headerlink" title="第三步，测试连接MySQL"></a>第三步，测试连接MySQL</h2><p>这里我使用navicat远程连接，连接MySQL前需要防火墙开放端口或者关闭防火墙。</p><p>开放端口：</p><pre><code>$ sudo firewall-cmd --add-port=3306/tcp</code></pre><p>关闭防火墙：</p><pre><code>$ sudo systemctl stop firewalld</code></pre><p>接着使用navicat连接<br><img src="http://img.blog.csdn.net/20160317143333986" alt="04"></p><p>连接成功，也可以进行相关数据库操作，因此MySQL服务搭建成功！</p><hr><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><strong>1.可以启动多个MySQL服务，因为我们启动的是容器，容器可以有多个，只要容器名字映射段端口不一样就可以了，例如：</strong></p><pre><code>$ sudo docker run --name dbdb -e MYSQL_ROOT_PASSWORD=123456 -p 6666:3306 -d mysql</code></pre><p><strong>2.查看所有容器（启动状态或者关闭状态）</strong></p><pre><code>$ sudo docker ps -a</code></pre><p><strong>3.启动和关闭容器</strong></p><p>启动命令：</p><pre><code>$ sudo docker start pwc-mysql   //通过指定容器名字$ sudo docker start 73f8811f669e  //通过指定容器ID</code></pre><p>关闭命令：</p><pre><code>$ sudo docker stop pwc-mysql   //通过指定容器名字$ sudo docker stop 73f8811f669e  //通过指定容器ID</code></pre><p><strong>3.修改MySQL配置文件有两种方法：</strong></p><ul><li><p>一是进入容器，修改容器里的MySQL的配置文件，然后重新启动容器，例如：</p><pre><code>$ sudo docker exec -it pwc-mysql /usr/bin/bash</code></pre><p>然后可以进入容器的命令行模式，接着修改 <code>/etc/mysql/my.cnf</code> 文件即可</p></li><li><p>二是挂载主机的mysql配置文件，官方文档如下：</p><p>The MySQL startup configuration is specified in the file <code>/etc/mysql/my.cnf</code>, and that file in turn includes any files found in the <code>/etc/mysql/conf.d</code> directory that end with .cnf. Settings in files in this directory will augment and/or override settings in <code>/etc/mysql/my.cnf</code>. If you want to use a customized MySQL configuration, you can create your alternative configuration file in a directory on the host machine and then mount that directory location as <code>/etc/mysql/conf.d</code> inside the mysql container.</p><p>If <code>/my/custom/config-file.cnf</code> is the path and name of your custom configuration file, you can start your mysql container like this (note that only the directory path of the custom config file is used in this command):</p><pre><code>$ docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</code></pre><p>This will start a new container some-mysql where the MySQL instance uses the combined startup settings from <code>/etc/mysql/my.cnf</code> and <code>/etc/mysql/conf.d/config-file.cnf</code>, with settings from the latter taking precedence.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker搭建MySQL服务&quot;&gt;&lt;a href=&quot;#Docker搭建MySQL服务&quot; class=&quot;headerlink&quot; title=&quot;Docker搭建MySQL服务&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/pwc1996/p/5425234.html&quot;&gt;Docker搭建MySQL服务&lt;/a&gt;&lt;/h1&gt;&lt;h1 id=&quot;Docker开源镜像&quot;&gt;&lt;a href=&quot;#Docker开源镜像&quot; class=&quot;headerlink&quot; title=&quot;Docker开源镜像&quot;&gt;&lt;/a&gt;Docker开源镜像&lt;/h1&gt;&lt;p&gt;前面我们已经安装好了Docker，也简单了解了Docker。那么我们可以尝试搭建一个MySQL服务。&lt;/p&gt;
&lt;p&gt;要搭建服务就要启动服务容器，要创建容易就要有镜像，Docker提供了一个类似Github的开源平台，提供开源镜像，放心可靠。（毕竟大家都看着源码呢）&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://yxzhizhi.github.io/categories/linux/"/>
    
      <category term="docker" scheme="https://yxzhizhi.github.io/categories/linux/docker/"/>
    
      <category term="mysql" scheme="https://yxzhizhi.github.io/categories/linux/docker/mysql/"/>
    
    
      <category term="mysql" scheme="https://yxzhizhi.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>sql and freemaker format</title>
    <link href="https://yxzhizhi.github.io/2020/04/05/sql%20and%20freemaker%20format/"/>
    <id>https://yxzhizhi.github.io/2020/04/05/sql%20and%20freemaker%20format/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-04-05T11:05:19.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sql-and-freemaker-format"><a href="#sql-and-freemaker-format" class="headerlink" title="sql and freemaker format"></a>sql and freemaker format</h2><ol><li>格式化换行<pre><code>&amp;lt;[\/|#].*?&amp;gt;  \n$0\n</code></pre><span id="more"></span></li><li>删除空行<pre><code>^(\s*)\n 空</code></pre></li><li>sql内容<pre><code class="sql">sql=&quot; $0\n\n&quot; tables= \n\n$0</code></pre></li></ol><p>(&lt;[/|#].<em>?&gt;)|(sql=”)|(“ tables)<br>(&lt;[/|#].</em>?&gt;)</p><p>\n$0\n<br>/// \r$0\r</p><pre><code>4. 删除空行</code></pre><p>^(\s*)\n 空</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;sql-and-freemaker-format&quot;&gt;&lt;a href=&quot;#sql-and-freemaker-format&quot; class=&quot;headerlink&quot; title=&quot;sql and freemaker format&quot;&gt;&lt;/a&gt;sql and freemaker format&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;格式化换行&lt;pre&gt;&lt;code&gt;&amp;amp;lt;[\/|#].*?&amp;amp;gt;  \n$0\n&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="sql" scheme="https://yxzhizhi.github.io/categories/sql/"/>
    
      <category term="format" scheme="https://yxzhizhi.github.io/categories/sql/format/"/>
    
    
      <category term="format" scheme="https://yxzhizhi.github.io/tags/format/"/>
    
  </entry>
  
  <entry>
    <title>eclipse/che</title>
    <link href="https://yxzhizhi.github.io/2020/04/05/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Eclipse%20Che/"/>
    <id>https://yxzhizhi.github.io/2020/04/05/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Eclipse%20Che/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2021-10-23T12:40:24.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h3><pre><code>下载镜像docker pull portainer/portainer基于镜像运行容器docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer  portainer/portainerhttp://172.17.0.1:8080/dashboard/#/ide/che/wksp-tvqqhttp://127.0.0.1:9000/#/networksup: admin/y3</code></pre><span id="more"></span><h3 id="eclipse-che"><a href="#eclipse-che" class="headerlink" title="eclipse/che"></a>eclipse/che</h3><pre><code>启动服务-v /var/…是选择docker文件-v /opt/…是选择容器存放位置-e CHE_HOST 设置主机的IP地址单用户：docker run -ti --rm --name che6 -v /var/run/docker.sock:/var/run/docker.sock -v /home/zhanghuo/LinuxHome/docker/eclipseche:/data  -e CHE_PORT=8080 -e CHE_HOST=192.168.10.225 eclipse/che:6.19.0 start多用户：docker run -ti -e CHE_MULTIUSER=true -v /var/run/docker.sock:/var/run/docker.sock -v /home/zhanghuo/LinuxHome/docker/eclipseche:/data  -e CHE_PORT=8080 -e CHE_HOST=192.168.6.203 eclipse/che:6.19.0 start实际创建:docker run -ti -e CHE_MULTIUSER=true -v /var/run/docker.sock:/var/run/docker.sock -v /home/zhanghuo/LinuxHome/docker/eclipseche:/data  -e CHE_PORT=8080  eclipse/che:6.19.0 start</code></pre><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><pre><code>~/docker-tags eclipse/chesudo docker pull eclipse/che:6.19.0</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code>sudo docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock -v /home/zhanghuo/LinuxHome/docker/eclipseche:/data eclipse/che:6.19.0 start启动完毕后，访问 “http://:8080/” 来验证安装。</code></pre><pre><code>创建 workspace 和 project访问 “Workspaces -&gt; Add Workspace”；在 “New Workspace” 页面选择 “java Default Java Stack with JDK 8, Maven and Tomcat.” 然后 “CREATE &amp; OPEN”；在 “Workspace” 页面，选择 “Create Project…”；在 “Create New Project” 窗口，选择 Java -&gt; Maven 项目，然后输入一个Name，比如: “test”，并进入下一步；勾选 “From Archetype:” 并选择 “org.apache.maven.archetypes:maven-archetype-quickstart:RELEASE”，同时输入 “Artifact ID” 和 “Group ID”，然后 “Create” 来创建工程；运行工程选中并打开工程，然后在 “Manage commands” 依次创建三个 Maven 命令，并运行。buildmvn clean install -f $&#123;current.project.path&#125;1testmvn clean test -f $&#123;current.project.path&#125;1runmvn exec:java -Dexec.mainClass=&quot;test.App&quot; -f $&#123;current.project.path&#125;</code></pre><h3 id="eclipse-che-命令-ubuntu"><a href="#eclipse-che-命令-ubuntu" class="headerlink" title="eclipse/che 命令 -ubuntu"></a>eclipse/che 命令 -ubuntu</h3><h5 id="1-apt-get-update"><a href="#1-apt-get-update" class="headerlink" title="1. apt-get update"></a>1. apt-get update</h5><h5 id="2-安装docker-国内源安装"><a href="#2-安装docker-国内源安装" class="headerlink" title="2. 安装docker,国内源安装"></a>2. <a href="https://link.jianshu.com/?t=https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html">安装docker,国内源安装</a></h5><h5 id="3-配置镜像仓库"><a href="#3-配置镜像仓库" class="headerlink" title="3.配置镜像仓库"></a>3.<a href="https://link.jianshu.com/?t=https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html#ubuntu-1604、debian-8-jessie、centos-7">配置镜像仓库</a></h5><h5 id="4-解决内存溢出的问题"><a href="#4-解决内存溢出的问题" class="headerlink" title="4.解决内存溢出的问题"></a>4.解决内存溢出的问题</h5><pre><code class="javascript">Adjust memory and swap accountingWhen users run Docker, they may see these messages when working with an image:WARNING: Your kernel does not support cgroup swap limit. WARNING: Yourkernel does not support swap limit capabilities. Limitation discarded.To prevent these messages, enable memory and swap accounting on your system. To enable these on system using GNU GRUB (GNU GRand Unified Bootloader), do the following.Log into Ubuntu as a user with sudo privileges.Edit the /etc/default/grub file.Set the GRUB_CMDLINE_LINUX value as follows:GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;Save and close the file.Update GRUB.$ sudo update-grubReboot your system.</code></pre><h5 id="5关闭防火墙"><a href="#5关闭防火墙" class="headerlink" title="5关闭防火墙"></a>5关闭防火墙</h5><p><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/wclwcw/p/6140263.html">网络相关配置</a></p><pre><code class="javascript">ufw disable</code></pre><ul><li>安装</li></ul><pre><code class="javascript">docker pull eclipse/che:5.17.0</code></pre><ul><li>启动(第一次启动需要下载其他镜像)</li></ul><pre><code class="javascript">docker run -it --rm -e CHE_PORT=8120 -v /var/run/docker.sock:/var/run/docker.sock -v /c/8120/tmp:/data eclipse/che:5.17.0 start</code></pre><ul><li>修改che的样式文件，去掉左边导航栏</li></ul><pre><code class="javascript">docker cp /che/index.html che-8120:/home/user/eclipse-che-5.17.0/tomcat/webapps/dashboard</code></pre><ul><li>停止</li></ul><pre><code class="javascript">docker run -it --rm -e CHE_PORT=8120 -v /var/run/docker.sock:/var/run/docker.sock -v /c/8120/tmp:/data eclipse/che:5.17.0 stop</code></pre><ul><li>重启</li></ul><pre><code class="javascript">docker run -it --rm -e CHE_PORT=8120 -v /var/run/docker.sock:/var/run/docker.sock -v /c/8120/tmp:/data eclipse/che:5.17.0 restart</code></pre><ul><li>che API</li></ul><p>启动che的时候的终端返回信息最后一行是che的api地址</p><ul><li>创建che工作空间</li></ul><pre><code class="javascript">curl -X POST -H &#39;Content-Type: application/json&#39; -d &#39;&#123;&quot;name&quot;:&quot;myworkspace&quot;,&quot;projects&quot;:[],&quot;commands&quot;:[&#123;&quot;name&quot;:&quot;build&quot;,&quot;type&quot;:&quot;mvn&quot;,&quot;attributes&quot;:&#123;&quot;goal&quot;:&quot;Build&quot;,&quot;previewUrl&quot;:&quot;&quot;&#125;,&quot;commandLine&quot;:&quot;mvn clean install&quot;],&quot;environments&quot;:&#123;&quot;myworkspace&quot;:&#123;&quot;recipe&quot;:&#123;&quot;location&quot;:&quot;eclipse/ubuntu_jdk8&quot;,&quot;type&quot;:&quot;dockerimage&quot;&#125;,&quot;machines&quot;:&#123;&quot;dev-machine&quot;:&#123;&quot;attributes&quot;:&#123;&quot;memoryLimitBytes&quot;:&quot;2147483648&quot;&#125;,&quot;agents&quot;:[&quot;org.eclipse.che.exec&quot;,&quot;org.eclipse.che.terminal&quot;,&quot;org.eclipse.che.ws-agent&quot;,&quot;org.eclipse.che.ssh&quot;],&quot;servers&quot;:&#123;&#125;&#125;&#125;&#125;&#125;,&quot;defaultEnv&quot;:&quot;myworkspace&quot;,&quot;links&quot;:[]&#125;&#39; http://localhost:8080/api/workspace//其中-d为创建工作空间所需json参数，具体请看下一小节</code></pre><ul><li>修改che的运行时环境</li></ul><p>访问che的webide，点击左侧stacks，在右侧的列表中选择自己需要的运行时环境点进进入详情界面</p><p>下拉找到row configuration，复制其中json数据里的workspaceconfig部分代码（注意只取 “workspaceConfig”:后面的{}已经其中的信息），作为访问创建che工作空间api的参数</p><ul><li>在项目中使用che api需要执行以下命令</li></ul><pre><code class="javascript">git clone http://github.com/eclipse/checd cdegit checkout 5.17.xcd coremvn install</code></pre><ul><li>chedir 初始化工作空间和项目</li></ul><pre><code class="javascript">cd /ChedirDocker/projectmkdir che8081projectcd che8081project//创建Chedir文件docker run -it --rm -e CHE_PORT=8081 -v /var/run/docker.sock:/var/run/docker.sock -v /c/8081/tmp:/data  -v  /ChedirDocker/project/che8081project:/chedir eclipse/che:5.17.0 dir init//进行相应修改vim Chedir//启动容器/var/run/docker.sock:/var/run/docker.sock -v /c/8081/tmp:/data  -v  /ChedirDocker/project/che8081project:/chedir eclipse/che:5.17.0 dir up//销毁容器/var/run/docker.sock:/var/run/docker.sock -v /c/8081/tmp:/data  -v  /ChedirDocker/project/che8081project:/chedir eclipse/che:5.17.0 dir down</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;portainer&quot;&gt;&lt;a href=&quot;#portainer&quot; class=&quot;headerlink&quot; title=&quot;portainer&quot;&gt;&lt;/a&gt;portainer&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;下载镜像
docker pull portainer/portainer
基于镜像运行容器

docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer  portainer/portainer
http://172.17.0.1:8080/dashboard/#/ide/che/wksp-tvqq
http://127.0.0.1:9000/#/networks
up: admin/y3
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://yxzhizhi.github.io/categories/linux/"/>
    
      <category term="che" scheme="https://yxzhizhi.github.io/categories/linux/che/"/>
    
      <category term="eclipse" scheme="https://yxzhizhi.github.io/categories/linux/che/eclipse/"/>
    
    
      <category term="che" scheme="https://yxzhizhi.github.io/tags/che/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://yxzhizhi.github.io/2020/04/05/docker/"/>
    <id>https://yxzhizhi.github.io/2020/04/05/docker/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2020-04-06T12:39:08.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用docker命令"><a href="#常用docker命令" class="headerlink" title="常用docker命令"></a>常用docker命令</h2><span id="more"></span><h4 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h4><pre><code>列表|docker images    |查看本地docker仓库的所有镜像docker images 列出本地所有镜像检索 docker search keywork eg: docker search tomcat 去docker hub搜索镜像的详细信息docker search(-s) nginx 搜索相关镜像　加上-s 参数 选出至少start数范围的镜像docker pull（-a） 镜像名:版本号　拉取镜像,-a pull all拉取 docker pull keywork:tag eg: docker pull tomcat:latest|    tag是可选的，不指定默认拉取latest最新版本&lt;!--more--&gt;docker push 192.168.0.100:5000/ubuntu 　　  推送镜像库到私有源删除|docker rmi imageId eg: docker rmi 6408fdc94212    |删除本地docker仓库镜像docker rmi（-f） 镜像名：版本号/镜像ID 　　删除镜像 （加上 -f 参数 强制删除）docker rmi $(docker images -q)　　删除所有镜像docker rmi $(docker images | grep &quot;none&quot; | awk &#39;&#123;print $3&#125;&#39;) 删除所有名字中带“none” 关键字的镜像sudo docker rmi $(sudo docker images | grep &quot;eclipse&quot; | awk &#39;&#123;print $3&#125;&#39;)docker save docker.io``/tomcat``:7.0.77-jre7 &gt;``/root/mytomcat7``.``tar``.gz 导出镜像`docker load &lt; ``/root/mytomcat7``.``tar``.gz　　导入镜像`</code></pre><pre><code>#基本命令#查看docker服务运行状态sudo systemctl status docker#启动docker服务sudo systemctl start docker#停止docker服务sudo systemctl stop docker#查看所有本地镜像sudo docker images#查看正在运行的容器sudo docker ps#查看所有容器sudo docker ps -a#删除本地镜像 -f表示强制删除(可选)sudo docker rmi -f [镜像id]#删除指定容器 sudo docker rm [容器Id|容器名]--#1 添加docker用户组(一般安装docker时会自动添加)sudo groupadd docker #2 将指定用户添加到docker用户组中 注:将USER替换为自己的用户名sudo gpasswd -a USER docker#3 重启docker服务sudo systemctl restart docker#4 退出SSH连接，重新登录</code></pre><h3 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h3><pre><code>docker ps 查看当前正在运行的容器docker inspect name/image[name/image...] 查看详细docker ps -a 查看所有容器的状态docker start/stop(-t) id/name[name...] 启动/停止某个（多个）容器 -t 指定时间docker kill (-s) name[name...] 强制中断 -s指定SIGINT信号类型，默认“kill”docker restart (-t) name[name...] 重启 -t 指定时间docker pause name　暂停　　docker unpause name 继续docker rm(-$) name[name...] 移除     -f　　--force=false　　强制移除运行中容器    -l　　--link=false　　 移除指定链接，保留底层容器    -v　 --volumes=false  移除容器关联卷docker commit(-$)name 镜像名:版本号 　　提交指定容器为镜像    -a, --author=&quot;&quot; 　　　　作者    -m, --message=&quot;&quot; 　　 简要说明    -p, --pause=true 　　　暂停容器再提交docker logs(-$) name　　输出指定容器日志信息    -f　　跟踪日志输出    -t　　显示时间戳 类似 tail -f    --tail 在日志的末尾输出指定行数日志（默认所有日志）docker attach id 进入某个容器(使用exit退出后容器也跟着停止运行)docker exec -ti id 启动一个伪终端以交互式的方式进入某个容器（使用exit退出后容器不停止运行）docker run(-$) IMAGE [COMMAND] [ARG...] 　 运行一个容器    -d　　　　　　　　  指定容器运行于前台还是后台，默认为false       -i　　　　　　　　  打开STDIN，用于控制台交互，默认为false     -t　　　　　　　　  分配tty设备，该可以支持终端登录，默认为false      -u, --user=&quot;&quot;       指定容器的用户      -a, --attach=[]      登录容器（必须是以docker run -d启动的容器）     -w　　　　　　　　  指定容器的工作目录     -c   　　　　　　　设置容器CPU权重，在CPU共享场景使用      -e, --env=[]        指定环境变量，容器中可以使用该环境变量      -m　　　　　　　　  指定容器的内存上限      -P, --publish-all=false 指定容器暴露的端口      -p, --publish=[]      指定容器暴露的端口      -h　　　　　　　　　指定容器的主机名      -v, --volume=[]      给容器挂载存储卷，挂载到容器的某个目录     --volumes-from=[]    给容器挂载其他容器上的卷，挂载到容器的某个目录     --cap-add=[]　　　　 添加权限    --cap-drop=[]   　 删除权限    --cidfile=&quot;&quot;　　　　　 运行容器后，在指定文件中写入容器PID值，监控系统用法      --cpuset=&quot;&quot;　 　　　 设置容器可使用哪些CPU，此参数可以用来容器独占CPU      --device=[]   　　　  添加主机设备给容器，相当于设备直通      --dns=[]            指定容器的dns服务器      --dns-search=[]      指定容器的dns搜索域名，写入到容器/etc/resolv.conf文件      --entrypoint=&quot;&quot;       覆盖image的入口点      --env-file=[]          指定环境变量文件，文件格式为每行一个环境变量      --expose=[]         指定容器暴露的端口，即修改镜像的暴露端口      --link=[]            指定容器间的关联，使用其他容器的IP、env等信息      --lxc-conf=[]         指定容器的配置文件，只有在指定--exec-driver=lxc时使用      --name=&quot;&quot;          指定容器名字，links特性需要使用名字      --net=&quot;bridge&quot;       容器网络设置:         bridge 使用docker daemon指定的网桥            host  //容器使用主机的网络          container:NAME_or_ID &gt;//使用其他容器的网路共享IP和PORT等网络资源          none 容器使用自己的网络（类似--net=bridge）    --privileged=false     指定容器是否为特权容器，特权容器拥有所有的权限    --restart=&quot;no&quot;        指定容器停止后的重启策略:         no：　　　　容器退出时不重启          on-failure：  容器故障退出（返回值非零）时重启          always：　　 容器退出时总是重启      --rm=false      指定容器停止后自动删除容器(不支持以docker run -d启动的容器)      --sig-proxy=true 设置由代理接受并处理信号，SIGCHLD，SIGSTOP和SIGKILL不代例：docker run -i -t centos6.8 进入到默认的线程”/bin/bash”，直接进入控制台操作docker run -i -t -d centos6.8 进入到默认的线程”/bin/bash”，后台运行docker run -d --restart=always centos6.8 ping www.docker.com 带命令启动docker run -d --name=server-dbcentos6.8-mysql /usr/bin/mysql_safe -d 容器的名称为server-db，同时激活了数据库mysql的后台线程docker run -d --name=server-db -p 3306:3306 -v /server/mysql-data:/mysql-datacentos6.8-mysql /usr/bin/mysql_safe –ddocker run -d --name=server-db -p 3306:3306 centos6.8-mysql /usr/bin/mysql_safe –d 服务器宿主机与容器端口映射并暴露docker run -d --name=server-http --link=server-db  -p 8080:80centos6.8-httpd /usr/bin/httpd --DFOREGROUND 映射服务器宿主机的8080端口，关联service-db docker run -it --rm centos6.8　　容器进程结束后，立马自动删除</code></pre><h4 id="docker-option"><a href="#docker-option" class="headerlink" title="docker option"></a>docker option</h4><pre><code>    --api-enable-cors=false      在远程API中启用CORS 头    -b, --bridge=&quot;&quot;          　　桥接网络 使用“none” 禁用容器网络    --bip=&quot;&quot;             　　　网桥模式                         -d, --daemon=false         守护者模式    -D, --debug=false          debug 模式    --dns=[]             　　  强制 docker 使用指定 dns 服务器    --dns-search=[]         　 强制 docker 使用指定 dns 搜索域    -e, --exec-driver=&quot;native&quot;     强制 docker 运行时使用指定执行驱动器    --fixed-cidr=&quot;&quot;          　　 固定IP的IPv4子网(例: 10.20.0.0/16)必须镶套在桥子网中(由-b or --bip定义)                         -G, --group=&quot;docker&quot;        当在守护模式中运行时，组指向-H指定的unix套接字。使用&quot;&quot;禁用组设置。    -g, --graph=&quot;/var/lib/docker&quot;   容器运行的根目录路径    -H, --host=[]            　 套接字绑定到守护模式。使用一个或多个tcp://主机:端口，unix:///路径/到/套接字，fd://*或fd://socketfd.    --icc=true            　　  inter-container跨容器通信    --insecure-registry=[]        使用指定的注册表启用不安全通信(没有HTTPS的证书验　证和启用HTTP回退)(例如，localhost:5000或10.20.0 /16)    --ip=&quot;0.0.0.0&quot;          　　 绑定容器端口时使用的IP地址    --ip-forward=true           使用net.ipv4.ip_forward转发    --ip-masq=true        使IP伪装成桥的IP范围    --iptables=true          　　启用Docker添加iptables规则    --mtu=0              　　  设置容器网络mtu                   -p, --pidfile=&quot;/var/run/docker.pid&quot;   指定守护进程pid文件位置    --registry-mirror=[]       　　指定一个首选的镜像仓库（加速地址）             -s, --storage-driver=&quot;&quot;        强制 docker 运行时使用指定存储驱动    --selinux-enabled=false       开启 selinux 支持    --storage-opt=[]         　　设置存储驱动选项    --tls=false            　　　 开启 tls    --tlscacert=&quot;/root/.docker/ca.pem&quot;　　只信任提供CA签名的证书    --tlscert=&quot;/root/.docker/cert.pem&quot;    tls 证书文件位置    --tlskey=&quot;/root/.docker/key.pem&quot; 　　 tls key 文件位置    --tlsverify=false         　　　　　 使用 tls 并确认远程控制主机-v,     --version=false   输出 docker 版本信息</code></pre><h1 id="Docker-容器镜像删除"><a href="#Docker-容器镜像删除" class="headerlink" title="Docker 容器镜像删除"></a><a href="https://www.cnblogs.com/q4486233/p/6482711.html">Docker 容器镜像删除</a></h1><pre><code>1.停止所有的container，这样才能够删除其中的images：docker stop $(docker ps -a -q)如果想要删除所有container的话再加一个指令：docker rm $(docker ps -a -q)2.查看当前有些什么imagesdocker images3.删除images，通过image的id来指定删除谁docker rmi &lt;image id&gt;想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;&#123;print $3&#125;&quot;)要删除全部image的话docker rmi $(docker images -q)</code></pre><p><strong>1、导出某个容器</strong><br>导出某个容器，非常简单，使用docker export命令，语法：docker export $container_id &gt; 容器快照名<br><strong>2、导入某个容器</strong>–docker import命令<br>有了容器快照之后，我们可以在想要的时候随时导入。导入快照使用docker import命令。<br>例如我们可以使用cat centos.tar | docker import - my/centos:v888 导入容器快照作为镜像<br>处理本地的容器快照导入为镜像，我们还可以通过指定一个URL或者目录来导入。<br>例如在某个网络上有个快照image_test.tgz：docker import <a href="http://xxxx.com/image_test.tgz">http://xxxx.com/image_test.tgz</a> test/image_test<br><strong>镜像保存/载入</strong>：docker load/docker save；将一个镜像导出为文件，再使用docker load命令将文件导入为一个镜像，会保存该镜像的的所有历史记录。比docker export命令导出的文件大，很好理解，因为会保存镜像的所有历史记录。<br><strong>容器导入/导出</strong>：docker import/docker export；将一个容器导出为文件，再使用docker import命令将容器导入成为一个新的镜像，但是相比docker save命令，容器文件会丢失所有元数据和历史记录，仅保存容器当时的状态，相当于虚拟机快照。<br><strong>3、删除容器</strong><br>可以使用”docker rm 容器id”来删除一个终止状态的容器；若要删除一个运行中的容器，需要加-f参数。</p><h2 id="清除所有未使用或悬空的图像，容器，卷和网络"><a href="#清除所有未使用或悬空的图像，容器，卷和网络" class="headerlink" title="清除所有未使用或悬空的图像，容器，卷和网络"></a><strong>清除所有未使用或悬空的图像，容器，卷和网络</strong></h2><p>Docker提供了一个命令，可以清理悬空的任何资源（图像，容器，卷和网络）（与容器无关）：</p><pre><code class="javascript">docker system prune</code></pre><p>要另外删除任何已停止的容器和所有未使用的图像（不只是悬空图像），请将该<code>-a</code>标志添加到命令：</p><pre><code class="javascript">docker system prune -a</code></pre><h2 id="删除Docker镜像"><a href="#删除Docker镜像" class="headerlink" title="删除Docker镜像"></a><strong>删除Docker镜像</strong></h2><h3 id="删除一个或多个特定图像"><a href="#删除一个或多个特定图像" class="headerlink" title="删除一个或多个特定图像"></a><strong>删除一个或多个特定图像</strong></h3><p>使用带有<code>-a</code>标志的命令<code>docker images</code>可以找到要删除的图像的ID。这将显示每个图像，包括中间图像层。当您找到要删除的图像时，可以将其ID或标记传递给<code>docker rmi</code>：<br><strong>列表：</strong></p><pre><code class="javascript">docker images -a</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker rmi Image Image</code></pre><h3 id="删除悬空图像"><a href="#删除悬空图像" class="headerlink" title="删除悬空图像"></a><strong>删除悬空图像</strong></h3><p>Docker图像由多个图层组成。悬空图像是与任何标记图像无关的图层。它们不再用于目的并占用磁盘空间。它们可以通过添加具有值<code>dangling=true</code>的<code>-f</code>过滤器标志到<code>docker images</code>的命令来定位。如果您确定要删除它们，可以使用以下<code>docker images purge</code>命令：</p><p><strong>注意：</strong>如果您在不标记图像的情况下构建图像，则图像将显示在悬空图像列表中，因为它与标记图像无关。您可以通过在构建时提供标记来避免这种情况，并且可以使用docker tag命令追溯标记图像。</p><p><strong>列表：</strong></p><pre><code class="javascript">docker images -f dangling=true</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker images purge</code></pre><h3 id="根据图案删除图像"><a href="#根据图案删除图像" class="headerlink" title="根据图案删除图像"></a><strong>根据图案删除图像</strong></h3><p>你可以使用组合模式<code>docker images</code>和<code>grep</code>找到相匹配的图像。一旦您满意，您可以通过使用<code>awk</code>来删除它们<code>docker rmi</code>。请注意，这些实用程序不是由Docker提供的，并不一定适用于所有系统：</p><p><strong>列表：</strong></p><pre><code class="javascript">docker images -a |  grep &quot;pattern&quot;</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker images -a | grep &quot;pattern&quot; | awk &#39;&#123;print $3&#125;&#39; | xargs docker rmi</code></pre><h3 id="删除所有图像"><a href="#删除所有图像" class="headerlink" title="删除所有图像"></a><strong>删除所有图像</strong></h3><p>通过添加<code>-a</code>到<code>docker images</code>命令，可以列出系统上的所有Docker映像。一旦确定要全部删除它们，就可以添加<code>-q</code>标志以将图像ID传递给<code>docker rmi</code>：</p><p><strong>列表：</strong></p><pre><code class="javascript">docker images -a</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker rmi $(docker images -a -q)</code></pre><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a><strong>删除容器</strong></h2><h3 id="删除一个或多个特定容器"><a href="#删除一个或多个特定容器" class="headerlink" title="删除一个或多个特定容器"></a><strong>删除一个或多个特定容器</strong></h3><p>使用带有该<code>-a</code>标志的<code>docker ps</code>命令可以找到要删除的容器的名称或ID：</p><p><strong>列表：</strong></p><pre><code class="javascript">docker ps -a</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker rm ID_or_Name ID_or_Name</code></pre><h3 id="退出时取出容器"><a href="#退出时取出容器" class="headerlink" title="退出时取出容器"></a><strong>退出时取出容器</strong></h3><p>如果您知道何时创建容器，一旦完成就不想保留它，您可以运行<code>docker run --rm</code>以在退出时自动删除它。</p><p><strong>运行和删除：</strong></p><pre><code class="javascript">docker run --rm image_name</code></pre><h3 id="删除所有已退出的容器"><a href="#删除所有已退出的容器" class="headerlink" title="删除所有已退出的容器"></a><strong>删除所有已退出的容器</strong></h3><p>您可以使用以下<code>docker ps -a</code>状态定位容器并对其进行过滤：创建，重新启动，运行，暂停或退出。要查看已退出容器的列表，请使用<code>-f</code>标志根据状态进行过滤。当您确认要删除这些容器时，使用<code>-q</code>将ID传递给<code>docker rm</code>命令。</p><p><strong>列表：</strong></p><pre><code class="javascript">docker ps -a -f status=exited</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker rm $(docker ps -a -f status=exited -q)</code></pre><h3 id="使用多个过滤器移除容器"><a href="#使用多个过滤器移除容器" class="headerlink" title="使用多个过滤器移除容器"></a><strong>使用多个过滤器移除容器</strong></h3><p>可以通过使用附加值重复过滤器标志来组合Docker过滤器。这导致满足任一条件的容器列表。例如，如果要删除标记为<strong>Created的</strong>所有容器（运行具有无效命令的容器时可能导致的状态）或<strong>Exited</strong>，则可以使用两个过滤器：</p><p><strong>列表：</strong></p><pre><code class="javascript">docker ps -a -f status=exited -f status=created</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker rm $(docker ps -a -f status=exited -f status=created -q)</code></pre><h3 id="根据图案移除容器"><a href="#根据图案移除容器" class="headerlink" title="根据图案移除容器"></a><strong>根据图案移除容器</strong></h3><p>您可以使用<code>docker ps</code>和grep的组合找到与模式匹配的所有容器。当您对要删除的列表感到满意时，可以使用<code>awk</code>和<code>xargs</code>提供ID给 <code>docker rmi</code>。请注意，这些实用程序不是由Docker提供的，并不一定适用于所有系统：</p><p><strong>列表：</strong></p><pre><code class="javascript">docker ps -a |  grep &quot;pattern”</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker ps -a | grep &quot;pattern&quot; | awk &#39;&#123;print $3&#125;&#39; | xargs docker rmi</code></pre><h3 id="停止并移除所有容器"><a href="#停止并移除所有容器" class="headerlink" title="停止并移除所有容器"></a><strong>停止并移除所有容器</strong></h3><p>您可以查看系统上的容器<code>docker ps</code>。添加<code>-a</code>标志将显示所有容器。当您确定要删除它们时，可以添加<code>-q</code>标志以向 <code>docker stop</code>和<code>docker rm</code>命令提供ID：<br><strong>列表：</strong></p><pre><code class="javascript">docker ps -a</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker stop $(docker ps -a -q)docker rm $(docker ps -a -q)</code></pre><h2 id="删除卷"><a href="#删除卷" class="headerlink" title="删除卷"></a><strong>删除卷</strong></h2><h3 id="删除一个或多个特定卷-Docker-1-9及更高版本"><a href="#删除一个或多个特定卷-Docker-1-9及更高版本" class="headerlink" title="删除一个或多个特定卷 - Docker 1.9及更高版本"></a><strong>删除一个或多个特定卷 - Docker 1.9及更高版本</strong></h3><p>使用此<code>docker volume ls</code>命令可找到要删除的卷名称。然后，您可以使用以下<code>docker volume rm</code>命令删除一个或多个卷：<br><strong>列表：</strong></p><pre><code class="javascript">docker volume ls</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker volume rm volume_name volume_name</code></pre><h3 id="删除悬空卷-Docker-1-9及更高版本"><a href="#删除悬空卷-Docker-1-9及更高版本" class="headerlink" title="删除悬空卷 - Docker 1.9及更高版本"></a><strong>删除悬空卷 - Docker 1.9及更高版本</strong></h3><p>由于卷的位置与容器无关，因此在移除容器时，不会同时自动删除卷。当卷存在且不再连接到任何容器时，它称为悬空卷。要找到它们以确认您要删除它们，可以使用带过滤器的命令<code>docker volume ls</code>将结果限制为悬空卷。当您对列表感到满意时，可以用<code>docker volume prune</code>将它们全部删除：</p><p><strong>列表：</strong></p><pre><code class="javascript">docker volume ls -f dangling=true</code></pre><p><strong>去掉：</strong></p><pre><code class="javascript">docker volume prune</code></pre><h3 id="删除容器及其容量"><a href="#删除容器及其容量" class="headerlink" title="删除容器及其容量"></a><strong>删除容器及其容量</strong></h3><p>如果您创建了一个未命名的卷，则可以将其与具有该<code>-v</code>标志的容器同时删除。请注意，这仅适用于<em>未命名的</em>卷。成功删除容器后，将显示其ID。请注意，没有引用卷的删除。如果未命名，则会以静默方式从系统中删除。如果它被命名，它会默默地保持存在。</p><p><strong>去掉：</strong></p><pre><code class="javascript">docker rm -v container_name</code></pre><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>本教程介绍了一些用于使用Docker删除图像，容器和卷的常用命令。每个都可以使用许多其他组合和标志。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常用docker命令&quot;&gt;&lt;a href=&quot;#常用docker命令&quot; class=&quot;headerlink&quot; title=&quot;常用docker命令&quot;&gt;&lt;/a&gt;常用docker命令&lt;/h2&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://yxzhizhi.github.io/categories/linux/"/>
    
      <category term="docker" scheme="https://yxzhizhi.github.io/categories/linux/docker/"/>
    
    
      <category term="docker" scheme="https://yxzhizhi.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
