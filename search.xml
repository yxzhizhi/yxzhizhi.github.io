<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>126mail</title>
    <url>/2020/04/05/%E5%A4%87%E5%BF%98/126%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<pre><code>成功开启IMAP/SMTP服务，在第三方客户端登录时，登录密码输入以下授权密码
DDOVIWIXCWQIEUFX
授权密码只显示一次</code></pre><span id="more"></span>]]></content>
      <categories>
        <category>mail</category>
        <category>back</category>
      </categories>
      <tags>
        <tag>back</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2020/01/01/%E5%A4%87%E5%BF%98/hexo/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<pre><code class="bash">###  hexo install
npm install hexo /yarn add hexo
//npx hexo &lt;command&gt; to hexo 
echo &#39;PATH=&quot;$PATH:./node_modules/.bin&quot;&#39; &gt;&gt; ~/.profile 

hexo init ./yxzhizhi     # 初始化
yarn install    # 安装组件
hexo g   # 生成页面
hexo s   # 启动预览
hexo s --watch
yarn add hexo-deployer-git

然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：
deploy:
  type: git
  repository: git@github.com:用户名/用户名.github.io.git
  branch: master
完成后运行 hexo d 将网站上传部署到 GitHub Pages。

git config --global user.email &quot;yxzhizhi@126.com&quot;
git config --global user.name &quot;yxzhizhi@126.com&quot;

ssh-keygen -t rsa -b 4096 -C &quot;yxzhizhi@126.com&quot;


hexo new &quot;name&quot;       # 新建文章
hexo new page &quot;name&quot;  # 新建页面
hexo g                # 生成页面
hexo d                # 部署
hexo g -d             # 生成页面并部署
hexo s                # 本地预览
hexo clean            # 清除缓存和已生成的静态文件
hexo help             # 帮助
https://yxzhizhi.github.io/</code></pre>
<pre><code>hexo new &quot;name&quot;       # 新建文章
hexo new page &quot;name&quot;  # 新建页面
hexo g
hexo d
</code></pre>]]></content>
      <categories>
        <category>linux</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>firefox dev</title>
    <url>/2020/05/01/%E5%BC%80%E5%8F%91/firefox-dev/</url>
    <content><![CDATA[<p>about:config<br>跨域访问：设置signed.applets.codebase_principal_support=true<br>允许k加载本地文件：设置security.fileuri.strict_origin_policy=false<br>privacy.file_unique_origin=false</p>
<hr>
<h3 id="设置最小版本"><a href="#设置最小版本" class="headerlink" title="设置最小版本"></a>设置最小版本</h3><p>“browser_specific_settings”: {<br>    “gecko”: {<br>      “strict_min_version”: “54.0a1”<br>    }<br>  },</p>
<h3 id="设置侧边栏-图标、标题、页面"><a href="#设置侧边栏-图标、标题、页面" class="headerlink" title="设置侧边栏　图标、标题、页面"></a>设置侧边栏　图标、标题、页面</h3><p>“sidebar_action”: {<br>    “default_icon”: “icons/star.png”,<br>    “default_title” : “Annotator”,<br>    “default_panel”: “sidebar/panel.html”<br>  },</p>
<h3 id="设置权限-存储、tabs"><a href="#设置权限-存储、tabs" class="headerlink" title="设置权限　存储、tabs"></a>设置权限　存储、tabs</h3><p>“permissions”: [“storage”, “tabs”],  </p>
<h3 id="按钮事件-按钮"><a href="#按钮事件-按钮" class="headerlink" title="按钮事件　按钮"></a>按钮事件　按钮</h3><p>“browser_action”: {<br>    “default_icon”: “icons/beasts-32.png”,<br>    “theme_icons”: [{<br>        “light”: “icons/beasts-32-light.png”,<br>        “dark”: “icons/beasts-32.png”,<br>        “size”: 32<br>    }],<br>    “default_title”: “Beastify”,<br>    “default_popup”: “popup/choose_beast.html”<br>  },</p>
<h3 id="页面事件-url后面"><a href="#页面事件-url后面" class="headerlink" title="页面事件　url后面"></a>页面事件　url后面</h3><p>“page_action”: {<br>    “default_icon”: “icons/off.svg”,<br>    “browser_style”: true<br>  },</p>
<h3 id="后台活动"><a href="#后台活动" class="headerlink" title="后台活动"></a>后台活动</h3><p>“background”: {<br>    “scripts”: [“background.js”]<br>  },</p>
<p>/*<br>Update content when a new tab becomes active.　在窗口激活时添加监听动作＝updateContent<br>*/<br>browser.tabs.onActivated.addListener(updateContent);</p>
<p>在打开的tab中查询激活窗口<br>browser.tabs.query({windowId: myWindowId, active: true})<br>.then((tabs) =&gt; {<br>return browser.storage.local.get(tabs[0].url);// 获取本地存储中的tab地址，根据地址获取内容<br>})<br>.then((storedInfo) =&gt; {<br>contentBox.textContent = storedInfo[Object.keys(storedInfo)[0]];//得到内容后<br>});<br>//定义静态资源内容<br>“web_accessible_resources”: [<br>    “beasts/<em>.jpg”<br>]<br>###　给后台发送消息　<br>browser.tabs.sendMessage(tabs[0].id, {<br>    command: “beastify”,<br>    beastURL: url<br>});<br>/*</em>　当窗口打开时，给页面注入js文件</p>
<ul>
<li>When the popup loads, inject a content script into the active tab,</li>
<li>and add a click handler.</li>
<li>If we couldn’t inject the script, handle the error.</li>
<li>/<br>browser.tabs.executeScript({file: “/content_scripts/beastify.js”})<br>.then(listenForClicks)<br>.catch(reportExecuteScriptError);</li>
</ul>
<p>/**　在注入js中　监听消息事件</p>
<ul>
<li>Listen for messages from the background script.</li>
<li>Call “beastify()” or “reset()”.</li>
<li>/<br>browser.runtime.onMessage.addListener((message) =&gt; {<br>if (message.command === “beastify”) {<br>   insertBeast(message.beastURL);<br>} else if (message.command === “reset”) {<br>   removeExistingBeasts();<br>}<br>});<br>注入内容脚本<br>“content_scripts”: [<br>{<br>   “matches”: [“<em>://</em>.mozilla.org/*”],<br>   “js”: [“borderify.js”]<br>}<br>],</li>
</ul>
<p>侧边栏页面：browser.tabs　window.addEventListener<br>后台js: browser.tabs browser.pageAction<br>窗口页面：browser.tabs　browser.tabs.sendMessage<br>注入js:　browser.runtime.onMessage　</p>
<p>事例：<br>annotate-page＝给页面添加注释　打开侧边栏、给活动页面添加注释，再次打开时可显示注释信息[使用本地存储、获取tab地址]<br>apply-css＝添加样式　在url后面添加按钮，后台编写事件给页面增加删除样式[增加样式、删除样式]<br>beastify＝添加扩展按钮　，打开按钮下页面，页面上提供按钮修改页面显示内容，并可恢复原始内容[窗口与注入js通讯]<br>bookmark-it＝创建书签，删除、查找，监控tab修改，流程browserAction<br>borderify＝通过配置注入脚本并配置页面规则<br>alarms＝闹钟<br>Content script registration＝脚本注册，侧边栏输入脚本内容，可注入到当前页面中</p>
]]></content>
  </entry>
  <entry>
    <title>git常用</title>
    <url>/2020/04/09/%E5%BC%80%E5%8F%91/git%E5%B8%B8%E7%94%A8/</url>
    <content><![CDATA[<pre><code class="text">git clone只能clone远程库的master分支，无法clone所有分支，解决办法如下：
1. 找一个干净目录，假设是git_work
2. cd git_work
3. git clone http://myrepo.xxx.com/project/.git ,这样在git_work目录下得到一个project子目录
4. cd project
5. git branch -a，列出所有分支名称如下：
remotes/origin/dev
remotes/origin/release
6. git checkout -b dev origin/dev，作用是checkout远程的dev分支，在本地起名为dev分支，并切换到本地的dev分支
7. git checkout -b release origin/release，作用参见上一步解释
8. git checkout dev，切换回dev分支，并开始开发。
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>sql and freemaker format</title>
    <url>/2020/04/05/%E5%BC%80%E5%8F%91/sql%20and%20freemaker%20format/</url>
    <content><![CDATA[<h2 id="sql-and-freemaker-format"><a href="#sql-and-freemaker-format" class="headerlink" title="sql and freemaker format"></a>sql and freemaker format</h2><ol>
<li>格式化换行<pre><code>&amp;lt;[\/|#].*?&amp;gt;  \n$0\n</code></pre><span id="more"></span></li>
<li>删除空行<pre><code>^(\s*)\n 空</code></pre></li>
<li>sql内容<pre><code class="sql">sql=&quot; $0\n\n
&quot; tables= \n\n$0
</code></pre>
</li>
</ol>
<p>(&lt;[/|#].<em>?&gt;)|(sql=”)|(“ tables)<br>(&lt;[/|#].</em>?&gt;)</p>
<p>\n$0\n<br>/// \r$0\r</p>
<pre><code>4. 删除空行</code></pre><p>^(\s*)\n 空</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>sql</category>
        <category>format</category>
      </categories>
      <tags>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>使用帮助文档</title>
    <url>/2020/04/05/%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>hexo</p>
<pre><code class="javascript">https://hexo.io/zh-cn/docs/
</code></pre>
<span id="more"></span>

<p>Hexo-Next-主题优化</p>
<pre><code class="bash">https://www.jianshu.com/p/428244cd2caa</code></pre>
<p>Hexo+NexT（零）：最全Hexo+Next搭建博客教程</p>
<pre><code class="bash">https://blog.csdn.net/loze/article/details/94206726
</code></pre>
<p>Hexo | NexT打造一个炫酷博客</p>
<pre><code class="bash">https://blog.csdn.net/u012294515/article/details/83094693?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Linux和Docker常用命令</title>
    <url>/2020/04/05/%E5%BC%80%E5%8F%91/%E5%B8%B8%E7%94%A8Linux%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><span id="more"></span>
<pre><code>ls 　 -a(同时列出隐含文件),　　-l（输出一个比较完整的格式，除每个文件名外，增加显示文件
类型、权限、硬链接数、所有者名、组名、大小（byte）、及时间信息-----简化为 ll）

mkdir 　 新建目录　例：mkdir test 命令会在当前目录下建立一个名为“test”的新目录
touch 　　创建文件 例：touch test/readme.txt 在 test 目录下创建 readme.txt 文件
cd 　　切换目录 cd /. 到根目录 cd .. 上一级目录 cd /hahaha/hahaha 到指定目录
pwd 　　显示当前目录
mv 　　移动/重命名（加上 -i 参数询问是否覆盖） 　 mv hello rock/ 移动到 rock 目录下
mv hello rock 重命名为 rock
cp 　　拷贝 （加上 -i 参数询问是否覆盖，-r 参数递归调用）
cp -ir test/ workspace＂（递归复制 test 目录到 workpace 目录下并在覆盖时提示）
rm 　　删除 （加上 -i 参数确认提示，-r 参数递归调用）
rm -ir test/ 递归删除 test 目录及其子目录并询问
wget url 　　下载文件到当前目录
sudo 暂时获取超级用户权限（有默认时长）加上 -i 参数 没有时间限制,输入 exit 或 logout 退出
su 账户名 　　切换到某某用户模式，没有时间限制</code></pre><h3 id="ZIP-工具："><a href="#ZIP-工具：" class="headerlink" title="ZIP 工具："></a>ZIP 工具：</h3><pre><code>压缩文件　　 zip target.zip filename
压缩文件夹　　 zip -r target.zip dir 　　 -r 参数表示递归压缩子目录
解压　　 unzip target.zip</code></pre><h3 id="tar-工具："><a href="#tar-工具：" class="headerlink" title="tar 工具："></a>tar 工具：</h3><pre><code>-c: 建立压缩档案
-x：解压
-t：查看内容
-r：向压缩归档文件末尾追加文件
-u：更新原压缩包中的文件
这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需在压缩或解压档案时可选的。
-z：有 gzip 属性的
-j：有 bz2 属性的
-Z：有 compress 属性的
-v：显示所有过程
-O：将文件解开到标准输出
下面的参数-f 是必须的
-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名
例：tar -xvf file.tar //解压 tar 包
tar -xzvf jdk-8u131-linux-x64.tar.gz -C /usr/local/java //解压 jdk 到指定文件夹
tar -cZf jpg.tar.Z \*.jpg //将目录里所有 jpg 文件打包成 jpg.tar 后，并且将其用
compress 压缩，生成一个 umcompress 压缩过的包，命名为 jpg.tar.Z</code></pre><h3 id="vim-编辑器：-vim-test-cpp"><a href="#vim-编辑器：-vim-test-cpp" class="headerlink" title="vim 编辑器：　　 vim test.cpp"></a>vim 编辑器：　　 vim test.cpp</h3><pre><code>vim 有两种模式，一种是**普通模式**，另一种是**插入模式**。执行上述命令以后进入普通模式。
按下字母键“i”进入插入模式，使用方向键移动光标到需要插入的位置，然后输入想要插入
的内容。编辑完成后按键“Esc”退出回到普通模式,在普通模式下输入冒号“:”，然后输入
w 回车，保存更改。接着输入“:q”退出。也可以直接输入“:wq”保存并退出（注意 w 一定要
在 q 之前，先保存再退出）。
**查找**：在普通模式下输入“/查找内容”，回车，即可定位到第一个匹配项。接着按下字母
键“n”可以查找下一个。
**撤销**：普通模式下输入“:u”并回车，实现撤销。</code></pre>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse/che</title>
    <url>/2020/04/05/%E5%B7%A5%E5%85%B7/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Eclipse%20Che/</url>
    <content><![CDATA[<h3 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h3><pre><code>下载镜像
docker pull portainer/portainer
基于镜像运行容器

docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer  portainer/portainer
http://172.17.0.1:8080/dashboard/#/ide/che/wksp-tvqq
http://127.0.0.1:9000/#/networks
up: admin/y3
</code></pre><span id="more"></span>

<h3 id="eclipse-che"><a href="#eclipse-che" class="headerlink" title="eclipse/che"></a>eclipse/che</h3><pre><code>启动服务
-v /var/…是选择docker文件
-v /opt/…是选择容器存放位置
-e CHE_HOST 设置主机的IP地址

单用户：
docker run -ti --rm --name che6 -v /var/run/docker.sock:/var/run/docker.sock -v /home/zhanghuo/LinuxHome/docker/eclipseche:/data  -e CHE_PORT=8080 -e CHE_HOST=192.168.10.225 eclipse/che:6.19.0 start

多用户：
docker run -ti -e CHE_MULTIUSER=true -v /var/run/docker.sock:/var/run/docker.sock -v /home/zhanghuo/LinuxHome/docker/eclipseche:/data  -e CHE_PORT=8080 -e CHE_HOST=192.168.6.203 eclipse/che:6.19.0 start
实际创建:
docker run -ti -e CHE_MULTIUSER=true -v /var/run/docker.sock:/var/run/docker.sock -v /home/zhanghuo/LinuxHome/docker/eclipseche:/data  -e CHE_PORT=8080  eclipse/che:6.19.0 start</code></pre><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><pre><code>~/docker-tags eclipse/che
sudo docker pull eclipse/che:6.19.0</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><pre><code>sudo docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock -v /home/zhanghuo/LinuxHome/docker/eclipseche:/data eclipse/che:6.19.0 start
启动完毕后，访问 “http://:8080/” 来验证安装。
</code></pre><pre><code>创建 workspace 和 project
访问 “Workspaces -&gt; Add Workspace”；
在 “New Workspace” 页面选择 “java Default Java Stack with JDK 8, Maven and Tomcat.” 然后 “CREATE &amp; OPEN”；
在 “Workspace” 页面，选择 “Create Project…”；
在 “Create New Project” 窗口，选择 Java -&gt; Maven 项目，然后输入一个Name，比如: “test”，并进入下一步；
勾选 “From Archetype:” 并选择 “org.apache.maven.archetypes:maven-archetype-quickstart:RELEASE”，同时输入 “Artifact ID” 和 “Group ID”，然后 “Create” 来创建工程；
运行工程
选中并打开工程，然后在 “Manage commands” 依次创建三个 Maven 命令，并运行。

build
mvn clean install -f $&#123;current.project.path&#125;
1
test
mvn clean test -f $&#123;current.project.path&#125;
1
run
mvn exec:java -Dexec.mainClass=&quot;test.App&quot; -f $&#123;current.project.path&#125;</code></pre><h3 id="eclipse-che-命令-ubuntu"><a href="#eclipse-che-命令-ubuntu" class="headerlink" title="eclipse/che 命令 -ubuntu"></a>eclipse/che 命令 -ubuntu</h3><h5 id="1-apt-get-update"><a href="#1-apt-get-update" class="headerlink" title="1. apt-get update"></a>1. apt-get update</h5><h5 id="2-安装docker-国内源安装"><a href="#2-安装docker-国内源安装" class="headerlink" title="2. 安装docker,国内源安装"></a>2. <a href="https://link.jianshu.com/?t=https://yeasy.gitbooks.io/docker_practice/content/install/ubuntu.html">安装docker,国内源安装</a></h5><h5 id="3-配置镜像仓库"><a href="#3-配置镜像仓库" class="headerlink" title="3.配置镜像仓库"></a>3.<a href="https://link.jianshu.com/?t=https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html#ubuntu-1604、debian-8-jessie、centos-7">配置镜像仓库</a></h5><h5 id="4-解决内存溢出的问题"><a href="#4-解决内存溢出的问题" class="headerlink" title="4.解决内存溢出的问题"></a>4.解决内存溢出的问题</h5><pre><code class="javascript">Adjust memory and swap accounting
When users run Docker, they may see these messages when working with an image:

WARNING: Your kernel does not support cgroup swap limit. WARNING: Your
kernel does not support swap limit capabilities. Limitation discarded.
To prevent these messages, enable memory and swap accounting on your system. To enable these on system using GNU GRUB (GNU GRand Unified Bootloader), do the following.

Log into Ubuntu as a user with sudo privileges.

Edit the /etc/default/grub file.

Set the GRUB_CMDLINE_LINUX value as follows:

GRUB_CMDLINE_LINUX=&quot;cgroup_enable=memory swapaccount=1&quot;
Save and close the file.

Update GRUB.

$ sudo update-grub
Reboot your system.</code></pre>
<h5 id="5关闭防火墙"><a href="#5关闭防火墙" class="headerlink" title="5关闭防火墙"></a>5关闭防火墙</h5><p><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/wclwcw/p/6140263.html">网络相关配置</a></p>
<pre><code class="javascript">ufw disable</code></pre>
<ul>
<li>安装</li>
</ul>
<pre><code class="javascript">docker pull eclipse/che:5.17.0</code></pre>
<ul>
<li>启动(第一次启动需要下载其他镜像)</li>
</ul>
<pre><code class="javascript">docker run -it --rm -e CHE_PORT=8120 -v /var/run/docker.sock:/var/run/docker.sock -v /c/8120/tmp:/data eclipse/che:5.17.0 start</code></pre>
<ul>
<li>修改che的样式文件，去掉左边导航栏</li>
</ul>
<pre><code class="javascript">docker cp /che/index.html che-8120:/home/user/eclipse-che-5.17.0/tomcat/webapps/dashboard</code></pre>
<ul>
<li>停止</li>
</ul>
<pre><code class="javascript">docker run -it --rm -e CHE_PORT=8120 -v /var/run/docker.sock:/var/run/docker.sock -v /c/8120/tmp:/data eclipse/che:5.17.0 stop</code></pre>
<ul>
<li>重启</li>
</ul>
<pre><code class="javascript">docker run -it --rm -e CHE_PORT=8120 -v /var/run/docker.sock:/var/run/docker.sock -v /c/8120/tmp:/data eclipse/che:5.17.0 restart</code></pre>
<ul>
<li>che API</li>
</ul>
<p>启动che的时候的终端返回信息最后一行是che的api地址</p>
<ul>
<li>创建che工作空间</li>
</ul>
<pre><code class="javascript">curl -X POST -H &#39;Content-Type: application/json&#39; -d &#39;&#123;&quot;name&quot;:&quot;myworkspace&quot;,&quot;projects&quot;:[],&quot;commands&quot;:[&#123;&quot;name&quot;:&quot;build&quot;,&quot;type&quot;:&quot;mvn&quot;,&quot;attributes&quot;:&#123;&quot;goal&quot;:&quot;Build&quot;,&quot;previewUrl&quot;:&quot;&quot;&#125;,&quot;commandLine&quot;:&quot;mvn clean install&quot;],&quot;environments&quot;:&#123;&quot;myworkspace&quot;:&#123;&quot;recipe&quot;:&#123;&quot;location&quot;:&quot;eclipse/ubuntu_jdk8&quot;,&quot;type&quot;:&quot;dockerimage&quot;&#125;,&quot;machines&quot;:&#123;&quot;dev-machine&quot;:&#123;&quot;attributes&quot;:&#123;&quot;memoryLimitBytes&quot;:&quot;2147483648&quot;&#125;,&quot;agents&quot;:[&quot;org.eclipse.che.exec&quot;,&quot;org.eclipse.che.terminal&quot;,&quot;org.eclipse.che.ws-agent&quot;,&quot;org.eclipse.che.ssh&quot;],&quot;servers&quot;:&#123;&#125;&#125;&#125;&#125;&#125;,&quot;defaultEnv&quot;:&quot;myworkspace&quot;,&quot;links&quot;:[]&#125;&#39; http://localhost:8080/api/workspace
//其中-d为创建工作空间所需json参数，具体请看下一小节</code></pre>
<ul>
<li>修改che的运行时环境</li>
</ul>
<p>访问che的webide，点击左侧stacks，在右侧的列表中选择自己需要的运行时环境点进进入详情界面</p>
<p>下拉找到row configuration，复制其中json数据里的workspaceconfig部分代码（注意只取 “workspaceConfig”:后面的{}已经其中的信息），作为访问创建che工作空间api的参数</p>
<ul>
<li>在项目中使用che api需要执行以下命令</li>
</ul>
<pre><code class="javascript">git clone http://github.com/eclipse/che
cd cde
git checkout 5.17.x
cd core
mvn install</code></pre>
<ul>
<li>chedir 初始化工作空间和项目</li>
</ul>
<pre><code class="javascript">cd /ChedirDocker/project
mkdir che8081project
cd che8081project
//创建Chedir文件
docker run -it --rm -e CHE_PORT=8081 -v /var/run/docker.sock:/var/run/docker.sock -v /c/8081/tmp:/data  -v  /ChedirDocker/project/che8081project:/chedir eclipse/che:5.17.0 dir init
//进行相应修改
vim Chedir
//启动容器
/var/run/docker.sock:/var/run/docker.sock -v /c/8081/tmp:/data  -v  /ChedirDocker/project/che8081project:/chedir eclipse/che:5.17.0 dir up
//销毁容器
/var/run/docker.sock:/var/run/docker.sock -v /c/8081/tmp:/data  -v  /ChedirDocker/project/che8081project:/chedir eclipse/che:5.17.0 dir down</code></pre>
]]></content>
      <categories>
        <category>linux</category>
        <category>che</category>
        <category>eclipse</category>
      </categories>
      <tags>
        <tag>che</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建MySQL服务</title>
    <url>/2020/04/05/%E7%8E%AF%E5%A2%83/Docker%E6%90%AD%E5%BB%BAMySQL%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="Docker搭建MySQL服务"><a href="#Docker搭建MySQL服务" class="headerlink" title="Docker搭建MySQL服务"></a><a href="https://www.cnblogs.com/pwc1996/p/5425234.html">Docker搭建MySQL服务</a></h1><h1 id="Docker开源镜像"><a href="#Docker开源镜像" class="headerlink" title="Docker开源镜像"></a>Docker开源镜像</h1><p>前面我们已经安装好了Docker，也简单了解了Docker。那么我们可以尝试搭建一个MySQL服务。</p>
<p>要搭建服务就要启动服务容器，要创建容易就要有镜像，Docker提供了一个类似Github的开源平台，提供开源镜像，放心可靠。（毕竟大家都看着源码呢）</p>
<span id="more"></span>
<p><a href="https://hub.docker.com/">Docker开源镜像传送门</a></p>
<hr>
<h1 id="大概步骤"><a href="#大概步骤" class="headerlink" title="大概步骤"></a>大概步骤</h1><p><strong>1. 下载MySQL镜像</strong><br><strong>2. 创建运行容器</strong></p>
<blockquote>
<p>好像很简单是吧？</p>
</blockquote>
<hr>
<h1 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h1><h2 id="第零步，查看Docker-MySQL文档"><a href="#第零步，查看Docker-MySQL文档" class="headerlink" title="第零步，查看Docker MySQL文档"></a>第零步，查看Docker MySQL文档</h2><p>MySQL文档地址：<br><a href="https://hub.docker.com/_/mysql/">https://hub.docker.com/_/mysql/</a></p>
<hr>
<h2 id="第一步，拉取MySQL镜像"><a href="#第一步，拉取MySQL镜像" class="headerlink" title="第一步，拉取MySQL镜像"></a>第一步，拉取MySQL镜像</h2><pre><code>$ sudo docker pull mysql</code></pre><p>之后docker会自动拉取（下载）MySQL镜像。</p>
<p>等待同样是漫长的。。。</p>
<blockquote>
<p>注意，若提示拉取失败就重复几次，总有一次会成功的。。。没办法，墙内的人民很辛苦</p>
</blockquote>
<p>拉取成功后我们查看一下：</p>
<pre><code>$ sudo docker images</code></pre><p><img src="http://img.blog.csdn.net/20160317140105707" alt="01"></p>
<hr>
<h2 id="第二步，创建并启动一个MySQL容器"><a href="#第二步，创建并启动一个MySQL容器" class="headerlink" title="第二步，创建并启动一个MySQL容器"></a>第二步，创建并启动一个MySQL容器</h2><p>输入以下命令：</p>
<pre><code>$ sudo docker run --name pwc-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql</code></pre><p><img src="http://img.blog.csdn.net/20160317142223778" alt="02"></p>
<ul>
<li>–name：给新创建的容器命名，此处命名为<code>pwc-mysql</code></li>
<li>-e：配置信息，此处配置<code>mysql</code>的<code>root用户</code>的登陆密码</li>
<li>-p：端口映射，此处映射<code>主机3306端口</code>到<code>容器pwc-mysql的3306端口</code></li>
<li>-d：成功启动容器后输出容器的完整ID，例如上图 <code>73f8811f669ee...</code></li>
<li>最后一个<code>mysql</code>指的是<code>mysql镜像名字</code></li>
</ul>
<p><strong>到这里我们查看容器运行状态：</strong></p>
<pre><code>$ sudo docker ps</code></pre><p><img src="http://img.blog.csdn.net/20160317142325183" alt="03"></p>
<p>上图可以看到容器的简写ID，容器的源镜像，创建时间，状态，端口映射信息，容器名字等。</p>
<hr>
<h2 id="第三步，测试连接MySQL"><a href="#第三步，测试连接MySQL" class="headerlink" title="第三步，测试连接MySQL"></a>第三步，测试连接MySQL</h2><p>这里我使用navicat远程连接，连接MySQL前需要防火墙开放端口或者关闭防火墙。</p>
<p>开放端口：</p>
<pre><code>$ sudo firewall-cmd --add-port=3306/tcp</code></pre><p>关闭防火墙：</p>
<pre><code>$ sudo systemctl stop firewalld</code></pre><p>接着使用navicat连接<br><img src="http://img.blog.csdn.net/20160317143333986" alt="04"></p>
<p>连接成功，也可以进行相关数据库操作，因此MySQL服务搭建成功！</p>
<hr>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><strong>1.可以启动多个MySQL服务，因为我们启动的是容器，容器可以有多个，只要容器名字映射段端口不一样就可以了，例如：</strong></p>
<pre><code>$ sudo docker run --name dbdb -e MYSQL_ROOT_PASSWORD=123456 -p 6666:3306 -d mysql</code></pre><p><strong>2.查看所有容器（启动状态或者关闭状态）</strong></p>
<pre><code>$ sudo docker ps -a</code></pre><p><strong>3.启动和关闭容器</strong></p>
<p>启动命令：</p>
<pre><code>$ sudo docker start pwc-mysql   //通过指定容器名字
$ sudo docker start 73f8811f669e  //通过指定容器ID</code></pre><p>关闭命令：</p>
<pre><code>$ sudo docker stop pwc-mysql   //通过指定容器名字
$ sudo docker stop 73f8811f669e  //通过指定容器ID</code></pre><p><strong>3.修改MySQL配置文件有两种方法：</strong></p>
<ul>
<li><p>一是进入容器，修改容器里的MySQL的配置文件，然后重新启动容器，例如：</p>
<pre><code>$ sudo docker exec -it pwc-mysql /usr/bin/bash</code></pre><p>然后可以进入容器的命令行模式，接着修改 <code>/etc/mysql/my.cnf</code> 文件即可</p>
</li>
<li><p>二是挂载主机的mysql配置文件，官方文档如下：</p>
<p>The MySQL startup configuration is specified in the file <code>/etc/mysql/my.cnf</code>, and that file in turn includes any files found in the <code>/etc/mysql/conf.d</code> directory that end with .cnf. Settings in files in this directory will augment and/or override settings in <code>/etc/mysql/my.cnf</code>. If you want to use a customized MySQL configuration, you can create your alternative configuration file in a directory on the host machine and then mount that directory location as <code>/etc/mysql/conf.d</code> inside the mysql container.</p>
<p>If <code>/my/custom/config-file.cnf</code> is the path and name of your custom configuration file, you can start your mysql container like this (note that only the directory path of the custom config file is used in this command):</p>
<pre><code>$ docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</code></pre><p>This will start a new container some-mysql where the MySQL instance uses the combined startup settings from <code>/etc/mysql/my.cnf</code> and <code>/etc/mysql/conf.d/config-file.cnf</code>, with settings from the latter taking precedence.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>conda 虚拟环境</title>
    <url>/2020/04/09/%E7%8E%AF%E5%A2%83/conda-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>无法加载文件 <strong>**</strong>.ps1，因为在此系统中禁止执行脚本。有关详细信息<br>在powershell中执行 set-ExecutionPolicy RemoteSigned</p>
<p>conda</p>
<p>Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。</p>
<p>安装可以下载一个科学计算包anaconda，怕麻烦的人可以直接安装，自带很多必须包</p>
<p>清华镜像下载地址，<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p>
<p>创建</p>
<p>conda create –name py3 python=3.7</p>
<p>使用<br>conda env list #查看当前存在的虚拟环境</p>
<p>source activate py3 #激活虚拟环境 activate py3 windows下</p>
<p>conda install numpy #安装包</p>
<p>source deactivate #退出虚拟环境</p>
<p>conda remove -n py3 –all #删除虚拟环境</p>
<p>1、首先在所在系统中安装Anaconda。可以打开命令行输入conda -V检验是否安装以及当前conda的版本。</p>
<p>2、conda常用的命令。</p>
<pre><code>1）conda list 查看安装了哪些包。

2）conda env list 或 conda info -e 查看当前存在哪些虚拟环境

3）conda update conda 检查更新当前conda

4）conda --version 查询conda版本

5）conda -h 查询conda的命令使用</code></pre><p>3、创建python虚拟环境。</p>
<pre><code> 使用 conda create -n your_env_name python=X.X（2.7、3.6等)命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。

 注意：默认的情况下只安装了一些必须的包，并不会像我们安装anaconda时自动安装很多常用的包。要实现上面的功能，则须在末尾加上‘anaconda’，完整命令是：conda create -n your_env_name python=X.X anaconda</code></pre><p>4、使用激活(或切换不同python版本)的虚拟环境。</p>
<pre><code>打开命令行输入python --version可以检查当前python的版本。

使用如下命令即可 激活你的虚拟环境(即将python的版本改变)。

Linux:  source activate your_env_name(虚拟环境名称)

Windows: activate your_env_name(虚拟环境名称)</code></pre><p>   这是再使用python –version可以检查当前python版本是否为想要的。</p>
<p>5、对虚拟环境中安装额外的包。</p>
<pre><code>使用命令conda install -n your_env_name [package]即可安装package到your_env_name中</code></pre><p>6、关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)。</p>
<p>   使用如下命令即可。</p>
<p>   Linux: source deactivate</p>
<p>   Windows: deactivate</p>
<p>7、删除虚拟环境。</p>
<p>   使用命令conda remove -n your_env_name(虚拟环境名称) –all， 即可删除。</p>
<p>8、删除环境中的某个包。</p>
<p>   使用命令conda remove –name your_env_name  package_name 即可。</p>
<pre><code class="bash">
conda create -n rest_xops python=3.7.6
source activate rest_xops # conda activate rest_xops
conda install -n rest_xops [package]
source deactivate # conda deactivate
# remove
conda remove --name rest_xops package_name
conda remove -n rest_xops --all
</code></pre>
<p>设置国内镜像<br>如果需要安装很多packages，你会发现conda下载的速度经常很慢，因为Anaconda.org的服务器在国外。所幸的是，清华TUNA镜像源有Anaconda仓库的镜像，我们将其加入conda的配置即可：</p>
<p>1 # 添加Anaconda的TUNA镜像<br>2 conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>3 # TUNA的help中镜像地址加有引号，需要去掉<br>4<br>5 # 设置搜索时显示通道地址<br>6 conda config –set show_channel_urls yes<br> 执行完上述命令后，会生成~/.condarc(Linux/Mac)或C:UsersUSER_NAME.condarc文件，记录着我们对conda的配置，直接手动创建、编辑该文件是相同的效果。</p>
]]></content>
  </entry>
  <entry>
    <title>java deploy to docker</title>
    <url>/2020/04/06/%E7%8E%AF%E5%A2%83/java-deploy-to-docker/</url>
    <content><![CDATA[<hr>
<h1 id="ubuntu普通用户登录操作docker提示无权限的解决办法"><a href="#ubuntu普通用户登录操作docker提示无权限的解决办法" class="headerlink" title="ubuntu普通用户登录操作docker提示无权限的解决办法"></a>ubuntu普通用户登录操作docker提示无权限的解决办法</h1><pre><code class="bash">sudo groupadd docker
sudo usermod -aG docker $&#123;USER&#125;
newgrp docker     #更新用户组
docker ps    #测试docker命令是否可以使用sudo正常使用
#1 添加docker用户组(一般安装docker时会自动添加)
sudo groupadd docker 
#2 将指定用户添加到docker用户组中 注:将USER替换为自己的用户名
sudo gpasswd -a USER docker
#3 重启docker服务
sudo systemctl restart docker
#4 退出SSH连接，重新登录</code></pre>
<span id="more"></span>
<h1 id="grep-正则"><a href="#grep-正则" class="headerlink" title="grep 正则"></a>grep 正则</h1><pre><code class="bash">
1、或操作
grep -E &#39;123|abc&#39; filename  // 找出文件（filename）中包含123或者包含abc的行
egrep &#39;123|abc&#39; filename    // 用egrep同样可以实现
awk &#39;/123|abc/&#39; filename   // awk 的实现方式
2、与操作
grep pattern1 files | grep pattern2 //显示既匹配 pattern1 又匹配 pattern2 的行。
3、其他操作
grep -i pattern files   //不区分大小写地搜索。默认情况区分大小写，
grep -l pattern files   //只列出匹配的文件名，
grep -L pattern files   //列出不匹配的文件名，
grep -w pattern files  //只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），
grep -C number pattern files //匹配的上下文分别显示[number]行，
</code></pre>
<h1 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h1><pre><code class="bash"># 根据镜像id删除
docker rm $(docker ps -a|grep -E &#39;1b9cf56dec97|4eb9989fc00f&#39;| awk &#39;&#123;print $1&#125;&#39;)
docker rm $(docker ps -a|grep 1b9cf56dec97| awk &#39;&#123;print $1&#125;&#39;)
# 删除未命名的容器[通常由dockfile文件执行run命令自动产生的中间镜像]
docker rmi $(docker images | grep &quot;none&quot; | awk &#39;&#123;print $3&#125;&#39;)</code></pre>
<p>———————-;</p>
<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><pre><code class="bash">1. 获取镜像
    ```sudo docker pull oraclelinux```
2. 后台运行
    ```sudo docker run -itd --name oraclelinux_dev oraclelinux /bin/bash```
3. 查询容器
    ```sudo docker ps #47e0e5a52244 oraclelinux_dev```
4. 进入容器
    在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：
    ```docker attach  $ sudo docker attach 47e0e5a52244```
    注意： 如果从这个容器退出，会导致容器的停止。
    docker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。
    ```sudo docker exec -it 47e0e5a52244 /bin/bash```

5. 导出容器
    如果要导出本地某个容器，可以使用 docker export 命令。
    ```docker export 47e0e5a52244 &gt; oraclelinux_dev.tar```

6. 导入容器快照
    可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 oraclelinux_dev.tar 导入到镜像 test/oraclelinux_dev:v1:
    ```cat docker/oraclelinux_dev.tar | sudo docker import - dev/oraclelinux_dev:v1```
    ```sudo docker import oraclelinux_dev dev/oraclelinux_dev```
7. 下面的命令可以清理掉所有处于终止状态的容器。
    ```docker container prune```</code></pre>
<h1 id="用Docker搭建Python的开发环境"><a href="#用Docker搭建Python的开发环境" class="headerlink" title="用Docker搭建Python的开发环境"></a>用Docker搭建Python的开发环境</h1><pre><code class="bash">sudo docker pull python:3.7.6
cd /home/zhanghuo/PycharmProjects/db_manage_vue
docker run  -v /home/zhanghuo/PycharmProjects/db_manage_vue:/usr/src/db_manage_vue  -w /usr/src/db_manage_vue python:3.7.6 python ./manage.py runserver
注意事项：
-v 将主机的py文件目录挂载到容器中的/usr/src/db_manage_vue
-w 指定容器的/usr/src/db_manage_vue目录为工作目录
python ./manage.py runserver 用容器中的python命令来执行工作目录的pyth.py
dockerfile
FROM python:3.7.6
COPY . /usr/src/db_manage_vue
WORKDIR /usr/src/db_manage_vue
RUN pip install -r requirements.txt
ENTRYPOINT [&quot;python&quot;]
CMD [&quot;./manage.py runserver&quot;]

-- 生成依赖包文件
pip freeze &gt; requirements.txt
创建镜像
sudo docker build -t db_manage_vue/python .
运行容器：
docker run id/db_manage_vue/python
### docker-compose
</code></pre>
<h1 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker compose安装"></a>docker compose安装</h1><h2 id="参考daocloud的https-get-daocloud-io-install-compose"><a href="#参考daocloud的https-get-daocloud-io-install-compose" class="headerlink" title="参考daocloud的https://get.daocloud.io/#install-compose"></a>参考daocloud的<a href="https://get.daocloud.io/#install-compose">https://get.daocloud.io/#install-compose</a></h2><ol>
<li>github</li>
</ol>
<pre><code class="bash">https://github.com/docker/compose/releases
curl -L https://github.com/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose</code></pre>
<ol>
<li>daocloud<br>Docker Compose 存放在Git Hub，不太稳定。<br>你可以也通过执行下面的命令，高速安装Docker Compose。</li>
</ol>
<pre><code class="bash">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose</code></pre>
<p>你可以通过修改URL中的版本，可以自定义您的需要的版本。<br>3. 测试安装</p>
<pre><code class="bash">docker-compose --version</code></pre>
<h3 id="重命名镜像"><a href="#重命名镜像" class="headerlink" title="重命名镜像"></a>重命名镜像</h3><pre><code class="bash">docker tag IMAGEID(镜像id) REPOSITORY:TAG（仓库：标签）
#例子
docker tag ca1b6b825289 registry.cn-hangzhou.aliyuncs.com/xxxxxxx:v1.0</code></pre>
<h1 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h1><pre><code class="bash"> vi /etc/docker/daemon.json
&#123;&quot;registry-mirrors&quot;: [&quot;https://s75dbt4b.mirror.aliyuncs.com&quot;]&#125;</code></pre>
<p>然后进入到 mysql 容器中将 django 数据库文件导入：</p>
<pre><code class="bash">#docker inspect --format &quot;&#123;&#123;.State.Pid&#125;&#125;&quot; mysql
12674
#nsenter --target 12674 --mount --uts --ipc --net --pid
root@91308514f209:/# cd /etc/mysql/conf.d/
root@91308514f209:/etc/mysql/conf.d# mysql -uroot -p jianshu \&lt; jianshu.sql</code></pre>
<h1 id="docker-发布-django项目"><a href="#docker-发布-django项目" class="headerlink" title="docker 发布 django项目"></a>docker 发布 django项目</h1><pre><code class="bash">打包django项目
先生成需要的python模块列表
pip freeze &gt;req.txt
然后打包程序
tar cvf django1.tar ./django1
scp到docker服务器的/python目录下解压
确定基础镜像版本
docker pull centos:7.3.1611
运行此镜像
docker run -d -i -v /python:/python -tcentos:7.3.1611
-d为后台运行
-v 为映射本地目录到docker中
准备程序运行环境
然后进入到运行的docker中，安装需要的软件包以及模块
yum install xxxx
pip install –r req.txt
生成新镜像
docker commit bd486b5df131 centos/django
运行
docker run -itd -p 8000:8000  -v /python:/python -w /python centos/django1python /python/django1/manage.py runserver 0.0.0.0:8000
运行的时候使用
docker export db509b5a599f &gt;django.tar
然后在目标服务器
cat django.tar | docker import -centos/django
然后新建/python/
将django1.tar项目文件传送到目录上，解压
运行
docker run -itd -p 8000:8000  -v /python:/python -w /python centos/djangopython /python/django1/manage.py runserver 0.0.0.0:8000
查看项目库运行日志：
docker logs fba7f2b32fb0 -f
-docker 发布 django项目 end-</code></pre>
<pre><code class="bash">base=https://github.com/docker/machine/releases/download/v0.16.0 &amp;&amp;
curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp;
sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;
chmod +x /usr/local/bin/docker-machine
</code></pre>
<hr>
]]></content>
      <tags>
        <tag>java,docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 删除软件</title>
    <url>/2020/04/18/%E7%8E%AF%E5%A2%83/ubuntu-%E5%88%A0%E9%99%A4%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p>Ubuntu apt-get彻底卸载软件包<br>原创享学IT 最后发布于2016-04-28 18:09:48 阅读数 228448  收藏<br>展开<br>如果你关注搜索到这篇文章，那么我可以合理怀疑你被apt-get的几个卸载命令有点搞晕了。</p>
<p>apt-get的卸载相关的命令有remove/purge/autoremove/clean/autoclean等。具体来说：</p>
<p>apt-get purge / apt-get –purge remove<br>删除已安装包（不保留配置文件)。<br>如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文件</p>
<p>apt-get autoremove<br>删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</p>
<p>apt-get remove<br>删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</p>
<p>apt-get autoclean<br>APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。</p>
<p>apt-get clean<br>使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。</p>
<p>那么如何彻底卸载软件呢？<br>具体来说可以运行如下命令：</p>
<h1 id="删除软件及其配置文件"><a href="#删除软件及其配置文件" class="headerlink" title="删除软件及其配置文件"></a>删除软件及其配置文件</h1><p>apt-get –purge remove <package></p>
<h1 id="删除没用的依赖包"><a href="#删除没用的依赖包" class="headerlink" title="删除没用的依赖包"></a>删除没用的依赖包</h1><p>apt-get autoremove <package></p>
<h1 id="此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理："><a href="#此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：" class="headerlink" title="此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理："></a>此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：</h1><p>dpkg -l |grep ^rc|awk ‘{print $2}’ |sudo xargs dpkg -P<br>当然如果要删除暂存的软件安装包，也可以再使用clean命令。<br>————————————————</p>
]]></content>
  </entry>
  <entry>
    <title>vritubox-ubuntu-init</title>
    <url>/2020/04/19/%E7%8E%AF%E5%A2%83/vritubox-ubuntu-init/</url>
    <content><![CDATA[<p>init_net_10.0.2.15</p>
<pre><code>vim /etc/network/interfaces
auto eth0
iface eth0 inet static    
address 10.0.2.15
gateway 10.0.2.1
netmask 255.255.255.0
dns-nameservers 8.8.8.8
--
auto eth0#etho为通常的Ubuntu的网关名称，有时也会改变，可通过ifconfig命令查看，有时会出现如ens160,ens33等名称
iface eth0 inet static#设置IP为静止IP,
address 192.168.1.103#你想设置的静态IP地址
netmask 255.255.255.0#子网掩码，通常为255.255.255.0
#network 192.168.1.0
broadcast 192.168.1.255 #广播地址，可以通过ifconfig查看现有的。，
gateway 192.168.1.8#网关, #netstat -r 命令或者   nm-tool   查看现有的
# dns-* options are implemented by the resolvconf package, if installed
dns-nameservers 61.139.2.69#国内常见的dns解析，
#dns-search localhost
dns-nameservers 8.8.8.8#谷歌dns解析，但是速度较慢


sudo service networking restart
/etc/init.d/networking restart
sudo ifconfig eth0 down 
sudo ifconfig eth0 up
eb

vim /etc/resolvconf/resolv.conf.d/base
nameserver 8.8.8.8

VBox无界面启动
VBoxManage startvm name  --type headless
关机
VBoxManage controlvm name poweroff
</code></pre><p>init&amp;ssh&amp;ssl&amp;ssh免密码快速登录配置</p>
<pre><code>apt install openssh* openssl
netstat -lnt | grep 22
service sshd restart

ssh zhanghuo@localhost -p 21522

--ssh免密码快速登录配置
ssh-keygen -t rsa
scp -P21522 ./id_rsa.pub zhanghuo@localhost:~
ssh -p21522 zhanghuo@localhost
remote:cat id_rsa.pub &gt; ~/.ssh/authorized_keys
ssh -p21522 zhanghuo@localhost


vi ～/.ssh/config
Host v21522
HostName localhost
Port 21522
User zhanghuo
IdentityFile ~/.ssh/id_rsa.pub

:wq

# ssh-copy-id -i ~/.ssh/id_rsa.pub v21522
ssh v21522
</code></pre><p>oraclelinux7&amp;centos7</p>
<pre><code>cd /etc/sysconfig/network-scripts
ip addr / ifconfig 没有此命令
sudo vi ifcfg-enp0s3 /ens33

BOOTPROTO=&quot;static&quot;         # 使用静态IP地址，默认为dhcp
IPADDR=&quot;10.0.3.15&quot;   # 设置的静态IP地址
NETMASK=&quot;255.255.255.0&quot;    # 子网掩码
GATEWAY=&quot;10.0.3.1&quot;    # 网关地址
DNS1=&quot;8.8.8.8&quot;       # DNS服务器

ONBOOT=&quot;yes&quot;             #是否开机启用
:wq

service network restart
hostnamectl set-hostname zhanghuo
vim /etc/hosts
10.0.3.15 zhanghuo

ping www.baidu.com
</code></pre><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h4 id="firewall命令"><a href="#firewall命令" class="headerlink" title="firewall命令"></a>firewall命令</h4><p>firewall-cmd –zone=public –add-port=3306/tcp –permanent<br>#对外开放3306端口，供外部的计算机访问<br>#该命令方式添加的端口，可在/etc/firewalld/zones中的对应配置文件中得到体现</p>
<p>systemctl restart firewalld #重启防火漆<br>说明：<br>firewall-cmd：Linux中提供的操作firewall的工具。<br>–zone：指定作用域。<br>–add-port=80/tcp：添加的端口，格式为：端口/通讯协议。<br>–permanent：表示永久生效，没有此参数重启后会失效。</p>
<h4 id="直接修改配置文件"><a href="#直接修改配置文件" class="headerlink" title="直接修改配置文件"></a>直接修改配置文件</h4><p>/etc/firewalld/zones/public.xml 文件的默认内容为：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;zone&gt;
  &lt;short&gt;Public&lt;/short&gt;
  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;
  &lt;service name=&quot;dhcpv6-client&quot;/&gt;
  &lt;service name=&quot;ssh&quot;/&gt;
&lt;/zone&gt;</code></pre><p>修改该配置文件，来添加3306端口。修改后的内容为：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;zone&gt;
  &lt;short&gt;Public&lt;/short&gt;
  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;
  &lt;service name=&quot;dhcpv6-client&quot;/&gt;
  &lt;service name=&quot;ssh&quot;/&gt;
  &lt;port protocol=&quot;tcp&quot; port=&quot;3306&quot;/&gt;
&lt;/zone&gt;</code></pre><hr>
<h4 id="firewall常用命令"><a href="#firewall常用命令" class="headerlink" title="firewall常用命令"></a>firewall常用命令</h4><h4 id="查看firewall的状态"><a href="#查看firewall的状态" class="headerlink" title="查看firewall的状态"></a>查看firewall的状态</h4><pre><code>service firewalld status
或
systemctl status firewalld
或
firewall-cmd --state</code></pre><h4 id="启动、停止、重启"><a href="#启动、停止、重启" class="headerlink" title="启动、停止、重启"></a>启动、停止、重启</h4><pre><code>service firewalld start
或
systemctl start firewalld
# 启动

service firewalld stop
或
systemctl stop firewalld
# 停止

service firewalld restart
或
systemctl restart firewalld
# 重启</code></pre><h4 id="开机自启动的关闭与开启"><a href="#开机自启动的关闭与开启" class="headerlink" title="开机自启动的关闭与开启"></a>开机自启动的关闭与开启</h4><pre><code>systemctl disable firewalld
# 关闭开机自启动
systemctl enable firewalld
# 开启开机自启动
2.4 查看防火墙的规则
firewall-cmd --list-all </code></pre><p>开放22端口，默认已经开放ssh服务</p>
<pre><code>sudo firewall-cmd --zone=public --add-port=22/tcp --permanent
sudo service firewalld restart</code></pre><p>vritubox 全局设定，创建nat网络并配置端口映射<br>ssh zhanghuo@localhost -p 21522<br>ssh zhanghuo@localhost -p 31522<br>ssh zhanghuo@localhost -p 51522</p>
<p>–ssh免密码快速登录配置</p>
<p>vi ～/.ssh/config<br>Host v21522<br>HostName localhost<br>Port 21522<br>User zhanghuo<br>IdentityFile ~/.ssh/id_rsa.pub</p>
<p>Host v31522<br>HostName localhost<br>Port 31522<br>User zhanghuo<br>IdentityFile ~/.ssh/id_rsa.pub</p>
<p>Host v51522<br>HostName localhost<br>Port 51522<br>User zhanghuo<br>IdentityFile ~/.ssh/id_rsa.pub</p>
<p>:wq</p>
<p>ssh-keygen -t rsa #存在id_rsa.pub则可不再执行</p>
<p>ssh-copy-id -i ~/.ssh/id_rsa.pub v31522<br>ssh-copy-id -i ~/.ssh/id_rsa.pub -p 31522 zhanghuo@localhost</p>
<p>ssh v31522</p>
<p>ssh-copy-id -i ~/.ssh/id_rsa.pub v51522</p>
<p>ssh v31522</p>
<hr>
<pre><code>vim /etc/ssh/sshd_config
#PermitRootLogin yes
#RSAAuthentication yes
#PubkeyAuthentication yes
将这三个配置打开 并进行对应的配置 全为yes</code></pre><p>DevStack|DevStack|21622</p>
<p>VBox无界面启动-DevStack<br>VBoxManage startvm DevStack  –type headless<br>ssh DevStack<br>关机<br>VBoxManage controlvm DevStack poweroff</p>
]]></content>
  </entry>
  <entry>
    <title>学习计划</title>
    <url>/2020/04/12/%E7%8E%AF%E5%A2%83/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h3 id="私有云平台环境-OpenStack-CloudStack"><a href="#私有云平台环境-OpenStack-CloudStack" class="headerlink" title="私有云平台环境 OpenStack\CloudStack"></a>私有云平台环境 OpenStack\CloudStack</h3><h3 id="Istio-是当前Service-Mesh领域最完善的解决方案"><a href="#Istio-是当前Service-Mesh领域最完善的解决方案" class="headerlink" title="Istio 是当前Service Mesh领域最完善的解决方案"></a>Istio 是当前Service Mesh领域最完善的解决方案</h3><p>![<a href="https://www.servicemesher.com/blog/supergloo-a-service-mesh-orchestrator/]">https://www.servicemesher.com/blog/supergloo-a-service-mesh-orchestrator/]</a><br>[<a href="https://blog.csdn.net/weixin_38669561/article/details/88944460]">https://blog.csdn.net/weixin_38669561/article/details/88944460]</a><br>[<a href="https://blog.csdn.net/lQ1NS259ej3OKYvK4Jf/article/details/82880131]">https://blog.csdn.net/lQ1NS259ej3OKYvK4Jf/article/details/82880131]</a><br>[<a href="https://cloud.tencent.com/developer/article/1356425]">https://cloud.tencent.com/developer/article/1356425]</a></p>
<p>第一种方法可以是一种基本的方法，其中Kubernetes与OpenStack共存来管理容器。它提供了良好的性能，但你不能通过单个pane来管理统一的基础设施资源。这会导致与跨工作负载规划和设计策略的相关问题。此外，很难诊断任何影响运行资源性能的问题。</p>
<p>第二种方法是在OpenStack管理的VM中运行Kubernetes集群。这使得基于OpenStack的基础设施能够在集中管理的OpenStack控制系统中利用kubernetes的优点。此外，它还允许OpenStack环境中的容器具有全功能的多租户和安全性优势。然而，这会导致性能滞后，需要额外的工作流程来管理托管Kubernetes的VM。</p>
<p>第三种方法是一种创新的方法，倾向于完全云原生环境。在这种方法中，OpenStack可以替换Kubernetes来管理容器和VM。工作负载完全利用了硬件加速器、智能网卡等。通过这种方法，可以为任何数据中心提供带有容器工作负载的集成VNS解决方案，但这需要改进OpenStack中的网络功能（SFC、Provider Networks、Segmentation）。</p>
<p>LinkedIn上Michiel Manten写了一篇非常不错的帖子。他说，容器和VM各有缺点。两者都有自己的用例和编排工具。如果将OpenStack和Kubernetes恰当地结合起来，在VM中运行一些工作负载，从而在服务器和容器中获得隔离的好处，那么OpenStack和Kubernetes将相得益彰。实现这种组合的一种方法是在OpenStack中的VM中运行Kubernetes集群，这样可以消除容器的安全隐患，同时利用VM的可靠性和弹性。</p>
<p>OpenStack支持目前使用的大多数企业存储和网络系统。在OpenStack上运行Kubernetes可以实现容器与IT基础设施的无缝集成。无论你是想用裸机或VM运行容器化应用程序，OpenStack都允许你以最适合业务的方式运行容器。</p>
<p>ESContainer\Mirantis </p>
<h3 id="k8s-docker-大数据环境"><a href="#k8s-docker-大数据环境" class="headerlink" title="k8s docker 大数据环境"></a>k8s docker 大数据环境</h3><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><h4 id="OpenStack-环境安装"><a href="#OpenStack-环境安装" class="headerlink" title="OpenStack 环境安装"></a>OpenStack 环境安装</h4><p>宿主机系统:ubuntu 18.04<br>虚拟机系统kvm：模拟多台主机<br>centos7-min-1908 1C1G 10G<br>centos7-min-1908 1C1G 10G</p>
<p>2.虚拟机环境配置</p>
<p>连接网络:CentOS最小安装不会自己联网，需要稍微配置一下</p>
<pre><code class="bash">vi /etc/sysconfig/network-scripts/ifcfg-eth0/ens33 
# 将ONBOOT条目修改为：ONBOOT=yes
service network restart # 重启网络
service sshd restart
# 便于我们使用ssh连接服务器，以使用复制粘贴的方法输入命令
yum install -y net-tools wget  #安装网络工具</code></pre>
<pre><code class="bash">ifconfig[192.168.122.48]
ssh root@ip
</code></pre>
<p>换源:虽然CentOS可以自动判断最快的源，但是为了以防万一，我们将源换为阿里云。</p>
<pre><code class="bash">yum install -y net-tools wget 
curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo 
curl -o /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo</code></pre>
<p>安装openstack源<br>阿里云只保存最近几个版本的openstack，所以需要我们手动确认最新版是哪个，前往<a href="https://mirrors.aliyun.com/centos/7/cloud/x86_64/查看openstack版本。版本号采用字母表命名法，我选的是train版">https://mirrors.aliyun.com/centos/7/cloud/x86_64/查看openstack版本。版本号采用字母表命名法，我选的是train版</a><br><a href="http://mirrors.aliyun.com/centos/7.7.1908/cloud/x86_64/">http://mirrors.aliyun.com/centos/7.7.1908/cloud/x86_64/</a><br><a href="http://mirrors.aliyun.com/centos/7/cloud/x86_64/">http://mirrors.aliyun.com/centos/7/cloud/x86_64/</a></p>
<pre><code class="bash"># 添加源
cat &gt; /etc/yum.repos.d/openstack-train.repo &lt;&lt; EOF
[openstack-train]
name=openstacktrain
baseurl=https://mirrors.aliyun.com/centos/7/cloud/x86_64/openstack-train/
failovermethod=priority
enabled=1
gpgcheck=0
EOF
# 查看源
cat /etc/yum.repos.d/openstack-train.repo
# 更新系统软件 
yum clean all &amp;&amp; yum makecache
# 设置环境变量：
vi /etc/environment

# 添加内容：
LANG=en_US.utf-8
LC_ALL=en_US.utf-8

# 禁用各种安全机制
systemctl stop firewalld
systemctl disable firewalld
systemctl stop NetworkManager
systemctl disable NetworkManager
vi /etc/selinux/config
    SELINUX=disabled

setenforce 0
getenforce
</code></pre>
<pre><code class="bash">hostnamectl set-hostname controller &amp;&amp; bash
</code></pre>
<p><a href="http://mirrors.aliyun.com/centos/7/cloud/x86_64/openstack-train/">http://mirrors.aliyun.com/centos/7/cloud/x86_64/openstack-train/</a></p>
<p>备份虚拟机</p>
<p>多合一（AIO）构建是一种执行OpenStack-Ansible构建的好方法：<br><a href="https://docs.openstack.org/openstack-ansible/latest/user/aio/quickstart.html">https://docs.openstack.org/openstack-ansible/latest/user/aio/quickstart.html</a></p>
<p>oVirt<br>[<a href="https://blog.csdn.net/bbwangj/article/details/80263654?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3]">https://blog.csdn.net/bbwangj/article/details/80263654?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3]</a></p>
<h4 id="进行安装"><a href="#进行安装" class="headerlink" title="进行安装"></a>进行安装</h4><pre><code class="bash">yum search all openstack-train
yum install -y centos-release-openstack-train
packstack --allinone
# 持续一小时左右，会报错，报错之后服务器部署好了，但还不能访问面板
# 我们需要使用报错生成的应答文件再次安装
packstack --answer-file packstack-answers
# 这里的时间随你的安装时间而变化.txt
</code></pre>
<pre><code>tar -zxvf openstack-ansible-stable_train.tar.gz 
scripts/bootstrap-ansible.sh
scripts/bootstrap-aio.sh
# cd /opt/openstack-ansible/playbooks
# openstack-ansible setup-hosts.yml
# openstack-ansible setup-infrastructure.yml
# openstack-ansible setup-openstack.yml
</code></pre>]]></content>
  </entry>
  <entry>
    <title>windows node 环境安装</title>
    <url>/2020/04/19/%E7%8E%AF%E5%A2%83/windows10%20node%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>使用 nvs 管理本地 Node.js 版本</p>
<h3 id="Linux-macOS-环境"><a href="#Linux-macOS-环境" class="headerlink" title="Linux / macOS 环境"></a>Linux / macOS 环境</h3><p>通过 Git Clone 对应的项目即可。</p>
<p>$ export NVS_HOME=”$HOME/.nvs”<br>$ git clone <a href="https://github.com/jasongin/nvs">https://github.com/jasongin/nvs</a> –depth=1 “$NVS_HOME”<br>$ . “$NVS_HOME/nvs.sh” install</p>
<h3 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h3><p>由于 Windows 环境配置比较复杂，所以还是推荐使用 msi 文件完成初始化工作。</p>
<p>访问 nvs/releases 下载最新版本的 nvs.msi，然后双击安装即可。</p>
<h2 id="配置镜像地址"><a href="#配置镜像地址" class="headerlink" title="配置镜像地址"></a>配置镜像地址</h2><p>在国内由于大家都懂的原因，需要把对应的镜像地址修改下：</p>
<p>$ nvs remote node <a href="https://npm.taobao.org/mirrors/node/">https://npm.taobao.org/mirrors/node/</a><br>$ nvs remote<br>default             node<br>chakracore          <a href="https://github.com/nodejs/node-chakracore/releases/">https://github.com/nodejs/node-chakracore/releases/</a><br>chakracore-nightly  <a href="https://nodejs.org/download/chakracore-nightly/">https://nodejs.org/download/chakracore-nightly/</a><br>nightly             <a href="https://nodejs.org/download/nightly/">https://nodejs.org/download/nightly/</a><br>node                <a href="https://nodejs.org/dist/">https://nodejs.org/dist/</a></p>
<h2 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h2><p>通过以下命令，即可非常简单的安装 Node.js 最新的 LTS 版本。</p>
<h1 id="安装最新的-LTS-版本"><a href="#安装最新的-LTS-版本" class="headerlink" title="安装最新的 LTS 版本"></a>安装最新的 LTS 版本</h1><p>$ nvs add lts</p>
<h1 id="配置为默认版本"><a href="#配置为默认版本" class="headerlink" title="配置为默认版本"></a>配置为默认版本</h1><p>$ nvs link lts<br>安装其他版本：</p>
<h1 id="安装其他版本尝尝鲜"><a href="#安装其他版本尝尝鲜" class="headerlink" title="安装其他版本尝尝鲜"></a>安装其他版本尝尝鲜</h1><p>$ nvs add 12</p>
<h1 id="查看已安装的版本"><a href="#查看已安装的版本" class="headerlink" title="查看已安装的版本"></a>查看已安装的版本</h1><p>$ nvs ls</p>
<h1 id="在当前-Shell-切换版本"><a href="#在当前-Shell-切换版本" class="headerlink" title="在当前 Shell 切换版本"></a>在当前 Shell 切换版本</h1><p>$ nvs use 12<br>更多指令参见 nvs –help 。</p>
<h2 id="共用-npm-全局模块"><a href="#共用-npm-全局模块" class="headerlink" title="共用 npm 全局模块"></a>共用 npm 全局模块</h2><p>使用 nvs 时，默认的 prefix 是当前激活的 Node.js 版本的安装路径。</p>
<p>带来一个问题是：切换版本之后，之前安装全局命令模块需要重新安装，非常不方便。</p>
<p>解决方案是配置统一的全局模块安装路径到 ~/.npm-global，如下：</p>
<p>$ mkdir -p ~/.npm-global<br>$ npm config set prefix ~/.npm-global<br>还需配置环境变量到 ~/.bashrc 或 ~/.zshrc 文件里面：</p>
<p>$ echo “export PATH=~/.npm-global/bin:$PATH” &gt;&gt; ~/.zshrc<br>$ source ~/.zshrc</p>
]]></content>
  </entry>
  <entry>
    <title>Markdown 语法手册 （完整整理版）</title>
    <url>/2020/04/07/%E5%A4%87%E5%BF%98/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C-%EF%BC%88%E5%AE%8C%E6%95%B4%E6%95%B4%E7%90%86%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="最小只有六级标题"><a href="#最小只有六级标题" class="headerlink" title="最小只有六级标题"></a>最小只有六级标题</h6><p>加粗<strong>我被加粗了</strong><br>斜体<em>我倾斜了了</em><br>高亮==我高亮了==<br>上标#2^2^<br>下标H<del>2</del>o<br>代码引用（&gt;式）</p>
<blockquote>
<p>hello markdown!<br>hello markdown!</p>
<blockquote>
<p>hello markdown!<br>代码引用（```式）</p>
</blockquote>
</blockquote>
<pre><code class="python">print(&#39;hello nick&#39;)</code></pre>
<span id="more"></span>

<p>代码引入（<code>式）</code>print(‘hello nick’)`<br>插入链接（链接显示）#<br><a href="https://www.cnblogs.com/nickchen121/p/10718112.html">https://www.cnblogs.com/nickchen121/p/10718112.html</a><br>插入链接（链接描述显示）#<br><a href="https://www.cnblogs.com/nickchen121/p/10718112.html" title="nickchen博客">nickchen博客</a><br>插入图片（链接）#<br><img src="http://www.chenyoude.com/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-%E6%90%9E%E7%AC%91%E7%BB%93%E6%9D%9F.jpg?x-oss-process=style/watermark" alt="数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark" title="描述信息"></p>
<p>插入图片（图片路径）#<br>绝对路径：.md文本同目录下图片的名字，如数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark</p>
<p>相对路径：图片在电脑中的路径地址，如\Users\nick\mac\desktop\数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark</p>
<p><img src="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-%E6%90%9E%E7%AC%91%E7%BB%93%E6%9D%9F.jpg?x-oss-process=style/watermark" alt="数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark" title="描述信息"></p>
<p><img src="%5CUsers%5Cnick%5Cmac%5Cdesktop%5C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93-%E6%90%9E%E7%AC%91%E7%BB%93%E6%9D%9F.jpg?x-oss-process=style/watermark" alt="数据类型总结-搞笑结束.jpg?x-oss-process=style/watermark" title="描述信息"></p>
<p>有序列表</p>
<ol>
<li>one</li>
<li>two </li>
<li>three<br>无序列表</li>
</ol>
<ul>
<li>one</li>
<li>two</li>
<li>three<br>分割线#</li>
</ul>
<hr>
<p>表格而且第二行必须得有，并且第二行的冒号代表对齐格式，分别为居中；右对齐；左对齐）：#<br>name | age | sex<br>:-:|:-|-:<br>tony|20|男<br>lucy|18|女</p>
<p>数学公式（行内嵌）#<br>内嵌数学公式<br>$sum_{i=1}^{10}f(i),,text{thanks}$<br>数学公式（块状）#<br>$$<br>sum_{i=1}^{10}f(i),,text{thanks}<br>$$</p>
<h3 id="Markdown-编辑器语法指南"><a href="#Markdown-编辑器语法指南" class="headerlink" title="Markdown 编辑器语法指南"></a>Markdown 编辑器语法指南</h3><p>如果你只想高亮语句中的某个函数名或关键字，可以使用 <code>function_name()</code> 实现</p>
<p>通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 ``` 包裹一段代码，并指定一种语言</p>
<pre><code class="javascript">$(document).ready(function () &#123;
    alert(&#39;hello world&#39;);
&#125;);</code></pre>
<p>支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir</p>
<p>也可以使用 4 空格缩进，再贴上代码，实现相同的的效果<br>    def g(x):<br>        yield from range(x, 0, -1)<br>    yield from range(x)<br>如你不需要代码高亮，可以用下面的方法禁用：</p>
<pre><code class="nohighlight">nohighlight</code></pre>
<p>标题<br>文章内容较多时，可以用标题分段：</p>
<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h2 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h2><h3 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h3><h2 id="粗斜体"><a href="#粗斜体" class="headerlink" title="粗斜体"></a>粗斜体</h2><p><em>斜体文本</em>    <em>斜体文本</em><br><strong>粗体文本</strong>    <strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong>    <strong><em>粗斜体文本</em></strong></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>文字链接 <a href="http://链接网址">链接名称</a><br>网址链接 <a href="http://链接网址">http://链接网址</a><br>高级链接技巧<br>这个链接用 1 作为网址变量 [Google][1].<br>这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].<br>然后在文档的结尾为变量赋值（网址）<br>  [1]: <a href="http://www.google.com/">http://www.google.com/</a><br>  [yahoo]: <a href="http://www.yahoo.com/">http://www.yahoo.com/</a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h4 id="普通无序列表"><a href="#普通无序列表" class="headerlink" title="普通无序列表"></a>普通无序列表</h4><ul>
<li>列表文本前使用 [减号+空格]</li>
</ul>
<ul>
<li>列表文本前使用 [加号+空格]</li>
</ul>
<ul>
<li>列表文本前使用 [星号+空格]<h4 id="普通有序列表"><a href="#普通有序列表" class="headerlink" title="普通有序列表"></a>普通有序列表</h4></li>
</ul>
<ol>
<li><p>列表前使用 [数字+空格]</p>
</li>
<li><p>我们会自动帮你添加数字</p>
</li>
<li><p>不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3</p>
<h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4></li>
<li><p>列出所有元素：</p>
<ul>
<li>无序列表元素 A<ol>
<li>元素 A 的有序子列表</li>
</ol>
</li>
<li>前面加四个空格</li>
</ul>
</li>
<li><p>列表里的多段换行：<br> 前面必须加四个空格，<br> 这样换行，整体的格式不会乱</p>
</li>
<li><p>列表里引用：</p>
<blockquote>
<p>前面空一行<br>仍然需要在 &gt;  前面加四个空格</p>
</blockquote>
</li>
<li><p>列表里代码段：</p>
<pre><code> 前面四个空格，之后按代码语法 ``` 书写</code></pre><pre><code> 或者直接空八个，引入代码块</code></pre></li>
</ol>
<h2 id="普通引用"><a href="#普通引用" class="headerlink" title="普通引用"></a>普通引用</h2><blockquote>
<p>引用文本前使用 [大于号+空格]<br>折行可以不加，新起一行都要加上哦</p>
</blockquote>
<h2 id="引用里嵌套引用"><a href="#引用里嵌套引用" class="headerlink" title="引用里嵌套引用"></a>引用里嵌套引用</h2><blockquote>
<p>最外层引用</p>
<blockquote>
<p>多一个 &gt; 嵌套一层引用</p>
<blockquote>
<p>可以嵌套很多层</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="引用里嵌套列表"><a href="#引用里嵌套列表" class="headerlink" title="引用里嵌套列表"></a>引用里嵌套列表</h2><blockquote>
<ul>
<li>这是引用里嵌套的一个列表</li>
<li>还可以有子列表<ul>
<li>子列表需要从 - 之后延后四个空格开始</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="引用里嵌套代码块"><a href="#引用里嵌套代码块" class="headerlink" title="引用里嵌套代码块"></a>引用里嵌套代码块</h2><blockquote>
<pre><code>同样的，在前面加四个空格形成代码块</code></pre><pre><code>或者使用 ``` 形成代码块</code></pre></blockquote>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？<br><img src="http://%E5%9B%BE%E7%89%87%E7%BD%91%E5%9D%80" alt="图片名称"><br>当然，你也可以像网址那样对图片网址使用变量<br>这个链接用 1 作为网址变量 [Google][1].<br>然后在文档的结尾位变量赋值（网址）<br> [1]: <a href="http://www.google.com/logo.png">http://www.google.com/logo.png</a></p>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>如果另起一行，只需在当前行结尾加 2 个空格<br>在当前行的结尾加 2 个空格<br>这行就会新起一行<br>如果是要起一个新段落，只需要空出一行即可。</p>
<h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行：</p>
<p>前面的段落</p>
<hr>
<p>后面的段落</p>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><p>行内 HTML 元素<br>目前只支持部分段内 HTML 元素效果，包括 <kdb> <b> <i> <em> <sup> <sub> <br> ，如</p>
<h2 id="键位显示"><a href="#键位显示" class="headerlink" title="键位显示"></a>键位显示</h2><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑<br>代码块使用 <pre></pre> 元素同样可以形成代码块<br>粗斜体<b> Markdown 在此处同样适用，如 <em>加粗</em> </b><br>符号转义<br>如果你的描述中需要用到 markdown 的符号，比如 _ # * 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 _ # * 进行避免。<br>_不想这里的文本变斜体_<br>**不想这里的文本被加粗**</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。<br>http://{url_of_the_fiddle}/embedded/[{tabs}/[{style}]]/<br><a href="https://gist.github.com/{gist_id}">https://gist.github.com/{gist_id}</a><br><a href="http://runjs.cn/detail/{id}">http://runjs.cn/detail/{id}</a><br><a href="http://v.youku.com/v_show/id_{video_id}.html">http://v.youku.com/v_show/id_{video_id}.html</a></p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：<br>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$</p>
<p>$$<br>x \href{why-equal.html}{=} y^2 + 1<br>$$</p>
<p>同时也支持 HTML 属性，如：<br>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$</p>
<p>$$<br>(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>
<h2 id="斜体和粗体"><a href="#斜体和粗体" class="headerlink" title="斜体和粗体"></a>斜体和粗体</h2><p><em>斜体</em>或<em>斜体</em><br><strong>粗体</strong><br><strong><em>加粗斜体</em></strong><br><del>删除线</del></p>
<h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><p>第二种写法：</p>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题-1"><a href="#三级标题-1" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题-1"><a href="#四级标题-1" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题-1"><a href="#五级标题-1" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>由于用了[TOC]标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。同学们自己在编辑器中观察，很简单，一级标题字号最大，依级递减。</p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p>
<h2 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h2><p>语法说明：</p>
<p>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。<br>代码：</p>
<p>欢迎来到<a href="http://blog.leanote.com/freewalk">梵居闹市</a><br>欢迎来到<a href="http://blog.leanote.com/freewalk" title="梵居闹市">梵居闹市</a></p>
<h2 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h2><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。<br>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p>
<p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。<br>代码：<br>我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]<br>[Leanote 笔记][2]是一个不错的[网站][]。<br>[1]:<a href="http://www.google.com">http://www.google.com</a> “Google”<br>[2]:<a href="http://www.leanote.com">http://www.leanote.com</a> “Leanote”<br>[3]:<a href="http://http://blog.leanote.com/freewalk">http://http://blog.leanote.com/freewalk</a> “梵居闹市”<br>[网站]:<a href="http://http://blog.leanote.com/freewalk">http://http://blog.leanote.com/freewalk</a></p>
<h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>语法说明：<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：<br>代码：<br><a href="http://example.com/">http://example.com/</a><br><a href="mailto:&#97;&#x64;&#x64;&#x72;&#x65;&#x73;&#x73;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;">&#97;&#x64;&#x64;&#x72;&#x65;&#x73;&#x73;&#64;&#101;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#x63;&#x6f;&#x6d;</a></p>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。<br>注意： </p>
<ol>
<li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。 </li>
<li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li>
</ol>
<p>语法描述：<br>在你准备跳转到的指定标题后插入锚点{ #标记}，然后在文档的其它地方写上连接到锚点的链接。<br>代码：</p>
<h2 id="0-目录-index"><a href="#0-目录-index" class="headerlink" title="0. 目录{ #index}"></a>0. 目录{ #index}</h2><p>跳转到<a href="#index">目录</a></p>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>使用 *，+，- 表示无序列表。<br>代码：</p>
<ul>
<li>无序列表项 一</li>
<li>无序列表项 二</li>
<li>无序列表项 三<br>有序列表</li>
</ul>
<hr>
<p>有序列表则使用数字接着一个英文句点。<br>代码：</p>
<ol>
<li>有序列表项 一</li>
<li>有序列表项 二</li>
<li>有序列表项 三<br>定义型列表</li>
</ol>
<hr>
<dl><dt>语法说明：<br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)<br>代码：<br>Markdown<br>:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）<br>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）<br>        代码块（左侧有八个不可见的空格）<br>列表缩进</dd></dl><hr>
<p>语法说明：<br>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：</p>
<p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。<br>但是如果你懒，那也行：<br>代码：</p>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ </li>
<li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li>
</ul>
<h2 id="包含段落的列表"><a href="#包含段落的列表" class="headerlink" title="包含段落的列表"></a>包含段落的列表</h2><p>语法说明：</p>
<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：</p>
<p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</p>
<p>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！</p>
<p>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p>
<p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：<br>代码：</p>
<ul>
<li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br> 那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </li>
<li>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li>
</ul>
<h2 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h2><p>语法说明：<br>如果要在列表项目内放进引用，那 &gt; 就需要缩进：<br>代码：</p>
<ul>
<li>阅读的方法:<blockquote>
<p>打开书本。<br>打开电灯。</p>
</blockquote>
</li>
</ul>
<h2 id="包含代码区块的引用"><a href="#包含代码区块的引用" class="headerlink" title="包含代码区块的引用"></a>包含代码区块的引用</h2><p>语法说明：<br>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<p>一列表项包含一个列表区块：</p>
<p>&lt;代码写在这&gt;</p>
<h2 id="一个特殊情况"><a href="#一个特殊情况" class="headerlink" title="一个特殊情况"></a>一个特殊情况</h2><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<ol start="1986">
<li>What a great season.<br>会显示成：</li>
</ol>
<p>What a great season.<br>换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p>
<p>1986. What a great season.<br>会显示成：</p>
<ol start="1986">
<li>What a great season.</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>语法说明：</p>
<p>引用需要在被引用的文本前加上&gt;符号。</p>
<p>代码：</p>
<blockquote>
<p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.</p>
<p>无意义的占行文字3.<br>无意义的占行文字4.</p>
</blockquote>
<p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：<br>代码：</p>
<blockquote>
<p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.<br>无意义的占行文字3.<br>无意义的占行文字4.<br>显示效果：</p>
</blockquote>
<p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.</p>
<p>无意义的占行文字3.<br>无意义的占行文字4.</p>
<h2 id="引用的多层嵌套"><a href="#引用的多层嵌套" class="headerlink" title="引用的多层嵌套"></a>引用的多层嵌套</h2><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：<br>代码：</p>
<blockquote>
<blockquote>
<blockquote>
<p>请问 Markdwon 怎么用？ - 小白<br>自己看教程！ - 愤青<br>教程在哪？ - 小白</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="引用其它要素"><a href="#引用其它要素" class="headerlink" title="引用其它要素"></a>引用其它要素</h2><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：<br>代码：</p>
<blockquote>
<ol>
<li>这是第一行列表项。</li>
<li>这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote>
<p>return shell_exec(“echo $input | $markdown_script”);<br>7. 插入图像<br>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p>
<p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p>
<h2 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h2><p>语法说明：![图片Alt](图片地址 “图片Title”)<br>代码：<br>美丽花儿：<br><img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p>
<h2 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h2><p>语法说明：</p>
<p>在文档要插入图片的地方写![图片Alt][标记]</p>
<p>在文档的最后写上[标记]:图片地址 “Title”</p>
<p>代码：<br>美丽花儿：<br>![美丽花儿][flower]<br>[flower]:<a href="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg">http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg</a>  “美丽花儿”</p>
<h2 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h2><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p>
<p>效果参见最上方的目录</p>
<h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>语法说明：</p>
<p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p>
<p>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p>
<p>代码：</p>
<p>使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。<br>[^1]:Markdown是一种纯文本标记语言<br>[^2]:HyperText Markup Language 超文本标记语言<br>[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文<br>显示效果：</p>
<p>使用 Markdown1可以效率的书写文档, 直接转换成 HTML2, 你可以使用 Leanote3 编辑器进行书写。</p>
<p>注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</p>
<h2 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h2><p>$ 表示行内公式：<br>代码：</p>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。<br>显示效果：</p>
<p>质能守恒方程可以用一个很简洁的方程式  来表达。</p>
<h2 id="表示整行公式："><a href="#表示整行公式：" class="headerlink" title="$$ 表示整行公式："></a>$$ 表示整行公式：</h2><p>代码：<br>$$\sum_{i=1}^n a_i=0$$<br>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$<br>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>代码：<br>flow<br>st=&gt;start: Start:&gt;<a href="https://www.zybuluo.com">https://www.zybuluo.com</a><br>io=&gt;inputoutput: verification<br>op=&gt;operation: Your Operation<br>cond=&gt;condition: Yes or No?<br>sub=&gt;subroutine: Your Subroutine<br>e=&gt;end<br>st-&gt;io-&gt;op-&gt;cond<br>cond(yes)-&gt;e<br>cond(no)-&gt;sub-&gt;io</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法说明：<br>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。<br>列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。<br>第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。<br>代码：<br>简单方式写表格：<br>学号|姓名|分数<br>-|-|-<br>小明|男|75<br>小红|女|79<br>小陆|男|92<br>原生方式写表格：</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>男</td>
<td>75</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>79</td>
</tr>
<tr>
<td>小陆</td>
<td>男</td>
<td>92</td>
</tr>
<tr>
<td>为表格第二列指定方向：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>产品</th>
<th align="right">价格</th>
</tr>
</thead>
<tbody><tr>
<td>Leanote 高级账号</td>
<td align="right">60元/年</td>
</tr>
<tr>
<td>Leanote 超级账号</td>
<td align="right">120元/年</td>
</tr>
</tbody></table>
<h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线</p>
<p>代码：</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。</p>
<p>语法说明：</p>
<p>插入行内代码，即插入一个单词或者一句代码的情况，使用<code>code</code>这样的形式插入。<br>插入多行代码，可以使用缩进或者“<code>code “</code>,具体看示例。<br>注意： 缩进式插入前方必须有空行</p>
<h2 id="行内式-2"><a href="#行内式-2" class="headerlink" title="行内式"></a>行内式</h2><p>代码：</p>
<p>C语言里的函数 <code>scanf()</code> 怎么使用？<br>缩进式多行代码</p>
<hr>
<p>缩进 4 个空格或是 1 个制表符<br>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。<br>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
int main(void)
&#123;
    printf(&quot;Hello world\n&quot;);
&#125;</code></pre><h2 id="用六个-包裹多行代码"><a href="#用六个-包裹多行代码" class="headerlink" title="用六个`包裹多行代码"></a>用六个`包裹多行代码</h2><p>代码：</p>
<pre><code>#include &lt;stdio.h&gt;
int main(void)
&#123;
    printf(&quot;Hello world\n&quot;);
&#125;</code></pre><h2 id="HTML-原始码"><a href="#HTML-原始码" class="headerlink" title="HTML 原始码"></a>HTML 原始码</h2><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p>
<p>代码：</p>
<p>第一个例子：</p>
<div class="footer">
   © 2004 Foo Corporation
</div>
第二个例子：

<table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>]]></content>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2020/04/05/%E5%BC%80%E5%8F%91/docker/</url>
    <content><![CDATA[<h2 id="常用docker命令"><a href="#常用docker命令" class="headerlink" title="常用docker命令"></a>常用docker命令</h2><span id="more"></span>
<h4 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h4><pre><code>列表|docker images    |查看本地docker仓库的所有镜像
docker images 列出本地所有镜像
检索 docker search keywork eg: docker search tomcat 去docker hub搜索镜像的详细信息
docker search(-s) nginx 搜索相关镜像　加上-s 参数 选出至少start数范围的镜像
docker pull（-a） 镜像名:版本号　拉取镜像,-a pull all
拉取 docker pull keywork:tag eg: docker pull tomcat:latest|    tag是可选的，不指定默认拉取latest最新版本
&lt;!--more--&gt;
docker push 192.168.0.100:5000/ubuntu 　　  推送镜像库到私有源
删除|docker rmi imageId eg: docker rmi 6408fdc94212    |删除本地docker仓库镜像
docker rmi（-f） 镜像名：版本号/镜像ID 　　删除镜像 （加上 -f 参数 强制删除）
docker rmi $(docker images -q)　　删除所有镜像
docker rmi $(docker images | grep &quot;none&quot; | awk &#39;&#123;print $3&#125;&#39;) 删除所有名字中带“none” 关键字的镜像

sudo docker rmi $(sudo docker images | grep &quot;eclipse&quot; | awk &#39;&#123;print $3&#125;&#39;)

docker save docker.io``/tomcat``:7.0.77-jre7 &gt;``/root/mytomcat7``.``tar``.gz 导出镜像`
docker load &lt; ``/root/mytomcat7``.``tar``.gz　　导入镜像`</code></pre><pre><code>
#基本命令
#查看docker服务运行状态
sudo systemctl status docker

#启动docker服务
sudo systemctl start docker

#停止docker服务
sudo systemctl stop docker

#查看所有本地镜像
sudo docker images

#查看正在运行的容器
sudo docker ps
#查看所有容器
sudo docker ps -a

#删除本地镜像 -f表示强制删除(可选)
sudo docker rmi -f [镜像id]
#删除指定容器 
sudo docker rm [容器Id|容器名]
--
#1 添加docker用户组(一般安装docker时会自动添加)
sudo groupadd docker 
#2 将指定用户添加到docker用户组中 注:将USER替换为自己的用户名
sudo gpasswd -a USER docker
#3 重启docker服务
sudo systemctl restart docker
#4 退出SSH连接，重新登录
</code></pre><h3 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h3><pre><code>docker ps 查看当前正在运行的容器
docker inspect name/image[name/image...] 查看详细
docker ps -a 查看所有容器的状态
docker start/stop(-t) id/name[name...] 启动/停止某个（多个）容器 -t 指定时间
docker kill (-s) name[name...] 强制中断 -s指定SIGINT信号类型，默认“kill”
docker restart (-t) name[name...] 重启 -t 指定时间
docker pause name　暂停　　docker unpause name 继续
docker rm(-$) name[name...] 移除 
    -f　　--force=false　　强制移除运行中容器
    -l　　--link=false　　 移除指定链接，保留底层容器
    -v　 --volumes=false  移除容器关联卷
docker commit(-$)name 镜像名:版本号 　　提交指定容器为镜像
    -a, --author=&quot;&quot; 　　　　作者
    -m, --message=&quot;&quot; 　　 简要说明
    -p, --pause=true 　　　暂停容器再提交
docker logs(-$) name　　输出指定容器日志信息
    -f　　跟踪日志输出
    -t　　显示时间戳 类似 tail -f
    --tail 在日志的末尾输出指定行数日志（默认所有日志）
docker attach id 进入某个容器(使用exit退出后容器也跟着停止运行)
docker exec -ti id 启动一个伪终端以交互式的方式进入某个容器（使用exit退出后容器不停止运行）
docker run(-$) IMAGE [COMMAND] [ARG...] 　 运行一个容器
    -d　　　　　　　　  指定容器运行于前台还是后台，默认为false   
    -i　　　　　　　　  打开STDIN，用于控制台交互，默认为false 
    -t　　　　　　　　  分配tty设备，该可以支持终端登录，默认为false  
    -u, --user=&quot;&quot;       指定容器的用户  
    -a, --attach=[]      登录容器（必须是以docker run -d启动的容器） 
    -w　　　　　　　　  指定容器的工作目录 
    -c   　　　　　　　设置容器CPU权重，在CPU共享场景使用  
    -e, --env=[]        指定环境变量，容器中可以使用该环境变量  
    -m　　　　　　　　  指定容器的内存上限  
    -P, --publish-all=false 指定容器暴露的端口  
    -p, --publish=[]      指定容器暴露的端口  
    -h　　　　　　　　　指定容器的主机名  
    -v, --volume=[]      给容器挂载存储卷，挂载到容器的某个目录 
    --volumes-from=[]    给容器挂载其他容器上的卷，挂载到容器的某个目录 
    --cap-add=[]　　　　 添加权限
    --cap-drop=[]   　 删除权限
    --cidfile=&quot;&quot;　　　　　 运行容器后，在指定文件中写入容器PID值，监控系统用法  
    --cpuset=&quot;&quot;　 　　　 设置容器可使用哪些CPU，此参数可以用来容器独占CPU  
    --device=[]   　　　  添加主机设备给容器，相当于设备直通  
    --dns=[]            指定容器的dns服务器  
    --dns-search=[]      指定容器的dns搜索域名，写入到容器/etc/resolv.conf文件  
    --entrypoint=&quot;&quot;       覆盖image的入口点  
    --env-file=[]          指定环境变量文件，文件格式为每行一个环境变量  
    --expose=[]         指定容器暴露的端口，即修改镜像的暴露端口  
    --link=[]            指定容器间的关联，使用其他容器的IP、env等信息  
    --lxc-conf=[]         指定容器的配置文件，只有在指定--exec-driver=lxc时使用  
    --name=&quot;&quot;          指定容器名字，links特性需要使用名字  
    --net=&quot;bridge&quot;       容器网络设置: 
        bridge 使用docker daemon指定的网桥    
        host  //容器使用主机的网络  
        container:NAME_or_ID &gt;//使用其他容器的网路共享IP和PORT等网络资源  
        none 容器使用自己的网络（类似--net=bridge）
    --privileged=false     指定容器是否为特权容器，特权容器拥有所有的权限
    --restart=&quot;no&quot;        指定容器停止后的重启策略: 
        no：　　　　容器退出时不重启  
        on-failure：  容器故障退出（返回值非零）时重启  
        always：　　 容器退出时总是重启  
    --rm=false      指定容器停止后自动删除容器(不支持以docker run -d启动的容器)  
    --sig-proxy=true 设置由代理接受并处理信号，SIGCHLD，SIGSTOP和SIGKILL不代
例：
docker run -i -t centos6.8 进入到默认的线程”/bin/bash”，直接进入控制台操作
docker run -i -t -d centos6.8 进入到默认的线程”/bin/bash”，后台运行
docker run -d --restart=always centos6.8 ping www.docker.com 带命令启动
docker run -d --name=server-dbcentos6.8-mysql /usr/bin/mysql_safe -d 容器的名称为server-db，同时激活了数据库mysql的后台线程
docker run -d --name=server-db -p 3306:3306 -v /server/mysql-data:/
mysql-datacentos6.8-mysql /usr/bin/mysql_safe –d
docker run -d --name=server-db -p 3306:3306 centos6.8-mysql /usr/bin/mysql_safe –d 服务器宿主机与容器端口映射并暴露
docker run -d --name=server-http --link=server-db  -p 8080:80centos6.8-httpd /usr/bin/httpd --DFOREGROUND 映射服务器宿主机的8080端口，关联service-db 
docker run -it --rm centos6.8　　容器进程结束后，立马自动删除</code></pre><h4 id="docker-option"><a href="#docker-option" class="headerlink" title="docker option"></a>docker option</h4><pre><code>    --api-enable-cors=false      在远程API中启用CORS 头
    -b, --bridge=&quot;&quot;          　　桥接网络 使用“none” 禁用容器网络
    --bip=&quot;&quot;             　　　网桥模式                     
    -d, --daemon=false         守护者模式
    -D, --debug=false          debug 模式
    --dns=[]             　　  强制 docker 使用指定 dns 服务器
    --dns-search=[]         　 强制 docker 使用指定 dns 搜索域
    -e, --exec-driver=&quot;native&quot;     强制 docker 运行时使用指定执行驱动器
    --fixed-cidr=&quot;&quot;          　　 固定IP的IPv4子网(例: 10.20.0.0/16)必须镶套在桥子网中(由-b or --bip定义)                     
    -G, --group=&quot;docker&quot;        当在守护模式中运行时，组指向-H指定的unix套接字。使用&quot;&quot;禁用组设置。
    -g, --graph=&quot;/var/lib/docker&quot;   容器运行的根目录路径
    -H, --host=[]            　 套接字绑定到守护模式。使用一个或多个tcp://主机:端口，unix:///路径/到/套接字，fd://*或fd://socketfd.
    --icc=true            　　  inter-container跨容器通信
    --insecure-registry=[]        使用指定的注册表启用不安全通信(没有HTTPS的证书验　证和启用HTTP回退)(例如，localhost:5000或10.20.0 /16)
    --ip=&quot;0.0.0.0&quot;          　　 绑定容器端口时使用的IP地址
    --ip-forward=true           使用net.ipv4.ip_forward转发
    --ip-masq=true        使IP伪装成桥的IP范围
    --iptables=true          　　启用Docker添加iptables规则
    --mtu=0              　　  设置容器网络mtu               
    -p, --pidfile=&quot;/var/run/docker.pid&quot;   指定守护进程pid文件位置
    --registry-mirror=[]       　　指定一个首选的镜像仓库（加速地址）         
    -s, --storage-driver=&quot;&quot;        强制 docker 运行时使用指定存储驱动
    --selinux-enabled=false       开启 selinux 支持
    --storage-opt=[]         　　设置存储驱动选项
    --tls=false            　　　 开启 tls
    --tlscacert=&quot;/root/.docker/ca.pem&quot;　　只信任提供CA签名的证书
    --tlscert=&quot;/root/.docker/cert.pem&quot;    tls 证书文件位置
    --tlskey=&quot;/root/.docker/key.pem&quot; 　　 tls key 文件位置
    --tlsverify=false         　　　　　 使用 tls 并确认远程控制主机-v, 
    --version=false   输出 docker 版本信息</code></pre><h1 id="Docker-容器镜像删除"><a href="#Docker-容器镜像删除" class="headerlink" title="Docker 容器镜像删除"></a><a href="https://www.cnblogs.com/q4486233/p/6482711.html">Docker 容器镜像删除</a></h1><pre><code>1.停止所有的container，这样才能够删除其中的images：
docker stop $(docker ps -a -q)
如果想要删除所有container的话再加一个指令：
docker rm $(docker ps -a -q)
2.查看当前有些什么images
docker images
3.删除images，通过image的id来指定删除谁
docker rmi &lt;image id&gt;
想要删除untagged images，也就是那些id为&lt;None&gt;的image的话可以用
docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;&#123;print $3&#125;&quot;)
要删除全部image的话
docker rmi $(docker images -q)</code></pre><p><strong>1、导出某个容器</strong><br>导出某个容器，非常简单，使用docker export命令，语法：docker export $container_id &gt; 容器快照名<br><strong>2、导入某个容器</strong>–docker import命令<br>有了容器快照之后，我们可以在想要的时候随时导入。导入快照使用docker import命令。<br>例如我们可以使用cat centos.tar | docker import - my/centos:v888 导入容器快照作为镜像<br>处理本地的容器快照导入为镜像，我们还可以通过指定一个URL或者目录来导入。<br>例如在某个网络上有个快照image_test.tgz：docker import <a href="http://xxxx.com/image_test.tgz">http://xxxx.com/image_test.tgz</a> test/image_test<br><strong>镜像保存/载入</strong>：docker load/docker save；将一个镜像导出为文件，再使用docker load命令将文件导入为一个镜像，会保存该镜像的的所有历史记录。比docker export命令导出的文件大，很好理解，因为会保存镜像的所有历史记录。<br><strong>容器导入/导出</strong>：docker import/docker export；将一个容器导出为文件，再使用docker import命令将容器导入成为一个新的镜像，但是相比docker save命令，容器文件会丢失所有元数据和历史记录，仅保存容器当时的状态，相当于虚拟机快照。<br><strong>3、删除容器</strong><br>可以使用”docker rm 容器id”来删除一个终止状态的容器；若要删除一个运行中的容器，需要加-f参数。</p>
<h2 id="清除所有未使用或悬空的图像，容器，卷和网络"><a href="#清除所有未使用或悬空的图像，容器，卷和网络" class="headerlink" title="清除所有未使用或悬空的图像，容器，卷和网络"></a><strong>清除所有未使用或悬空的图像，容器，卷和网络</strong></h2><p>Docker提供了一个命令，可以清理悬空的任何资源（图像，容器，卷和网络）（与容器无关）：</p>
<pre><code class="javascript">docker system prune</code></pre>
<p>要另外删除任何已停止的容器和所有未使用的图像（不只是悬空图像），请将该<code>-a</code>标志添加到命令：</p>
<pre><code class="javascript">docker system prune -a</code></pre>
<h2 id="删除Docker镜像"><a href="#删除Docker镜像" class="headerlink" title="删除Docker镜像"></a><strong>删除Docker镜像</strong></h2><h3 id="删除一个或多个特定图像"><a href="#删除一个或多个特定图像" class="headerlink" title="删除一个或多个特定图像"></a><strong>删除一个或多个特定图像</strong></h3><p>使用带有<code>-a</code>标志的命令<code>docker images</code>可以找到要删除的图像的ID。这将显示每个图像，包括中间图像层。当您找到要删除的图像时，可以将其ID或标记传递给<code>docker rmi</code>：<br><strong>列表：</strong></p>
<pre><code class="javascript">docker images -a</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker rmi Image Image</code></pre>
<h3 id="删除悬空图像"><a href="#删除悬空图像" class="headerlink" title="删除悬空图像"></a><strong>删除悬空图像</strong></h3><p>Docker图像由多个图层组成。悬空图像是与任何标记图像无关的图层。它们不再用于目的并占用磁盘空间。它们可以通过添加具有值<code>dangling=true</code>的<code>-f</code>过滤器标志到<code>docker images</code>的命令来定位。如果您确定要删除它们，可以使用以下<code>docker images purge</code>命令：</p>
<p><strong>注意：</strong>如果您在不标记图像的情况下构建图像，则图像将显示在悬空图像列表中，因为它与标记图像无关。您可以通过在构建时提供标记来避免这种情况，并且可以使用docker tag命令追溯标记图像。</p>
<p><strong>列表：</strong></p>
<pre><code class="javascript">docker images -f dangling=true</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker images purge</code></pre>
<h3 id="根据图案删除图像"><a href="#根据图案删除图像" class="headerlink" title="根据图案删除图像"></a><strong>根据图案删除图像</strong></h3><p>你可以使用组合模式<code>docker images</code>和<code>grep</code>找到相匹配的图像。一旦您满意，您可以通过使用<code>awk</code>来删除它们<code>docker rmi</code>。请注意，这些实用程序不是由Docker提供的，并不一定适用于所有系统：</p>
<p><strong>列表：</strong></p>
<pre><code class="javascript">docker images -a |  grep &quot;pattern&quot;</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker images -a | grep &quot;pattern&quot; | awk &#39;&#123;print $3&#125;&#39; | xargs docker rmi</code></pre>
<h3 id="删除所有图像"><a href="#删除所有图像" class="headerlink" title="删除所有图像"></a><strong>删除所有图像</strong></h3><p>通过添加<code>-a</code>到<code>docker images</code>命令，可以列出系统上的所有Docker映像。一旦确定要全部删除它们，就可以添加<code>-q</code>标志以将图像ID传递给<code>docker rmi</code>：</p>
<p><strong>列表：</strong></p>
<pre><code class="javascript">docker images -a</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker rmi $(docker images -a -q)</code></pre>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a><strong>删除容器</strong></h2><h3 id="删除一个或多个特定容器"><a href="#删除一个或多个特定容器" class="headerlink" title="删除一个或多个特定容器"></a><strong>删除一个或多个特定容器</strong></h3><p>使用带有该<code>-a</code>标志的<code>docker ps</code>命令可以找到要删除的容器的名称或ID：</p>
<p><strong>列表：</strong></p>
<pre><code class="javascript">docker ps -a</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker rm ID_or_Name ID_or_Name</code></pre>
<h3 id="退出时取出容器"><a href="#退出时取出容器" class="headerlink" title="退出时取出容器"></a><strong>退出时取出容器</strong></h3><p>如果您知道何时创建容器，一旦完成就不想保留它，您可以运行<code>docker run --rm</code>以在退出时自动删除它。</p>
<p><strong>运行和删除：</strong></p>
<pre><code class="javascript">docker run --rm image_name</code></pre>
<h3 id="删除所有已退出的容器"><a href="#删除所有已退出的容器" class="headerlink" title="删除所有已退出的容器"></a><strong>删除所有已退出的容器</strong></h3><p>您可以使用以下<code>docker ps -a</code>状态定位容器并对其进行过滤：创建，重新启动，运行，暂停或退出。要查看已退出容器的列表，请使用<code>-f</code>标志根据状态进行过滤。当您确认要删除这些容器时，使用<code>-q</code>将ID传递给<code>docker rm</code>命令。</p>
<p><strong>列表：</strong></p>
<pre><code class="javascript">docker ps -a -f status=exited</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker rm $(docker ps -a -f status=exited -q)</code></pre>
<h3 id="使用多个过滤器移除容器"><a href="#使用多个过滤器移除容器" class="headerlink" title="使用多个过滤器移除容器"></a><strong>使用多个过滤器移除容器</strong></h3><p>可以通过使用附加值重复过滤器标志来组合Docker过滤器。这导致满足任一条件的容器列表。例如，如果要删除标记为<strong>Created的</strong>所有容器（运行具有无效命令的容器时可能导致的状态）或<strong>Exited</strong>，则可以使用两个过滤器：</p>
<p><strong>列表：</strong></p>
<pre><code class="javascript">docker ps -a -f status=exited -f status=created</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker rm $(docker ps -a -f status=exited -f status=created -q)</code></pre>
<h3 id="根据图案移除容器"><a href="#根据图案移除容器" class="headerlink" title="根据图案移除容器"></a><strong>根据图案移除容器</strong></h3><p>您可以使用<code>docker ps</code>和grep的组合找到与模式匹配的所有容器。当您对要删除的列表感到满意时，可以使用<code>awk</code>和<code>xargs</code>提供ID给 <code>docker rmi</code>。请注意，这些实用程序不是由Docker提供的，并不一定适用于所有系统：</p>
<p><strong>列表：</strong></p>
<pre><code class="javascript">docker ps -a |  grep &quot;pattern”</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker ps -a | grep &quot;pattern&quot; | awk &#39;&#123;print $3&#125;&#39; | xargs docker rmi</code></pre>
<h3 id="停止并移除所有容器"><a href="#停止并移除所有容器" class="headerlink" title="停止并移除所有容器"></a><strong>停止并移除所有容器</strong></h3><p>您可以查看系统上的容器<code>docker ps</code>。添加<code>-a</code>标志将显示所有容器。当您确定要删除它们时，可以添加<code>-q</code>标志以向 <code>docker stop</code>和<code>docker rm</code>命令提供ID：<br><strong>列表：</strong></p>
<pre><code class="javascript">docker ps -a</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)</code></pre>
<h2 id="删除卷"><a href="#删除卷" class="headerlink" title="删除卷"></a><strong>删除卷</strong></h2><h3 id="删除一个或多个特定卷-Docker-1-9及更高版本"><a href="#删除一个或多个特定卷-Docker-1-9及更高版本" class="headerlink" title="删除一个或多个特定卷 - Docker 1.9及更高版本"></a><strong>删除一个或多个特定卷 - Docker 1.9及更高版本</strong></h3><p>使用此<code>docker volume ls</code>命令可找到要删除的卷名称。然后，您可以使用以下<code>docker volume rm</code>命令删除一个或多个卷：<br><strong>列表：</strong></p>
<pre><code class="javascript">docker volume ls</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker volume rm volume_name volume_name</code></pre>
<h3 id="删除悬空卷-Docker-1-9及更高版本"><a href="#删除悬空卷-Docker-1-9及更高版本" class="headerlink" title="删除悬空卷 - Docker 1.9及更高版本"></a><strong>删除悬空卷 - Docker 1.9及更高版本</strong></h3><p>由于卷的位置与容器无关，因此在移除容器时，不会同时自动删除卷。当卷存在且不再连接到任何容器时，它称为悬空卷。要找到它们以确认您要删除它们，可以使用带过滤器的命令<code>docker volume ls</code>将结果限制为悬空卷。当您对列表感到满意时，可以用<code>docker volume prune</code>将它们全部删除：</p>
<p><strong>列表：</strong></p>
<pre><code class="javascript">docker volume ls -f dangling=true</code></pre>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker volume prune</code></pre>
<h3 id="删除容器及其容量"><a href="#删除容器及其容量" class="headerlink" title="删除容器及其容量"></a><strong>删除容器及其容量</strong></h3><p>如果您创建了一个未命名的卷，则可以将其与具有该<code>-v</code>标志的容器同时删除。请注意，这仅适用于<em>未命名的</em>卷。成功删除容器后，将显示其ID。请注意，没有引用卷的删除。如果未命名，则会以静默方式从系统中删除。如果它被命名，它会默默地保持存在。</p>
<p><strong>去掉：</strong></p>
<pre><code class="javascript">docker rm -v container_name</code></pre>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><p>本教程介绍了一些用于使用Docker删除图像，容器和卷的常用命令。每个都可以使用许多其他组合和标志。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下的find文件查找命令与grep文件内容查找命令</title>
    <url>/2020/04/05/%E5%BC%80%E5%8F%91/find_grep/</url>
    <content><![CDATA[<h1 id="linux下的find文件查找命令与grep文件内容查找命令"><a href="#linux下的find文件查找命令与grep文件内容查找命令" class="headerlink" title="linux下的find文件查找命令与grep文件内容查找命令"></a>linux下的find文件查找命令与grep文件内容查找命令</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h2><pre><code>
(1)find命令是根据**文件的属性**进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。
(2)grep是根据**文件的内容进行**查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。</code></pre><span id="more"></span>
<h2 id="一-find命令"><a href="#一-find命令" class="headerlink" title="一.find命令"></a><strong>一.find命令</strong></h2><pre><code>**基本格式：**find path expression</code></pre><h3 id="1-按照文件名查找"><a href="#1-按照文件名查找" class="headerlink" title="1.按照文件名查找"></a><strong>1.按照文件名查找</strong></h3><pre><code>(1)find / -name httpd.conf　　#在根目录下查找文件httpd.conf，表示在整个硬盘查找
(2)find /etc -name httpd.conf　　#在/etc目录下文件httpd.conf
(3)find /etc -name &#39;*srm*&#39;　　#使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件
(4)find . -name &#39;srm*&#39; 　　#表示当前目录下查找文件名开头是字符串‘srm’的文件</code></pre><h3 id="2-按照文件特征查找"><a href="#2-按照文件特征查找" class="headerlink" title="2.按照文件特征查找 　　　"></a><strong>2.按照文件特征查找</strong> 　　　</h3><pre><code>(1)find / -amin -10 　　# 查找在系统中最后10分钟访问的文件(access time)
(2)find / -atime -2　　 # 查找在系统中最后48小时访问的文件
(3)find / -empty 　　# 查找在系统中为空的文件或者文件夹
(4)find / -group cat 　　# 查找在系统中属于 group为cat的文件
(5)find / -mmin -5 　　# 查找在系统中最后5分钟里修改过的文件(modify time)
(6)find / -mtime -1 　　#查找在系统中最后24小时里修改过的文件
(7)find / -user fred 　　#查找在系统中属于fred这个用户的文件
(8)find / -size +10000c　　#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)
(9)find / -size -1000k 　　#查找出小于1000KB的文件</code></pre><h3 id="3-使用混合查找方式查找文件"><a href="#3-使用混合查找方式查找文件" class="headerlink" title="3.使用混合查找方式查找文件"></a><strong>3.使用混合查找方式查找文件</strong></h3><pre><code>**参数有： ！，-and(-a)，-or(-o)。**
(1)find /tmp -size +10000c -and -mtime +2 　　#在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件
(2)find / -user fred -or -user george 　　#在/目录下查找用户是fred或者george的文件文件
(3)find /tmp ! -user panda　　#在/tmp目录中查找所有不属于panda用户的文件</code></pre><h2 id="二、grep命令"><a href="#二、grep命令" class="headerlink" title="二、grep命令"></a><strong>二、grep命令</strong></h2><pre><code>***\*基本格式：\**find  expression**</code></pre><h3 id="1-主要参数"><a href="#1-主要参数" class="headerlink" title="1.主要参数"></a><strong>1.主要参数</strong></h3><pre><code>[options]主要参数：**
－c：只输出匹配行的计数。
－i：不区分大小写
－h：查询多文件时不显示文件名。
－l：查询多文件时只输出包含匹配字符的文件名。
－n：显示匹配行及行号。
－s：不显示不存在或无匹配文本的错误信息。
－v：显示不包含匹配文本的所有行。

**pattern正则表达式主要参数：**
\： 忽略正则表达式中特殊字符的原有含义。
^：匹配正则表达式的开始行。
$: 匹配正则表达式的结束行。
\&lt;：从匹配正则表达 式的行开始。
\&gt;：到匹配正则表达式的行结束。
[ ]：单个字符，如[A]即A符合要求 。
[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
.：所有的单个字符。
* ：有字符，长度可以为0。</code></pre><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例　"></a><strong>2.实例</strong>　</h3><pre><code>(1)grep &#39;test&#39; d*　　#显示所有以d开头的文件中包含 test的行
(2)grep ‘test’ aa bb cc 　　 #显示在aa，bb，cc文件中包含test的行
(3)grep ‘[a-z]\&#123;5\&#125;’ aa 　　#显示所有包含每行字符串至少有5个连续小写字符的字符串的行
(4)grep magic /usr/src　　#显示/usr/src目录下的**文件(不含子目录)**包含magic的行
(5)grep -r magic /usr/src　　#显示/usr/src目录下的**文件(包含子目录)**包含magic的行
(6)grep -w pattern files  #只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)，
(7)grep -r &quot;查询内容&quot;  文件目录 #文件名+内容
(8)grep &#39;2020-02-27 17:5[6,9]&#39; xinyar-erp-auto.log ##根据时间查找日志
(9)grep -E &#39;2020-02-27 14:5[5-9]|2020-02-28 15:0[0-5]&#39; xinyar-erp-auto.log #查询指定时间段内的日志
(10)grep -C 10 &#39;aaaa&#39; nohup.out #查找关键字
(11)grep -r -l &quot;查询内容&quot;  文件目录 #只显示包含内容的文件名
(12)find 文件目录  -type f |xargs grep &quot;查询内容&quot;;  文件名+内容

(13)grep -l &quot;innercontent&quot; --include=&quot;*filepattern*&quot; ./* | xargs cp -t destdir # grep文件名，内容，然后复制到文件夹中
搜索源代码中的内容时, 为避免搜索到不相关的文件, 如.o文件中的内容, 可能希望grep能只处理特定格式的文件.
grep -rn --include=&#39;*.c&#39; --include=&#39;*.h&#39; re .
可以指定多次, 如果真是上面的这种情况,  其实可以用
grep -rn --include=&#39;*.[ch]&#39; re .
但是, 如果源文件中含有C++源代码, 上面的方法就不凑效了, 因为[]中只能放一个字符.
grep -rn --include=&#39;*.&#123;cpp,h&#125;&#39; 也是不行的.
此时需要不加引号的展开(由bash执行grep之前就已经完成, 可以通过set -x观察)
grep -rn --include=*.&#123;cpp,h&#125; re .
bash中对&#123;A,B&#125;这种形式的展开, 会忽略是否在当前目录下存在相应的文件。

示例：
grep -r &quot;version.app.xinyartech.com&quot;  /data/nginx/conf.d
grep -r -l &quot;version.app.xinyartech.com&quot;  /data/nginx/conf.d
find /data/nginx/conf.d  -type f |xargs grep &quot;version.app.xinyartech.com&quot;;

真实示例：
grep -r -l ea5dabc.*f76b .
grep -r -l 3367.*762 ./ | xargs cp -t ./rwglxt-`date +%y%m%d`
grep -r -l 3367.*762 ./ | xargs zip -q -r ./rwglxt-`date +%Y%m%d%H%M%S`.zip
--
cd ***/weblogic/*/domain/xxxdoamin
cd ./logs/
cd ./servers/
grep -r -l ea5dabc.*f76b ./ | xargs zip -q -r ./rwglxt-`date +%Y%m%d%H%M%S`.zip

find ./ -type f -name &quot;*.log&quot; | xargs grep &quot;ERROR&quot;

find ./ -type f -name &quot;*.log&quot; | grep -r -l ea5dabc.*f76b ./ | xargs zip -q -r ./rwglxt-`date +%Y%m%d%H%M%S`.zip


find ./Downloads/ -type f -name &quot;*.log&quot; | xargs grep -l 3367.*762

find ./ -type f -name &quot;*.log&quot; | xargs grep -l 3367.*762 | xargs zip -q -r ./rwglxt-`date +%Y%m%d%H%M%S`.zip

find ./ -type f -name &quot;*.log&quot; | xargs grep -l ea5dabc.*f76b | xargs zip -q -r ./rwglxt-`date +%Y%m%d%H%M%S`.zip
</code></pre><p>grep 命令系列：grep 中的正则表达式<br>作者： Vivek Gite 译者： LCTT runningwater</p>
<p>| 2016-01-27 11:30   评论: 4 收藏: 9    </p>
<p>在 Linux 、类 Unix 系统中我该如何使用 Grep 命令的正则表达式呢？</p>
<p>Linux 附带有 GNU grep 命令工具，它支持扩展正则表达式，而且 GNU grep 在所有的 Linux 系统中都是默认有的。Grep 命令被用于搜索定位存储在您服务器或工作站上的任何信息。</p>
<p>正则表达式</p>
<p>正则表达式就是用于匹配每行输入的一种模式，模式是指一串字符序列。下面是范例：</p>
<pre><code>^w1
w1|w2
[^ ]</code></pre><p>grep 正则表达式示例</p>
<p>在 /etc/passswd 目录中搜索 ‘vivek’</p>
<pre><code>grep vivek /etc/passwd</code></pre><p>输出例子:</p>
<pre><code>vivek:x:1000:1000:Vivek Gite,,,:/home/vivek:/bin/bash
vivekgite:x:1001:1001::/home/vivekgite:/bin/sh
gitevivek:x:1002:1002::/home/gitevivek:/bin/sh</code></pre><p>搜索大小写任意的 vivek(即不区分大小写的搜索)</p>
<pre><code>grep -i -w vivek /etc/passwd</code></pre><p>搜索大小写任意的 vivek 或 raj</p>
<pre><code>grep -E -i -w &#39;vivek|raj&#39; /etc/passwd</code></pre><p>上面最后的例子显示的，就是一个扩展的正则表达式的模式。<br>锚点</p>
<p>你可以分别使用 ^ 和 $ 符号来正则匹配输入行的开始或结尾。下面的例子搜索显示仅仅以 vivek 开始的输入行：</p>
<pre><code>grep ^vivek /etc/passwd</code></pre><p>输出例子:</p>
<pre><code>vivek:x:1000:1000:Vivek Gite,,,:/home/vivek:/bin/bash
vivekgite:x:1001:1001::/home/vivekgite:/bin/sh</code></pre><p>你可以仅仅只搜索出以单词 vivek 开始的行，即不显示 vivekgit、vivekg 等（LCTT 译注：即该单词后面是空格、符号等英文的单词分隔符。）</p>
<pre><code>grep -w ^vivek /etc/passwd</code></pre><p>找出以单词 word 结尾的行：</p>
<pre><code>grep &#39;foo$&#39; 文件名</code></pre><p>匹配仅仅只包含 foo 的行：</p>
<pre><code>grep &#39;^foo$&#39; 文件名</code></pre><p>如下所示的例子可以搜索空行：</p>
<pre><code>grep &#39;^$&#39; 文件名</code></pre><p>字符类</p>
<p>匹配 Vivek 或 vivek：</p>
<pre><code>grep &#39;[vV]ivek&#39; 文件名</code></pre><p>或者</p>
<pre><code>grep &#39;[vV][iI][Vv][Ee][kK]&#39; 文件名</code></pre><p>也可以匹配数字 (即匹配 vivek1 或 Vivek2 等等):</p>
<pre><code>grep -w &#39;[vV]ivek[0-9]&#39; 文件名</code></pre><p>可以匹配两个数字字符(即 foo11、foo12 等):</p>
<pre><code>grep &#39;foo[0-9][0-9]&#39; 文件名</code></pre><p>不仅仅局限于数字，也能匹配至少一个字母的:</p>
<pre><code>grep &#39;[A-Za-z]&#39; 文件名</code></pre><p>显示含有 “w” 或 “n” 字符的所有行：</p>
<pre><code>grep [wn] 文件名</code></pre><p>放在括号内的表达式，即包在 “[:” 和 “:]” 之间的字符类的名字，它表示的是属于此类的所有字符列表。标准的字符类名称如下：</p>
<pre><code>[:alnum:] - 字母数字字符
[:alpha:] - 字母字符
[:blank:] - 空字符: 空格键符 和 制表符
[:digit:] - 数字: &#39;0 1 2 3 4 5 6 7 8 9&#39;
[:lower:] - 小写字母: &#39;a b c d e f g h i j k l m n o p q r s t u v w x y z&#39;
[:space:] - 空格字符: 制表符、换行符、垂直制表符、换页符、回车符和空格键符
[:upper:] - 大写字母: &#39;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&#39;</code></pre><p>在这个例子所示的是匹配所有大写字母:</p>
<pre><code>grep &#39;[:upper:]&#39; 文件名</code></pre><p>通配符</p>
<p>你可以使用 “.” 来匹配单个字符。例子中匹配以 “b” 开头以 “t” 结尾的3个字符的单词：</p>
<pre><code>grep &#39;\&lt;b.t\&gt;&#39; 文件名</code></pre><p>在这儿,</p>
<pre><code>\&lt; 匹配单词前面的空字符串
\&gt; 匹配单词后面的空字符串</code></pre><p>打印出只有两个字符的所有行:</p>
<pre><code>grep &#39;^..$&#39; 文件名</code></pre><p>显示以一个点和一个数字开头的行：</p>
<pre><code>grep &#39;^\.[0-9]&#39; 文件名</code></pre><p>点字符转义</p>
<p>下面要匹配到 IP 地址为 192.168.1.254 的正则式是不正确的：（LCTT 译注：可以匹配到该 IP 地址，但是也有可能匹配到间隔符号不是点的类似格式）</p>
<pre><code>grep &#39;192.168.1.254&#39; /etc/hosts</code></pre><p>三个点字符都需要转义：</p>
<pre><code>grep &#39;192\.168\.1\.254&#39; /etc/hosts</code></pre><p>下面的例子只能匹配出 IP 地址：（LCTT 译注：实际上由于 IP 地址中数字的取值范围，该正则表达式并不精确）</p>
<pre><code>egrep &#39;[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;&#39; 文件名</code></pre><p>怎么样搜索以“-” 符号开头的匹配模式？</p>
<p>要使用 -e 选项来搜索匹配 ‘–test–’ 字符串，如果不使用 -e 选项，grep 命令会试图把 ‘–test–’ 当作自己的选项参数来解析：</p>
<pre><code>grep -e &#39;--test--&#39; 文件名</code></pre><p>怎么使用 grep 的“或”匹配?</p>
<p>使用如下的语法：</p>
<pre><code>grep -E &#39;word1|word2&#39; 文件名
或
egrep &#39;word1|word2&#39; 文件名</code></pre><p>或者是</p>
<pre><code>grep &#39;word1\|word2&#39; 文件名</code></pre><p>怎么使用 grep 的“和”匹配?</p>
<p>使用下面的语法来显示既包含 ‘word1’ 又包含 ‘word2’ 的所有行</p>
<pre><code>grep &#39;word1&#39; 文件名 | grep &#39;word2&#39;</code></pre><p>怎么样使用序列检测?</p>
<p>使用如下的语法，您可以检测一个字符在序列中重复出现次数：</p>
<pre><code>&#123;N&#125;
&#123;N,&#125;
&#123;min,max&#125;</code></pre><p>要匹配字符 “v” 出现两次：</p>
<pre><code>egrep &quot;v&#123;2&#125;&quot; 文件名</code></pre><p>下面的命令能匹配到 “col” 和 “cool” ：</p>
<pre><code>egrep &#39;co&#123;1,2&#125;l&#39; 文件名</code></pre><p>下面的命令将会匹配出至少有三个 ‘c’ 字符的所有行。</p>
<pre><code>egrep &#39;c&#123;3,&#125;&#39; 文件名</code></pre><p>下面的例子会匹配 91-1234567890（即二个数字-十个数字） 这种格式的手机号。</p>
<pre><code>grep &quot;[[:digit:]]\&#123;2\&#125;[ -]\?[[:digit:]]\&#123;10\&#125;&quot; 文件名</code></pre><p>怎么样使 grep 命令高亮显示？</p>
<p>使用如下的语法：</p>
<pre><code>grep --color 正则表达式 文件名</code></pre><p>怎么样仅仅只显示匹配出的字符，而不是匹配出的行？</p>
<p>使用如下语法：</p>
<pre><code>grep -o 正则表达式 文件名</code></pre><p>正则表达式限定符<br>限定符    描述<br>.     匹配任意的一个字符。<br>?     匹配前面的子表达式，最多一次。</p>
<ul>
<li>匹配前面的子表达式零次或多次。</li>
</ul>
<ul>
<li>匹配前面的子表达式一次或多次。<br>{N}     匹配前面的子表达式 N 次。<br>{N,}     匹配前面的子表达式 N 次到多次。<br>{N,M}     匹配前面的子表达式 N 到 M 次，至少 N 次至多 M 次。</li>
</ul>
<ul>
<li>只要不是在序列开始、结尾或者序列的结束点上，表示序列范围。<br>^     匹配一行开始的空字符串；也表示字符不在要匹配的列表中。<br>$     匹配一行末尾的空字符串。<br>\b     匹配一个单词前后的空字符串。<br>\B     匹配一个单词中间的空字符串。<br>&lt;     匹配单词前面的空字符串。<br>&gt;     匹配单词后面的空字符串。<br>grep 和 egrep</li>
</ul>
<p>egrep 等同于 grep -E 。它会以扩展的正则表达式的模式来解释模式。下面来自 grep 的帮助页：</p>
<pre><code>基本的正则表达式元字符 ?、+、 &#123;、 |、 ( 和 ) 已经失去了它们原来的意义，要使用的话用反斜线的版本 \?、\+、\&#123;、\|、\( 和 \) 来代替。 传统的 egrep 并不支持 &#123; 元字符，一些 egrep 的实现是以 \&#123; 替代的，所以一个可移植的脚本应该避免在 grep -E 使用 &#123; 符号，要匹配字面的 &#123; 应该使用 [&#125;]。

GNU grep -E 试图支持传统的用法，如果 &#123; 出在在无效的间隔规范字符串这前，它就会假定 &#123; 不是特殊字符。

例如，grep -E &#39;&#123;1&#39; 命令搜索包含 &#123;1 两个字符的串，而不会报出正则表达式语法错误。

POSIX.2 标准允许这种操作的扩展，但在可移植脚本文件里应该避免这样使用。</code></pre><p>参考:</p>
<pre><code>grep 和 regex 帮助手册页(7)
grep 的</code></pre><p>grep 命令系列：grep 中的正则表达式<br>作者： Vivek Gite 译者： LCTT runningwater</p>
<p>| 2016-01-27 11:30   评论: 4 收藏: 9    </p>
<p>在 Linux 、类 Unix 系统中我该如何使用 Grep 命令的正则表达式呢？</p>
<p>Linux 附带有 GNU grep 命令工具，它支持扩展正则表达式，而且 GNU grep 在所有的 Linux 系统中都是默认有的。Grep 命令被用于搜索定位存储在您服务器或工作站上的任何信息。</p>
<p>正则表达式</p>
<p>正则表达式就是用于匹配每行输入的一种模式，模式是指一串字符序列。下面是范例：</p>
<pre><code>^w1
w1|w2
[^ ]</code></pre><p>grep 正则表达式示例</p>
<p>在 /etc/passswd 目录中搜索 ‘vivek’</p>
<pre><code>grep vivek /etc/passwd</code></pre><p>输出例子:</p>
<pre><code>vivek:x:1000:1000:Vivek Gite,,,:/home/vivek:/bin/bash
vivekgite:x:1001:1001::/home/vivekgite:/bin/sh
gitevivek:x:1002:1002::/home/gitevivek:/bin/sh</code></pre><p>搜索大小写任意的 vivek(即不区分大小写的搜索)</p>
<pre><code>grep -i -w vivek /etc/passwd</code></pre><p>搜索大小写任意的 vivek 或 raj</p>
<pre><code>grep -E -i -w &#39;vivek|raj&#39; /etc/passwd</code></pre><p>上面最后的例子显示的，就是一个扩展的正则表达式的模式。<br>锚点</p>
<p>你可以分别使用 ^ 和 $ 符号来正则匹配输入行的开始或结尾。下面的例子搜索显示仅仅以 vivek 开始的输入行：</p>
<pre><code>grep ^vivek /etc/passwd</code></pre><p>输出例子:</p>
<pre><code>vivek:x:1000:1000:Vivek Gite,,,:/home/vivek:/bin/bash
vivekgite:x:1001:1001::/home/vivekgite:/bin/sh</code></pre><p>你可以仅仅只搜索出以单词 vivek 开始的行，即不显示 vivekgit、vivekg 等（LCTT 译注：即该单词后面是空格、符号等英文的单词分隔符。）</p>
<pre><code>grep -w ^vivek /etc/passwd</code></pre><p>找出以单词 word 结尾的行：</p>
<pre><code>grep &#39;foo$&#39; 文件名</code></pre><p>匹配仅仅只包含 foo 的行：</p>
<pre><code>grep &#39;^foo$&#39; 文件名</code></pre><p>如下所示的例子可以搜索空行：</p>
<pre><code>grep &#39;^$&#39; 文件名</code></pre><p>字符类</p>
<p>匹配 Vivek 或 vivek：</p>
<pre><code>grep &#39;[vV]ivek&#39; 文件名</code></pre><p>或者</p>
<pre><code>grep &#39;[vV][iI][Vv][Ee][kK]&#39; 文件名</code></pre><p>也可以匹配数字 (即匹配 vivek1 或 Vivek2 等等):</p>
<pre><code>grep -w &#39;[vV]ivek[0-9]&#39; 文件名</code></pre><p>可以匹配两个数字字符(即 foo11、foo12 等):</p>
<pre><code>grep &#39;foo[0-9][0-9]&#39; 文件名</code></pre><p>不仅仅局限于数字，也能匹配至少一个字母的:</p>
<pre><code>grep &#39;[A-Za-z]&#39; 文件名</code></pre><p>显示含有 “w” 或 “n” 字符的所有行：</p>
<pre><code>grep [wn] 文件名</code></pre><p>放在括号内的表达式，即包在 “[:” 和 “:]” 之间的字符类的名字，它表示的是属于此类的所有字符列表。标准的字符类名称如下：</p>
<pre><code>[:alnum:] - 字母数字字符
[:alpha:] - 字母字符
[:blank:] - 空字符: 空格键符 和 制表符
[:digit:] - 数字: &#39;0 1 2 3 4 5 6 7 8 9&#39;
[:lower:] - 小写字母: &#39;a b c d e f g h i j k l m n o p q r s t u v w x y z&#39;
[:space:] - 空格字符: 制表符、换行符、垂直制表符、换页符、回车符和空格键符
[:upper:] - 大写字母: &#39;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&#39;</code></pre><p>在这个例子所示的是匹配所有大写字母:</p>
<pre><code>grep &#39;[:upper:]&#39; 文件名</code></pre><p>通配符</p>
<p>你可以使用 “.” 来匹配单个字符。例子中匹配以 “b” 开头以 “t” 结尾的3个字符的单词：</p>
<pre><code>grep &#39;\&lt;b.t\&gt;&#39; 文件名</code></pre><p>在这儿,</p>
<pre><code>\&lt; 匹配单词前面的空字符串
\&gt; 匹配单词后面的空字符串</code></pre><p>打印出只有两个字符的所有行:</p>
<pre><code>grep &#39;^..$&#39; 文件名</code></pre><p>显示以一个点和一个数字开头的行：</p>
<pre><code>grep &#39;^\.[0-9]&#39; 文件名</code></pre><p>点字符转义</p>
<p>下面要匹配到 IP 地址为 192.168.1.254 的正则式是不正确的：（LCTT 译注：可以匹配到该 IP 地址，但是也有可能匹配到间隔符号不是点的类似格式）</p>
<pre><code>grep &#39;192.168.1.254&#39; /etc/hosts</code></pre><p>三个点字符都需要转义：</p>
<pre><code>grep &#39;192\.168\.1\.254&#39; /etc/hosts</code></pre><p>下面的例子只能匹配出 IP 地址：（LCTT 译注：实际上由于 IP 地址中数字的取值范围，该正则表达式并不精确）</p>
<pre><code>egrep &#39;[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;\.[[:digit:]]&#123;1,3&#125;&#39; 文件名</code></pre><p>怎么样搜索以“-” 符号开头的匹配模式？</p>
<p>要使用 -e 选项来搜索匹配 ‘–test–’ 字符串，如果不使用 -e 选项，grep 命令会试图把 ‘–test–’ 当作自己的选项参数来解析：</p>
<pre><code>grep -e &#39;--test--&#39; 文件名</code></pre><p>怎么使用 grep 的“或”匹配?</p>
<p>使用如下的语法：</p>
<pre><code>grep -E &#39;word1|word2&#39; 文件名
或
egrep &#39;word1|word2&#39; 文件名</code></pre><p>或者是</p>
<pre><code>grep &#39;word1\|word2&#39; 文件名</code></pre><p>怎么使用 grep 的“和”匹配?</p>
<p>使用下面的语法来显示既包含 ‘word1’ 又包含 ‘word2’ 的所有行</p>
<pre><code>grep &#39;word1&#39; 文件名 | grep &#39;word2&#39;</code></pre><p>怎么样使用序列检测?</p>
<p>使用如下的语法，您可以检测一个字符在序列中重复出现次数：</p>
<pre><code>&#123;N&#125;
&#123;N,&#125;
&#123;min,max&#125;</code></pre><p>要匹配字符 “v” 出现两次：</p>
<pre><code>egrep &quot;v&#123;2&#125;&quot; 文件名</code></pre><p>下面的命令能匹配到 “col” 和 “cool” ：</p>
<pre><code>egrep &#39;co&#123;1,2&#125;l&#39; 文件名</code></pre><p>下面的命令将会匹配出至少有三个 ‘c’ 字符的所有行。</p>
<pre><code>egrep &#39;c&#123;3,&#125;&#39; 文件名</code></pre><p>下面的例子会匹配 91-1234567890（即二个数字-十个数字） 这种格式的手机号。</p>
<pre><code>grep &quot;[[:digit:]]\&#123;2\&#125;[ -]\?[[:digit:]]\&#123;10\&#125;&quot; 文件名</code></pre><p>怎么样使 grep 命令高亮显示？</p>
<p>使用如下的语法：</p>
<pre><code>grep --color 正则表达式 文件名</code></pre><p>怎么样仅仅只显示匹配出的字符，而不是匹配出的行？</p>
<p>使用如下语法：</p>
<pre><code>grep -o 正则表达式 文件名</code></pre><p>正则表达式限定符<br>限定符    描述<br>.     匹配任意的一个字符。<br>?     匹配前面的子表达式，最多一次。</p>
<ul>
<li>匹配前面的子表达式零次或多次。</li>
</ul>
<ul>
<li>匹配前面的子表达式一次或多次。<br>{N}     匹配前面的子表达式 N 次。<br>{N,}     匹配前面的子表达式 N 次到多次。<br>{N,M}     匹配前面的子表达式 N 到 M 次，至少 N 次至多 M 次。</li>
</ul>
<ul>
<li>只要不是在序列开始、结尾或者序列的结束点上，表示序列范围。<br>^     匹配一行开始的空字符串；也表示字符不在要匹配的列表中。<br>$     匹配一行末尾的空字符串。<br>\b     匹配一个单词前后的空字符串。<br>\B     匹配一个单词中间的空字符串。<br>&lt;     匹配单词前面的空字符串。<br>&gt;     匹配单词后面的空字符串。<br>grep 和 egrep</li>
</ul>
<p>egrep 等同于 grep -E 。它会以扩展的正则表达式的模式来解释模式。下面来自 grep 的帮助页：</p>
<pre><code>基本的正则表达式元字符 ?、+、 &#123;、 |、 ( 和 ) 已经失去了它们原来的意义，要使用的话用反斜线的版本 \?、\+、\&#123;、\|、\( 和 \) 来代替。 传统的 egrep 并不支持 &#123; 元字符，一些 egrep 的实现是以 \&#123; 替代的，所以一个可移植的脚本应该避免在 grep -E 使用 &#123; 符号，要匹配字面的 &#123; 应该使用 [&#125;]。

GNU grep -E 试图支持传统的用法，如果 &#123; 出在在无效的间隔规范字符串这前，它就会假定 &#123; 不是特殊字符。

例如，grep -E &#39;&#123;1&#39; 命令搜索包含 &#123;1 两个字符的串，而不会报出正则表达式语法错误。

POSIX.2 标准允许这种操作的扩展，但在可移植脚本文件里应该避免这样使用。</code></pre><p>参考:</p>
<pre><code>grep 和 regex 帮助手册页(7)
grep 的 info 页</code></pre><p>via: <a href="http://www.cyberciti.biz/faq/grep-regular-expressions/">http://www.cyberciti.biz/faq/grep-regular-expressions/</a> info 页</p>
<p>via: <a href="http://www.cyberciti.biz/faq/grep-regular-expressions/">http://www.cyberciti.biz/faq/grep-regular-expressions/</a></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>grep</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>grep</tag>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title>openstack 部署方式</title>
    <url>/2020/04/18/%E7%8E%AF%E5%A2%83/openstack-%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>对于每一个刚接触到OpenStack的新人而言，安装无疑是最困难的，同时这也客观上提高了大家学习OpenStack云计算的技术门槛。想一想，自己3年前网上偶然接触到OpenStack时，一头茫然，手动搭建一个多节点环境时居然用了3个星期。</p>
<p>时至今日，真是感触颇多，从某种角度而言，也很庆幸当时自己并未因困难而放弃OpenStack，否则，应该是去做其他领域了吧！</p>
<p>言归正传，咱们就来数落数落部署OpenStack都有哪些方式吧。这里，我们根据使用者群体的不同类型来进行分类和归纳：</p>
<p>个人使用方面</p>
<p>DevStack</p>
<p>无疑，在可预见的未来时间内，DevStack仍将是众多开发者们的首选安装方式或工具。该方式主要是通过配置参数，执行shell脚本来安装一个OpenStack的开发环境。</p>
<p>Github: <a href="https://github.com/openstack-dev/devstack">https://github.com/openstack-dev/devstack</a></p>
<p>Wiki: <a href="https://wiki.openstack.org/wiki/DevStack">https://wiki.openstack.org/wiki/DevStack</a></p>
<p>Rdo</p>
<p>Rdo是由Red Hat开源的一款部署OpenStack的工具，同DevStack一样，支持单节点和多节点部署。但Rdo只支持CentOS系列的操作系统。需要注意的是，该项目并不属于OpenStack官方社区项目。</p>
<p>Docs：<a href="https://www.rdoproject.org/install/quickstart">https://www.rdoproject.org/install/quickstart</a></p>
<p>手动部署</p>
<p>手动部署all-in-one、multi-node、multi-HA-node环境。</p>
<p>其他</p>
<p>企业、团体方面</p>
<p>1.Puppet</p>
<p>Puppet由Ruby语言编写。应当说，Puppet是进入OpenStack自动化部署中的早期一批项目，历史还算悠久。目前，它的活跃开发群体们是Red hat、 Mirantis、UnitedStack等。</p>
<p>2.Red</p>
<p>hat自从收购Ansible之后，如今仍然保持强势劲头在Puppet</p>
<p>OpenStack项目中的Commit数量和质量，其技术实力不容小觑；Mirantis出品的Fuel部署工具中，大量的模块代码便使用的是</p>
<p>Puppet。就国内而言，UnitedStack是Puppet社区贡献和使用的最大用户。</p>
<p>Github：</p>
<p><a href="https://github.com/openstack/puppet-keystone">https://github.com/openstack/puppet-keystone</a></p>
<p>Governance：</p>
<p>Wiki：</p>
<p><a href="https://wiki.openstack.org/wiki/Puppet">https://wiki.openstack.org/wiki/Puppet</a></p>
<p>3.Ansible</p>
<p>Ansible</p>
<p>是新近出现的自动化运维工具，已被Red</p>
<p>Hat收购。基于Python开发，集合了众多运维工具（puppet、cfengine、chef、saltstack等）的优点，实现了批量系统配</p>
<p>置、批量程序部署、批量运行命令等功能，它一方面总结了Puppet的设计上的得失，另一方面也改进了很多设计。比如是基于SSH方式工作，故而不需要在被控端安装客户端。使得在和OpenStack结合上没有历史包袱，更加能够轻装上阵，未来发展潜力不容小觑号称是“你一直寻找的下一代Iaas”的</p>
<p>Zstack，使用到的部署工具也是基于Ansible。</p>
<p>Openstack-ansible项目，最早是由老牌Rackspace公司在Launchpad官网上注册。</p>
<p>在最新的Ansible OpenStack项目社区Commit贡献中，Rackspace也可谓是遥遥领先，而紧随其后的是Red Hat、国内九州云等公司。</p>
<p>Github：<a href="https://github.com/openstack/openstack-ansible">https://github.com/openstack/openstack-ansible</a></p>
<ol start="4">
<li>SaltStack</li>
</ol>
<p>SaltStack</p>
<p>也是一款开源的自动化部署工具，基于Python开发，实现了批量系统配置、批量程序部署、批量运行命令等功能，和Ansible也是挺相近的。不同之一</p>
<p>是，由于SaltStack的master和minion认证机制和工作方式，需要在被控端安装minion客户端，在加之其他原因，自然和</p>
<p>Ansible相比，其优缺点便很明显了。</p>
<p>需要注意的是，使用Saltstack部署OpenStack，并不属于OpenStack社区项目。目前，主要还是处于用户自研自用的阶段。据笔者所知，目前国内的携程应该是使用Saltstack部署OpenStack规模最大的用户。</p>
<p>Saltstack部署OpenStack示例：<a href="https://github.com/luckpenguin/saltstack_openstack">https://github.com/luckpenguin/saltstack_openstack</a></p>
<p>Saltstack部署OpenStack模块：</p>
<p>5.TripleO</p>
<p>Tripleo 项目最早由HP于2013.4在launchpad上注册BP。用于完成OpenStack的安装与部署。TripleO全称“OpenStack On OpenStack”，</p>
<p>意思即为“云上云”，可以简单理解为利用OpenStack来部署OpenStack，即首先基于V2P(和P2V相反，也就是指</p>
<p>把虚拟机的镜像迁移到物理机上)的理念事先准备好一些OpenStack节点（计算、存储、控制节点）的镜像，然后利用已有openstack环境的裸机</p>
<p>服务Ironic项目去部署裸机，软件安装部分的diskimage-builder，最后通过Heat项目和镜像内的DevOps工具(Puppet Or Chef)再在裸机上配置运行openstack。</p>
<p>和其他部署工具不同的是，TripleO利用OpenStack本来的基础设施来部署OpenStack，基于Nova、 Neutron、Ironic和Heat，来自动化部署和伸缩OpenStack集群。</p>
<p>应</p>
<p>当确切的说，TripleO项目属于当前OpenStack社区主推的“Big Tent”开发模式下的big tent project（OpenStack下的项目分为三种，core project: nova/neutron等核心项目，big tent project: 非核心项目，但也被OpenStack 基金会接受；第三种就是其它项目，只是放在OpenStack下，但是社区还没有接受）。</p>
<p>在该项目的社区Commit贡献上，Red hat可谓是遥遥领先，而紧随其后的是IBM等公司。</p>
<p>Wiki：<a href="https://wiki.openstack.org/wiki/TripleO">https://wiki.openstack.org/wiki/TripleO</a></p>
<p>6.Kolla</p>
<p>在国内一些互联网资料上，常看到关于kolla是TripleO项目的一部分这样的描述，其实是不准确的。真实的是，Kolla项目起源于Tripleo项</p>
<p>目，时至今日，与它没有任何关系（虽然它们的目标都是做自动化部署，但走的道路却不同）。比之于Tripleo和其他部署工具，Kolla走的是</p>
<p>docker容器部署路线。</p>
<p>kolla项目起源于TripleO项目，聚焦于使用docker容器部署OpenStack服务。该项目由</p>
<p>Cisco于2014年9月提出，是OpenStack的孵化项目。当前Kolla项目在Kollaglue</p>
<p>repo提供了以下服务的docker镜像。 # docker search kollaglue</p>
<p>Kolla的优势和使用场景，体现在如下几个方面：</p>
<p>原子性的升级或者回退OpenStack部署；</p>
<p>基于组件升级OpenStack；</p>
<p>基于组件回退OpenStack；</p>
<p>这里，我们予以拆分来理解：</p>
<p>Kolla的最终目标是为OpenStack的每一个服务都创建一个对应的Docker Image，通过Docker</p>
<p>Image将升级的粒度减小到Service级别，从而使升级时，对OpenStack影响能达到最小，并且一旦升级失败，也很容易回滚。升级只需要三</p>
<p>步：Pull新版本的容器镜像，停止老版本的容器服务，然后启动新版本容器。回滚也不需要重新安装包了，直接启动老版本容器服务就行，非常方便。</p>
<p>Kolla是通过Docker Compose来部署OpenStack集群的，现在主要是针对裸机部署的，所以在部署Docker Container时，默认的网络配置都是Host模式。</p>
<p>首先，只需要通过一个命令就可以把管理节点部署完成，这个命令是调用Docker Compose来部署OpenStack的所有服务，然后我们可以在每一个计算节点上通过Docker Compose安装计算节点需要的服务，就能部署一个OpenStack集群。因为Kolla的Docker</p>
<p>Image粒度很小，它针对每个OpenStack服务都有特定的Image，所以我们也可以通过Docker</p>
<p>Run来操作某个具体的OpenStack服务。</p>
<p>7.Fuel</p>
<p>Fuel 是针对OpenStack生产环境目标</p>
<p>（非开源）设计的一个端到端”一键部署“的工具，大量采用了Python、Ruby和JavaScript等语言。其功能含盖自动的PXE方式的操作系统</p>
<p>安装，DHCP服务，Orchestration服务 和puppet 配置管理相关服务等，此外还有OpenStack关键业务健康检查和log</p>
<p>实时查看等非常好用的服务。</p>
<p>Fuel，这款让很多人即爱且痛的工具，在国内外都很盛名。爱的原因是，它确实很棒；痛的原因是，要想彻底掌握</p>
<p>它，可不是一件容易事（各个模块集成度高、使用技术复杂）。既然提到Fuel，自然不能不提它的父母——Mirantis。Mirantis是一家技术实</p>
<p>力非常雄厚的OpenStack服务集成商，他是社区贡献排名前5名中唯一一个靠OpenStack软件和服务盈利的公司。同时，Fuel的版本节奏也很</p>
<p>快，平均每半年就能提供一个相对稳定的社区版。</p>
<p>从和笔者接触到的一些情况来看，国内研究、使用Fuel的个人、群体还是为数不少的。不少国内OpenStack初创公司的安装包就是基于Fuel去修改的。</p>
<hr>
<p>DevStack<br>手动部署all-in-one、multi-node、multi-HA-node环境。</p>
<p>Ansible<br>TripleO<br>Kolla-docker<br>Fuel<br><a href="https://www.bookstack.cn/read/deployopenstackwithpuppet/deployment_tool-packstack.md">https://www.bookstack.cn/read/deployopenstackwithpuppet/deployment_tool-packstack.md</a></p>
<h2 id="Devstack-安装配置"><a href="#Devstack-安装配置" class="headerlink" title="Devstack 安装配置"></a>Devstack 安装配置</h2><p>创建stack用户<br>为了系统的安全，DevStack最好不要在root用户下直接运行，因此需要创建一个专门的用户stack，该用户需要有免密码sudo权限，配置如下:</p>
<pre><code>su root
adduser stack
echo &quot;stack ALL=(ALL) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers # 建议使用visudo
su stack</code></pre><p>如果已经下载了DevStack代码，DevStack也提供了一个专门的脚本创建stack用户，该脚本位于devstack/tools/create-stack-user.sh，直接运行该脚本即可。<br>最后请务必检查当前工作用户为stack，并且能够不输入密码执行sudo命令。</p>
<ol>
<li>使用国内的镜像源<br>对于Ubuntu系统就是修改APT源，比如阿里云镜像源，只需要修改/etc/apt/source.list配置文件即可，替换为需要使用的镜像源。如：</li>
</ol>
<p>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-security main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-updates main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-proposed main restricted universe multiverse<br>deb <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-backports main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-security main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-updates main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-proposed main restricted universe multiverse<br>deb-src <a href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-backports main restricted universe multiverse<br>2. 使用国内的pip源<br>只需要在当前家目录.pip目录创建pip.conf配置文件，以使用阿里云为例，配置文件内容如下：</p>
<p>cat ~/.pip/pip.conf<br>[global]<br>index-url = <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>[install]<br>trusted-host=mirrors.aliyun.com<br>3.修改OpenStack源码地址<br>DevStack默认会从git.openstack.org下拉取代码，国内访问速度很慢，建议替换为github地址或者国内的trystack仓库，在[[local|localrc]]配置下增加以下配置项：</p>
<p>GIT_BASE=<a href="http://git.trystack.cn">http://git.trystack.cn</a><br>如果你本地已经有最新的OpenStack源码了，也可以指定你本地的源码路径，比如使用本地的Nova源代码并且使用new_feature分支:</p>
<p>[[local|localrc]]<br>NOVA_REPO=/home/int32bit/nova<br>NOVA_BRANCH=new_feature<br>需要注意的是，国内源存在同步滞后，可能包不兼容或者下载某些包失败问题，出现这种情况时只需要重新替换原来的镜像源，然后重新运行./stack.sh即可。</p>
<p><a href="https://docs.openstack.org/devstack/latest/">https://docs.openstack.org/devstack/latest/</a></p>
<p>安装Linux ¶<br>从干净，最小程度地安装Linux系统开始。DevStack尝试支持Ubuntu的两个最新LTS版本，最新/当前的Fedora版本，CentOS / RHEL 7以及Debian和OpenSUSE。</p>
<p>如果您没有偏好，Ubuntu 18.04（Bionic Beaver）将会是测试最多的，并且可能会做得最流畅。</p>
<p>添加堆栈用户（可选）¶<br>DevStack应该以启用了sudo的非root用户身份运行（通常可以正常登录到云映像，例如“ ubuntu”或“ cloud-user”）。</p>
<p>如果您不使用云映像，则可以创建一个单独的堆栈用户来运行DevStack</p>
<p>$ sudo useradd -s /bin/bash -d /opt/stack -m stack<br>由于此用户将对您的系统进行许多更改，因此它应该具有sudo特权：</p>
<p>$ echo “stack ALL=(ALL) NOPASSWD: ALL” | sudo tee /etc/sudoers.d/stack<br>$ sudo su - stack<br>下载DevStack ¶<br>$ git clone <a href="https://opendev.org/openstack/devstack">https://opendev.org/openstack/devstack</a><br>$ cd devstack<br>存储devstack库包含一个脚本，该脚本安装OpenStack和用于配置文件的模板。</p>
<p>创建local.conf中¶<br>local.conf在devstack git repo的根目录下创建一个具有四个密码的文件。</p>
<p>[[local|localrc]]<br>ADMIN_PASSWORD=secret<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD<br>这是开始使用DevStack所需的最低配置。</p>
<p> 注意</p>
<p>devstack存储库中local.conf的samples目录下有一个示例文件。</p>
<p>开始安装¶<br>$ ./stack.sh<br>这将需要15-20分钟，具体取决于您的互联网连接速度。在此过程中将安装许多git树和软件包。</p>
<p>二、环境准备<br>2.1 安装虚拟机Ubuntu<br>本例选用ubuntu16.04-server版本。<br>虚拟机配置：内存4G，磁盘：50GB<br>网络：桥接<br>设置用户名：stack，用户名可自由设置。</p>
<p>具体安装步骤后续再具体介绍。<br>安装好虚拟机后，启动虚拟机。</p>
<p>2.2 环境配置<br>2.2.1 给用户stack添加sudo权限<br>echo “stack ALL=(ALL) NOPASSWD: ALL” | sudo tee /etc/sudoers.d/stack<br>2.2.2 配置网卡<br>sudo vi /etc/network/interfaces</p>
<p>如上图示，设置静态IP。具体IP根据自己的主机环境来设置。<br>设置完后，记得重启网络：sudo /etc/init.d/networking restart。<br>如果更新失败，则重启虚拟机。</p>
<p>2.2.3 更换Ubuntu源<br>sudo vi /etc/apt/source.list</p>
<p>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial main restricted<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial-updates main restricted<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a>  xenial universe<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a>  xenial-updates universe<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial multiverse<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial-updates multiverse<br>deb <a href="http://hk.archive.ubuntu.com/ubuntu">http://hk.archive.ubuntu.com/ubuntu</a> xenial-backports main restricted universe multiverse<br>deb <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> xenial-security main restricted<br>deb <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> xenial-security universe<br>deb <a href="http://security.ubuntu.com/ubuntu">http://security.ubuntu.com/ubuntu</a> xenial-security multiverse  </p>
<p>2.2.4 更换pip源<br>创建文件：/home/stack/pip/pip.conf，其内容为：</p>
<p>[global]<br>index-url = <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>trusted-host = pypi.douban.com  </p>
<p>2.2.5 安装ssh：sudo apt-get install ssh<br>2.2.6 安装git：<br>sudo apt-get install git</p>
<p>2.2.7 安装python:<br>sudo apt-get install python</p>
<p>2.3 准备安装工具devstack<br>2.3.1 下载<br>git clone <a href="https://git.openstack.org/openstack-dev/devstack">https://git.openstack.org/openstack-dev/devstack</a><br>或者<br>git clone <a href="https://github.com/openstack-dev/devstack">https://github.com/openstack-dev/devstack</a><br>2.3.2 切换分支<br>cd devstack<br>git checkout stable/queens</p>
<p>2.3.4 配置devstack<br>在devstack目录下创建local.conf文件，内容如下：</p>
<p>[[local|localrc]]<br>ADMIN_PASSWORD=admin<br>DATABASE_PASSWORD=$ADMIN_PASSWORD<br>RABBIT_PASSWORD=$ADMIN_PASSWORD<br>SERVICE_PASSWORD=$ADMIN_PASSWORD</p>
<h1 id="Branches"><a href="#Branches" class="headerlink" title="Branches"></a>Branches</h1><p>KEYSTONE_BRANCH=stable/queens<br>NOVA_BRANCH=stable/queens<br>NEUTRON_BRANCH=stable/queens<br>SWIFT_BRANCH=stable/queens<br>GLANCE_BRANCH=stable/queens<br>CINDER_BRANCH=stable/queens</p>
<h1 id="Use-mirror"><a href="#Use-mirror" class="headerlink" title="Use mirror"></a>Use mirror</h1><p>GIT_BASE=<a href="http://git.trystack.cn">http://git.trystack.cn</a><br>NOVNC_REPO=<a href="http://git.trystack.cn/kanaka/noVNC.git">http://git.trystack.cn/kanaka/noVNC.git</a><br>SPICE_REPO=<a href="http://git.trystack.cn/git/spice/spice-html5.git">http://git.trystack.cn/git/spice/spice-html5.git</a></p>
<h1 id="Enable-heat-services"><a href="#Enable-heat-services" class="headerlink" title="Enable heat services"></a>Enable heat services</h1><p>enable_service h-eng h-api h-api-cfn h-api-cw</p>
<h1 id="Enable-heat-plugin"><a href="#Enable-heat-plugin" class="headerlink" title="Enable heat plugin"></a>Enable heat plugin</h1><p>enable_plugin heat <a href="http://git.trystack.cn/openstack/heat.git">http://git.trystack.cn/openstack/heat.git</a> stable/queens</p>
<p>IMAGE_URL_SITE=”<a href="http://download.fedoraproject.org&quot;">http://download.fedoraproject.org&quot;</a><br>IMAGE_URL_PATH=”/pub/fedora/linux/releases/25/CloudImages/x86_64/images/“<br>IMAGE_URL_FILE=”Fedora-Cloud-Base-25-1.3.x86_64.qcow2”<br>IMAGE_URLS+=”,”$IMAGE_URL_SITE$IMAGE_URL_PATH$IMAGE_URL_FILE</p>
<h1 id="Service-Dashboard-IP"><a href="#Service-Dashboard-IP" class="headerlink" title="Service/Dashboard IP"></a>Service/Dashboard IP</h1><p>FLOATING_RANGE=192.168.1.224/27<br>HOST_IP=172.20.10.6<br>FLAT_INTERFACE=enp0s3  </p>
<p>说明：172.20.10.6是虚拟机的IP地址。</p>
<p>三、安装OpenStack<br>切换到stack用户，在devstack目录下，执行脚本：./stack.sh，然后就是耐心等待。根据网络状况，等待从半小时到几个小时。<br>安装成功的提示：</p>
<p><a href="https://www.cnblogs.com/rhjeans/p/11328346.html">https://www.cnblogs.com/rhjeans/p/11328346.html</a></p>
<p>k8s:</p>
<p>docker login –username=17780517563 registry.cn-hangzhou.aliyuncs.com</p>
<p>docker tag gcr.io/google_containers/etcd:2.0.12 registry.cn-hangzhou.aliyuncs.com/huo_public/etcd:2.0.12<br>docker push registry.cn-hangzhou.aliyuncs.com/huo_public/etcd:2.0.12<br>docker images –digests<br>docker pull registry.cn-hangzhou.aliyuncs.com/lixin0120/kubernetes_etcd:3.3.10</p>
<p>docker run –net=host -d gcr.io/google_containers/etcd:2.0.12 /usr/local/bin/etcd –addr=127.0.0.1:4001 –bind-addr=0.0.0.0:4001 –data-dir=/var/etcd/data<br>CentOS 7</p>
<pre><code>sudo cp -n /lib/systemd/system/docker.service /etc/systemd/system/docker.service
sudo sed -i &quot;s|ExecStart=/usr/bin/docker daemon|ExecStart=/usr/bin/docker daemon --registry-mirror=https://s75dbt4b.mirror.aliyuncs.com|g&quot; /etc/systemd/system/docker.service
sudo sed -i &quot;s|ExecStart=/usr/bin/dockerd|ExecStart=/usr/bin/dockerd --registry-mirror=https://s75dbt4b.mirror.aliyuncs.com|g&quot; /etc/systemd/system/docker.service
sudo systemctl daemon-reload
sudo service docker restart      </code></pre><p>docker run –net=host -d registry.cn-hangzhou.aliyuncs.com/lixin0120/kubernetes_etcd:3.3.10 /usr/local/bin/etcd –addr=127.0.0.1:4001 –bind-addr=0.0.0.0:4001 –data-dir=/var/etcd/data</p>
<p>第一步：运行Etcd</p>
<p>docker run –net=host -d gcr.io/google_containers/etcd:2.0.12 /usr/local/bin/etcd –addr=127.0.0.1:4001 –bind-addr=0.0.0.0:4001 –data-dir=/var/etcd/data</p>
<p>docker run –net=host -d registry.cn-hangzhou.aliyuncs.com/lixin0120/kubernetes_etcd:3.3.10 /usr/local/bin/etcd –addr=127.0.0.1:4001 –bind-addr=0.0.0.0:4001 –data-dir=/var/etcd/data</p>
<p>第二步：启动master</p>
<h1 id="docker-pull-registry-cn-hangzhou-aliyuncs-com-google-kubernetes-container-kubernetes-v1-9-6"><a href="#docker-pull-registry-cn-hangzhou-aliyuncs-com-google-kubernetes-container-kubernetes-v1-9-6" class="headerlink" title="docker pull registry.cn-hangzhou.aliyuncs.com/google-kubernetes-container/kubernetes:v1.9.6"></a>docker pull registry.cn-hangzhou.aliyuncs.com/google-kubernetes-container/kubernetes:v1.9.6</h1><p>docker pull  registry.cn-hangzhou.aliyuncs.com/kubernetes-zy/hyperkube:v1.11.3<br>docker run <br>    –volume=/:/rootfs:ro <br>    –volume=/sys:/sys:ro <br>    –volume=/dev:/dev <br>    –volume=/var/lib/docker/:/var/lib/docker:ro <br>    –volume=/var/lib/kubelet/:/var/lib/kubelet:rw <br>    –volume=/var/run:/var/run:rw <br>    –net=host <br>    –pid=host <br>    –privileged=true <br>    -d <br>    registry.cn-hangzhou.aliyuncs.com/kubernetes-zy/hyperkube:v1.11.3 <br>    /hyperkube kubelet –containerized –hostname-override=”127.0.0.1” –address=”0.0.0.0” –api-servers=<a href="http://localhost:8080">http://localhost:8080</a> –config=/etc/kubernetes/manifests</p>
<p>这一步实际上运行的是 kubelet ，并启动了一个包含其他master组件的[pod](../userguide/pods.md）。</p>
<p>第三步：运行service proxy</p>
<p>docker run -d –net=host –privileged registry.cn-hangzhou.aliyuncs.com/kubernetes-zy/hyperkube:v1.11.3 /hyperkube proxy –master=<a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a> –v=2<br>测试<br>此时你应该已经运行起了一个Kubernetes集群。你可以下载kubectl二进制程序进行测试：</p>
<p>(OS X) (linux)<br>注意： 再OS/X上你需要通过ssh设置端口转发：</p>
<p>boot2docker ssh -L8080:localhost:8080<br>列出集群中的节点：</p>
<p>kubectl get nodes<br>应该输出以下内容：</p>
<p>NAME LABELS STATUS<br>127.0.0.1 Ready<br>如果你运行了不同的Kubernetes集群，你可能需要指定 -s <a href="http://localhost:8080">http://localhost:8080</a> 选项来访问本地集群。</p>
]]></content>
  </entry>
  <entry>
    <title>从0开始学架构</title>
    <url>/2020/01/01/%E8%AE%BE%E8%AE%A1/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="01-架构到底是指什么？"><a href="#01-架构到底是指什么？" class="headerlink" title="01 | 架构到底是指什么？"></a>01 | 架构到底是指什么？</h2><h4 id="系统与子系统"><a href="#系统与子系统" class="headerlink" title="系统与子系统"></a>系统与子系统</h4><ul>
<li>关联、规则、能力</li>
</ul>
<h4 id="模块与组件"><a href="#模块与组件" class="headerlink" title="模块与组件"></a>模块与组件</h4><ul>
<li>软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。</li>
<li>软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。</li>
</ul>
<p><strong>模块和组件都是系统的组成部分</strong>，只是从不同的角度拆分系统而已。</p>
<h4 id="框架与架构"><a href="#框架与架构" class="headerlink" title="框架与架构"></a>框架与架构</h4><ul>
<li><p>软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。‘</p>
<p>框架是组件规范：例如，MVC 就是一种最常见的开发规范，类似的还有 MVP、MVVM、J2EE 等框架。框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足 MVC 的规范，Spring 提供了很多基础功能来帮助我们实现功能，包括注解（@Controller 等）、Spring Security、Spring JPA 等很多基础功能。</p>
</li>
<li><p>软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。</p>
</li>
</ul>
<p><strong>框架关注的是“规范”，架构关注的是“结构”。框架的英文是 Framework，架构的英文是 Architecture。Spring MVC 的英文文档标题就是“Web MVC framework”。</strong></p>
<p>关键就是“基础结构”这个概念并没有明确说是从什么角度来分解的。采用不同的角度或者维度，可以将系统划分为不同的结构，其实我在“模块与组件”中的“学生管理系统”示例已经包含了这点</p>
<p>从业务逻辑的角度分解，“学生管理系统”的架构是：</p>
<p><img src="/.io//746f547767d94a5a7b8a9a130fcefc0c.jpg" alt="img"></p>
<p>从物理部署的角度分解，“学生管理系统”的架构是：</p>
<p><img src="/.io//0682867076f29d8f48c4021dabfd98ed.jpg" alt="img"></p>
<p>从开发规范的角度分解，“学生管理系统”可以采用标准的 MVC 框架来开发，因此架构又变成了 MVC 架构：</p>
<p><img src="/.io//e1b415fd316dc3f487a75f228c5fcf1d.jpg" alt="img"></p>
<p>这些“架构”，都是“学生管理系统”正确的架构，只是从不同的角度来分解而已，这也是 IBM 的 RUP 将软件架构视图分为著名的“4+1 视图”的原因。</p>
<pre><code>架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体</code></pre><p>重新定义架构参考维基百科的定义，我将架构重新定义为：<strong>软件架构指软件系统的顶层结构</strong>。这个定义看似很简单，但包含的信息很丰富，基本上把系统、子系统、模块、组件、架构等概念都串起来了，我来详细解释一下。首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。第三，维基百科定义的架构用到了“基础结构”这个说法，我改为“顶层结构”，可以更好地区分系统和子系统，避免将系统架构和子系统架构混淆在一起导致架构层次混乱。</p>
<h1 id="02-架构设计的历史背景"><a href="#02-架构设计的历史背景" class="headerlink" title="02 | 架构设计的历史背景"></a>02 | 架构设计的历史背景</h1><p>简单翻译一下：随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题；当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。这段话很好地解释了“软件架构”为何先在 Rational 或者 Microsoft 这样的大公司开始逐步流行起来。因为只有大公司开发的软件系统才具备较大规模，而只有规模较大的软件系统才会面临软件架构相关的问题，例如：系统规模庞大，内部耦合严重，开发效率低；系统耦合严重，牵一发动全身，后续修改和扩展困难；系统逻辑复杂，容易出问题，出问题后很难排查和修复。软件架构的出现有其历史必然性。20 世纪 60 年代第一次软件危机引出了“结构化编程”，创造了“模块”概念；20 世纪 80 年代第二次软件危机引出了“面向对象编程”，创造了“对象”概念；到了 20 世纪 90 年代“软件架构”开始流行，创造了“组件”概念。我们可以看到，“模块”“对象”“组件”本质上都是对达到一定规模的软件进行拆分，差别只是在于随着软件的复杂度不断增加，拆分的粒度越来越粗，拆分的层次越来越高。</p>
<pre><code>规模大，耦合严重，难修改和扩展，逻辑复杂，易出问题且难以排查</code></pre><h1 id="03-架构设计的目的"><a href="#03-架构设计的目的" class="headerlink" title="03 | 架构设计的目的"></a>03 | 架构设计的目的</h1><p><strong>架构设计的误区</strong></p>
<ul>
<li>因为架构很重要，所以要做架构设计【不做架构设计系统就跑不起来么？，做了架构设计就能提升开发效率么？，设计良好的架构能促进业务发展么？】</li>
<li>不是每个系统都要做架构设计吗</li>
<li>公司流程要求系统开发过程中必须有架构设计</li>
<li>为了高性能、高可用、可扩展，所以要做架构设计</li>
<li></li>
</ul>
<p><strong>架构设计的真正目的</strong></p>
<p>​    整个软件技术发展的历史，其实就是一部与“复杂度”斗争的历史，架构的出现也不例外。简而言之，架构也是为了应对软件系统复杂度而提出的一个解决方案，通过回顾架构产生的历史背景和原因，我们可以基本推导出答案：架构设计的主要目的是为了解决软件系统复杂度带来的问题。</p>
<p>“Docker 现在很流行，我们的架构应该将 Docker 应用进来”</p>
<p>——Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果我们的系统复杂度根本不是在这方面，引入 Docker 没有什么意义。</p>
<p><strong>简单的复杂度分析案例</strong></p>
<p>​    第一步就是identify系统的复杂度出现在哪里，性能，可用性，可拓展性，安全性</p>
<p>我来分析一个简单的案例，一起来看看如何将“架构设计的真正目的是为了解决软件系统复杂度带来的问题”这个指导思想应用到实践中。</p>
<p>假设我们需要设计一个大学的学生管理系统，其基本功能包括登录、注册、成绩管理、课程管理等。当我们对这样一个系统进行架构设计的时候，首先应识别其复杂度到底体现在哪里。性能：一个学校的学生大约 1 ~ 2 万人，学生管理系统的访问频率并不高，平均每天单个学生的访问次数平均不到 1 次，因此性能这部分并不复杂，存储用 MySQL 完全能够胜任，缓存都可以不用，Web 服务器用 Nginx 绰绰有余。可扩展性：学生管理系统的功能比较稳定，可扩展的空间并不大，因此可扩展性也不复杂。高可用：学生管理系统即使宕机 2 小时，对学生管理工作影响并不大，因此可以不做负载均衡，更不用考虑异地多活这类复杂的方案了。但是，如果学生的数据全部丢失，修复是非常麻烦的，只能靠人工逐条修复，这个很难接受，因此需要考虑存储高可靠，这里就有点复杂了。我们需要考虑多种异常情况：机器故障、机房故障，针对机器故障，我们需要设计 MySQL 同机房主备方案；针对机房故障，我们需要设计 MySQL 跨机房同步方案。安全性：学生管理系统存储的信息有一定的隐私性，例如学生的家庭情况，但并不是和金融相关的，也不包含强隐私（例如玉照、情感）的信息，因此安全性方面只要做 3 个事情就基本满足要求了：Nginx 提供 ACL 控制、用户账号密码管理、数据库访问权限控制。成本：由于系统很简单，基本上几台服务器就能够搞定，对于一所大学来说完全不是问题，可以无需太多关注。</p>
<h1 id="04-复杂度来源：高性能"><a href="#04-复杂度来源：高性能" class="headerlink" title="04 | 复杂度来源：高性能"></a>04 | 复杂度来源：高性能</h1><h4 id="软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。"><a href="#软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。" class="headerlink" title="软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。"></a>软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。</h4><p>单机复杂度</p>
<pre><code>操作系统可以发挥硬件的性能，具体发挥出来多少，取决于操作系统的能力
操作系统和性能最相关的就是进程和线程
多进程多线程虽然让多任务并行处理的性能大大提升，但本质上还是分时系统，并不能做到时间上真正的并行。解决这个问题的方式显而易见，就是让多个 CPU 能够同时执行计算任务，从而实现真正意义上的多任务并行。目前这样的解决方案有 3 种：SMP（Symmetric Multi-Processor，对称多处理器结构）、NUMA（Non-Uniform Memory Access，非一致存储访问结构）、MPP（Massive Parallel Processing，海量并行处理结构）。其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP 方案。
操作系统发展到现在，如果我们要完成一个高性能的软件系统，需要考虑如多进程、多线程、进程间通信、多线程并发等技术点，而且这些技术并不是最新的就是最好的，也不是非此即彼的选择。在做架构设计的时候，需要花费很大的精力来结合业务进行分析、判断、选择、组合，这个过程同样很复杂。举一个最简单的例子：Nginx 可以用多进程也可以用多线程，JBoss 采用的是多线程；Redis 采用的是单进程，Memcache 采用的是多线程，这些系统都实现了高性能，但内部实现差异却很大。</code></pre><p><strong>集群的复杂度</strong></p>
<p>通过大量机器来提升性能，并不仅仅是增加机器这么简单，让多台机器配合起来达到高性能的目的，是一个复杂的任务，我针对常见的几种方式简单分析一下。</p>
<ul>
<li><p>任务分配</p>
<p>任务分配的意思是指每台机器都可以处理完整的业务任务，不同的任务分配到不同的机器上执行。</p>
</li>
<li><p>任务分解</p>
<p>通过任务分配的方式，我们能够突破单台机器处理性能的瓶颈，通过增加更多的机器来满足业务的性能需求，但如果业务本身也越来越复杂，单纯只通过任务分配的方式来扩展性能，收益会越来越低。例如，业务简单的时候 1 台机器扩展到 10 台机器，性能能够提升 8 倍（需要扣除机器群带来的部分性能损耗，因此无法达到理论上的 10 倍那么高），但如果业务越来越复杂，1 台机器扩展到 10 台，性能可能只能提升 5 倍。造成这种现象的主要原因是业务越来越复杂，单台机器处理的性能会越来越低。为了能够继续提升性能，我们需要采取第二种方式：任务分解。继续以上面“任务分配”中的架构为例，“业务服务器”如果越来越复杂，我们可以将其拆分为更多的组成部分，我以微信的后台架构为例</p>
<p>通过上面的架构示意图可以看出，微信后台架构从逻辑上将各个子业务进行了拆分，包括：接入、注册登录、消息、LBS、摇一摇、漂流瓶、其他业务（聊天、视频、朋友圈等）</p>
<p>任务分解就能够提升性能主要有几方面的因素</p>
<p>简单的系统更加容易做到高性能</p>
<p>可以针对单个任务进行扩展</p>
</li>
</ul>
<p>虽然系统拆分可能在某种程度上能提升业务处理性能，但提升性能也是有限的，不可能系统不拆分的时候业务处理耗时为 50ms，系统拆分后业务处理耗时只要 1ms，因为最终决定业务处理性能的还是业务逻辑本身，业务逻辑本身没有发生大的变化下，理论上的性能是有一个上限的，系统拆分能够让性能逼近这个极限，但无法突破这个极限。因此，任务分解带来的性能收益是有一个度的，并不是任务分解越细越好，而对于架构设计来说，如何把握这个粒度就非常关键了。</p>
<h1 id="05-复杂度来源：高可用"><a href="#05-复杂度来源：高可用" class="headerlink" title="05 | 复杂度来源：高可用"></a>05 | 复杂度来源：高可用</h1><pre><code>系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</code></pre><p>系统的高可用方案五花八门，但万变不离其宗，本质上都是通过“冗余”来实现高可用。通俗点来讲，就是一台机器不够就两台，两台不够就四台；一个机房可能断电，那就部署两个机房；一条通道可能故障，那就用两条，两条不够那就用三条（移动、电信、联通一起上）。高可用的“冗余”解决方案，单纯从形式上来看，和之前讲的高性能是一样的，都是通过增加更多机器来达到目的，但其实本质上是有根本区别的：<strong>高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。</strong></p>
<p><strong>计算高可用</strong></p>
<p>这里的“计算”指的是业务的逻辑处理。计算有一个特点就是无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的，所以将计算从一台机器迁移到另外一台机器，对业务并没有什么影响。既然如此，计算高可用的复杂度体现在哪里呢？我以最简单的单机变双机为例进行分析。先来看一个单机变双机的简单架构示意图</p>
<p><img src="/.io//9616057cea1365eacf5f6c9c0091yy97.jpg" alt="img"></p>
<p>你可能会发现，这个双机的架构图和上期“高性能”讲到的双机架构图是一样的，因此复杂度也是类似的，具体表现为：需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面因素。任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。</p>
<p><strong>存储高可用</strong></p>
<p>对于需要存储数据的系统来说，整个系统的高可用设计关键点和难点就在于“存储高可用”。存储与计算相比，有一个本质上的区别：将数据从一台机器搬到到另一台机器，需要经过线路进行传输。线路传输的速度是毫秒级别，同一机房内部能够做到几毫秒；分布在不同地方的机房，传输耗时需要几十甚至上百毫秒。例如，从广州机房到北京机房，稳定情况下 ping 延时大约是 50ms，不稳定情况下可能达到 1s 甚至更多。</p>
<p><img src="/.io//0bcb547c1f2yyc8c1761cd203656765d.jpg" alt="img"></p>
<p>综合分析，无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题；但如果完全不做冗余，系统的整体高可用又无法保证，所以<strong>存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响</strong>。</p>
<p>分布式领域里面有一个著名的 CAP 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。</p>
<p><strong>高可用状态决策</strong></p>
<p>​        无论是计算高可用还是存储高可用，其基础都是“状态决策”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。但在具体实践的过程中，恰好存在一个本质的矛盾：通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。下面我基于几种常见的决策方式进行详细分析。</p>
<p>\1. 独裁式独裁式决策指的是存在一个独立的决策主体，我们姑且称它为“决策者”，负责收集信息然后进行决策；所有冗余的个体，我们姑且称它为“上报者”，都将状态信息发送给决策者</p>
<p>\2. 协商式协商式决策指的是两个独立的个体通过交流信息，然后根据规则进行决策，最常用的协商式决策就是主备决策。 协商式状态决策在某些场景总是存在一些问题的。</p>
<p>\3. 民主式民主式决策指的是多个独立的个体通过投票的方式来进行状态决策。例如，ZooKeeper 集群在选举 leader 时就是采用这种方式。 “多数取胜”的规则来确定最终的状态</p>
<h1 id="06-复杂度来源：可扩展性"><a href="#06-复杂度来源：可扩展性" class="headerlink" title="06 | 复杂度来源：可扩展性"></a>06 | 复杂度来源：可扩展性</h1><p>可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。由于软件系统固有的多变性，新的需求总会不断提出来，因此可扩展性显得尤其重要。在软件开发领域，面向对象思想的提出，就是为了解决可扩展性带来的问题；后来的设计模式，更是将可扩展性做到了极致。得益于设计模式的巨大影响力，几乎所有的技术人员对于可扩展性都特别重视。设计具备良好可扩展性的系统，有两个基本条件：正确预测变化、完美封装变化。但要达成这两个条件，本身也是一件复杂的事情，我来具体分析一下。</p>
<p><strong>预测变化</strong></p>
<p>软件系统与硬件或者建筑相比，有一个很大的差异：软件系统在发布后还可以不断地修改和演进，这就意味着不断有新的需求需要实现。</p>
<p>预测与不预测，预测多与预测少，这两者的平衡艺术</p>
<p>综合分析，预测变化的复杂性在于：不能每个设计点都考虑可扩展性。不能完全不考虑可扩展性。所有的预测都存在出错的可能性。</p>
<p><strong>应对变化</strong></p>
<p>第一种应对变化的常见方案是将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。</p>
<p>无论是变化层依赖稳定层，还是稳定层依赖变化层都是可以的，需要根据具体业务情况来设计。例如，如果系统需要支持 XML、JSON、ProtocolBuffer 三种接入方式，那么最终的架构就是上面图中的“形式 1”架构，也就是下面这样。</p>
<p><img src="/.io//0yy87c891c7ba0fd16826e8a91aa6ed3.jpg" alt="img"></p>
<p>如果系统需要支持 MySQL、Oracle、DB2 数据库存储，那么最终的架构就变成了“形式 2”的架构了，你可以看下面这张图。</p>
<p><img src="/.io//87c436de169b45f4b2909a7495c4eec4.jpg" alt="img"></p>
<p>无论采取哪种形式，通过剥离变化层和稳定层的方式应对变化，都会带来两个主要的复杂性相关的问题。</p>
<ol>
<li><p>系统需要拆分出变化层和稳定层</p>
<p>​        对于哪些属于变化层，哪些属于稳定层，很多时候并不是像前面的示例（不同接口协议或者不同数据库）那样明确，不同的人有不同的理解，导致架构设计评审的时候可能吵翻天。</p>
</li>
<li><p>需要设计变化层和稳定层之间的接口</p>
<p>​        接口设计同样至关重要，对于稳定层来说，接口肯定是越稳定越好；但对于变化层来说，在有差异的多个实现方式中找出共同点，并且还要保证当加入新的功能时原有的接口设计不需要太大修改，这是一件很复杂的事情。例如，MySQL 的 REPLACE INTO 和 Oracle 的 MERGE INTO 语法和功能有一些差异，那存储层如何向稳定层提供数据访问接口呢？是采取 MySQL 的方式，还是采取 Oracle 的方式，还是自适应判断？如果再考虑 DB2 的情况呢？相信你看到这里就已经能够大致体会到接口设计的复杂性了。</p>
</li>
</ol>
<p>第二种常见的应对变化的方案是提炼出一个“抽象层”和一个“实现层”。抽象层是稳定的，实现层可以根据具体业务需要定制开发，当加入新的功能时，只需要增加新的实现，无须修改抽象层。这种方案典型的实践就是设计模式和规则引擎。考虑到绝大部分技术人员对设计模式都非常熟悉，我以设计模式为例来说明这种方案的复杂性。以设计模式的“装饰者”模式来分析，下面是装饰者模式的类关系图。</p>
<p><img src="/.io//69fd1fbd54fce48784cbb0e05e304888.jpg" alt="img"></p>
<p>中的 Component 和 Decorator 就是抽象出来的规则，这个规则包括几部分：Component 和 Decorator 类。Decorator 类继承 Component 类。Decorator 类聚合了 Component 类。这个规则一旦抽象出来后就固定了，不能轻易修改。例如，把规则 3 去掉，就无法实现装饰者模式的目的了。</p>
<p>装饰者模式相比传统的继承来实现功能，确实灵活很多。例如，《设计模式》中装饰者模式的样例“TextView”类的实现，用了装饰者之后，能够灵活地给 TextView 增加额外更多功能，比如可以增加边框、滚动条、背景图片等，这些功能上的组合不影响规则，只需要按照规则实现即可。但装饰者模式相对普通的类实现模式，明显要复杂多了。本来一个函数或者一个类就能搞定的事情，现在要拆分成多个类，而且多个类之间必须按照装饰者模式来设计和调用。规则引擎和设计模式类似，都是通过灵活的设计来达到可扩展的目的，但“灵活的设计”本身就是一件复杂的事情，不说别的，光是把 23 种设计模式全部理解和备注，都是一件很困难的事情。</p>
<h1 id="07-复杂度来源：低成本、安全、规模"><a href="#07-复杂度来源：低成本、安全、规模" class="headerlink" title="07 | 复杂度来源：低成本、安全、规模"></a>07 | 复杂度来源：低成本、安全、规模</h1><p><strong>低成本</strong></p>
<p>当我们的架构方案只涉及几台或者十几台服务器时，一般情况下成本并不是我们重点关注的目标，但如果架构方案涉及几百上千甚至上万台服务器，成本就会变成一个非常重要的架构设计考虑点</p>
<p>高可用和低成本是冲突的，需要有权衡。</p>
<p>当我们设计“高性能”“高可用”的架构时，通用的手段都是增加更多服务器来满足“高性能”和“高可用”的要求；而低成本正好与此相反，我们需要减少服务器的数量才能达成低成本的目标。因此，低成本本质上是与高性能和高可用冲突的，所以低成本很多时候不会是架构设计的首要目标，而是架构设计的附加约束。也就是说，我们首先设定一个成本目标，当我们根据高性能、高可用的要求设计出方案时，评估一下方案是否能满足成本目标，如果不行，就需要重新设计架构；如果无论如何都无法设计出满足成本要求的方案，那就只能找老板调整成本目标了。</p>
<p>低成本给架构设计带来的主要复杂度体现在，往往只有“创新”才能达到低成本目标。这里的“创新”既包括开创一个全新的技术领域（这个要求对绝大部分公司太高），也包括引入新技术，如果没有找到能够解决自己问题的新技术，那么就真的需要自己创造新技术了。</p>
<p>类似的新技术例子很多，我来举几个。</p>
<p>NoSQL（Memcache、Redis 等）的出现是为了解决关系型数据库无法应对高并发访问带来的访问压力。</p>
<p>全文搜索引擎（Sphinx、Elasticsearch、Solr）的出现是为了解决关系型数据库 like 搜索的低效的问题。</p>
<p>Hadoop 的出现是为了解决传统文件系统无法应对海量数据存储和计算的问题。</p>
<p>无论是引入新技术，还是自己创造新技术，都是一件复杂的事情。引入新技术的主要复杂度在于需要去熟悉新技术，并且将新技术与已有技术结合起来；创造新技术的主要复杂度在于需要自己去创造全新的理念和技术，并且新技术跟旧技术相比，需要有质的飞跃。</p>
<p><strong>安全</strong></p>
<p>安全本身是一个庞大而又复杂的技术领域，并且一旦出问题，对业务和企业形象影响非常大。</p>
<p>从技术的角度来讲，安全可以分为两类：一类是功能上的安全，一类是架构上的安全。</p>
<ol>
<li><p>功能安全</p>
<p>​        例如，常见的 XSS 攻击、CSRF 攻击、SQL 注入、Windows 漏洞、密码破解等，本质上是因为系统实现有漏洞，黑客有了可乘之机。黑客会利用各种漏洞潜入系统，这种行为就像小偷一样，黑客和小偷的手法都是利用系统或家中不完善的地方潜入，并进行破坏或者盗取。因此形象地说，功能安全其实就是“防小偷”。</p>
</li>
</ol>
<p>\2. 架构安全</p>
<p>如果说功能安全是“防小偷”，那么架构安全就是“防强盗”。强盗会直接用大锤将门砸开，或者用炸药将围墙炸倒；小偷是偷东西，而强盗很多时候就是故意搞破坏，对系统的影响也大得多。因此架构设计时需要特别关注架构安全，尤其是互联网时代，理论上来说系统部署在互联网上时，全球任何地方都可以发起攻击。</p>
<p>传统的架构安全主要依靠防火墙，防火墙最基本的功能就是隔离网络，通过将网络划分成不同的区域，制定出不同区域之间的访问控制策略来控制不同信任程度区域间传送的数据流。例如，下图是一个典型的银行系统的安全架构。</p>
<p><img src="/.io//28e72e72d8691f1c869ea0db283e156b.png" alt="img"></p>
<p>基于上述原因，互联网系统的架构安全目前并没有太好的设计手段来实现，更多地是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现。</p>
<p><strong>规模</strong></p>
<p>很多企业级的系统，既没有高性能要求，也没有双中心高可用要求，也不需要什么扩展性，但往往我们一说到这样的系统，很多人都会脱口而出：这个系统好复杂！为什么这样说呢？关键就在于这样的系统往往功能特别多，逻辑分支特别多。特别是有的系统，发展时间比较长，不断地往上面叠加功能，后来的人由于不熟悉整个发展历史，可能连很多功能的应用场景都不清楚，或者细节根本无法掌握，面对的就是一个黑盒系统，看不懂、改不动、不敢改、修不了，复杂度自然就感觉很高了。</p>
<p><strong>规模带来复杂度的主要原因就是“量变引起质变”，</strong>当数量超过一定的阈值后，复杂度会发生质的变化。常见的规模带来的复杂度有：</p>
<p>\1. 功能越来越多，导致系统复杂度指数级上升</p>
<p>\2. 数据越来越多，系统复杂度发生质变</p>
<p>​        添加索引会很慢，可能需要几个小时，这几个小时内数据库表是无法插入数据的，相当于业务停机了。修改表结构和添加索引存在类似的问题，耗时可能会很长。即使有索引，索引的性能也可能会很低，因为数据量太大。数据库备份耗时很长。……因此，当 MySQL 单表数据量太大时，我们必须考虑将单表拆分为多表，这个拆分过程也会引入更多复杂性，例如：拆表的规则是什么？以用户表为例：是按照用户 id 拆分表，还是按照用户注册时间拆表？拆完表后查询如何处理？以用户表为例：假设按照用户 id 拆表，当业务需要查询学历为“本科”以上的用户时，要去很多表查询才能得到最终结果，怎么保证性能？</p>
<h1 id="08-架构设计三原则"><a href="#08-架构设计三原则" class="headerlink" title="08 | 架构设计三原则"></a>08 | 架构设计三原则</h1><p>成为架构师是每个程序员的梦想，但并不意味着把编程做好就能够自然而然地成为一个架构师，优秀程序员和架构师之间还有一个明显的鸿沟需要跨越，这个鸿沟就是“不确定性”。对于编程来说，本质上是不能存在不确定的，对于同样一段代码，不管是谁写的，不管什么时候执行，执行的结果应该都是确定的（注意：“确定的”并不等于“正确的”，有 bug 也是确定的）。而对于架构设计来说，本质上是不确定的，同样的一个系统，A 公司和 B 公司做出来的架构可能差异很大，但最后都能正常运转；同样一个方案，A 设计师认为应该这样做，B 设计师认为应该那样做，看起来好像都有道理……相比编程来说，架构设计并没有像编程语言那样的语法来进行约束，更多的时候是面对多种可能性时进行选择。</p>
<p>可是一旦涉及“选择”，就很容易让架构师陷入两难的境地，例如：</p>
<p>是要选择业界最先进的技术，还是选择团队目前最熟悉的技术？如果选了最先进的技术后出了问题怎么办？如果选了目前最熟悉的技术，后续技术演进怎么办？</p>
<p>是要选择 Google 的 Angular 的方案来做，还是选择 Facebook 的 React 来做？Angular 看起来更强大，但 React 看起来更灵活？</p>
<p>是要选 MySQL 还是 MongoDB？团队对 MySQL 很熟悉，但是 MongoDB 更加适合业务场景？淘宝的电商网站架构很完善，我们新做一个电商网站，是否简单地照搬淘宝就可以了？</p>
<p>还有很多类似的问题和困惑，关键原因在于架构设计领域并没有一套通用的规范来指导架构师进行架构设计，更多是依赖架构师的经验和直觉，因此架构设计有时候也会被看作一项比较神秘的工作。</p>
<p>业务千变万化，技术层出不穷，设计理念也是百花齐放，看起来似乎很难有一套通用的规范来适用所有的架构设计场景。但是在研究了架构设计的发展历史、多个公司的架构发展过程（QQ、淘宝、Facebook 等）、众多的互联网公司架构设计后，我发现有几个共性的原则隐含其中，这就是：<strong>合适原则、简单原则、演化原则</strong>，架构设计时遵循这几个原则，有助于你做出最好的选择。</p>
<p><strong>合适原则</strong></p>
<p><strong>合适原则宣言：“合适优于业界领先”。</strong></p>
<p>\1. 将军难打无兵之仗</p>
<p>​    没那么多人，却想干那么多活，是失败的第一个主要原因。</p>
<p>\2. 罗马不是一天建成的</p>
<p>​    没有那么多积累，却想一步登天，是失败的第二个主要原因。</p>
<p>\3. 冰山下面才是关键</p>
<p>​    没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。</p>
<p>​    新技术的出现“纯属无奈”😄</p>
<p>真正优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来的，能够合理地将资源整合在一起并发挥出最大功效，并且能够快速落地。这也是很多 BAT 出来的架构师到了小公司或者创业团队反而做不出成绩的原因，因为没有了大公司的平台、资源、积累，只是生搬硬套大公司的做法，失败的概率非常高。简单原则</p>
<p><strong>简单原则</strong></p>
<p><strong>简单原则宣言：“简单优于复杂”。</strong></p>
<p>​    团队的压力有时也会有意无意地促进我们走向复杂的方向，因为大部分人在评价一个方案水平高低的时候，复杂性是其中一个重要的参考指标。例如设计一个主备方案，如果你用心跳来实现，可能大家都认为这太简单了。但如果你引入 ZooKeeper 来做主备决策，可能很多人会认为这个方案更加“高大上”一些，毕竟 ZooKeeper 使用的是 ZAB 协议，而 ZAB 协议本身就很复杂。其实，真正理解 ZAB 协议的人很少（我也不懂），但并不妨碍我们都知道 ZAB 协议很优秀。刚才我聊的这些原因，会在潜意识层面促使初出茅庐的架构师，不自觉地追求架构的复杂性。然而，“复杂”在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是“问题”。</p>
<p>软件领域的复杂性体现在两个方面：</p>
<p>1、结构的复杂性</p>
<p>​    结构复杂的系统几乎毫无例外具备两个特点：</p>
<ol>
<li>组成复杂系统的组件数量更多；</li>
<li>同时这些组件之间的关系也更加复杂。</li>
</ol>
<p>​    结构上的复杂性存在的问题：</p>
<ul>
<li>组件越多，就越有可能其中某个组件出现故障</li>
<li>某个组件改动，会影响关联的所有组件</li>
<li>定位一个复杂系统中的问题总是比简单系统更加困难</li>
</ul>
<p>\2. 逻辑的复杂性</p>
<p>​    意识到结构的复杂性后，我们的第一反应可能就是“降低组件数量”，毕竟组件数量越少，系统结构越简。最简单的结构当然就是整个系统只有一个组件，即系统本身，所有的功能和逻辑都在这一个组件中实现。</p>
<p>​    逻辑复杂的组件，一个典型特征就是单个组件承担了太多的功能。以电商业务为例，常见的功能有：商品管理、商品搜索、商品展示、订单管理、用户管理、支付、发货、客服……把这些功能全部在一个组件中实现，就是典型的逻辑复杂性。</p>
<p>​    综合前面的分析，我们可以看到，无论是结构的复杂性，还是逻辑的复杂性，都会存在各种问题，所以架构设计时如果简单的方案和复杂的方案都可以满足需求，最好选择简单的方案。《UNIX 编程艺术》总结的 KISS（Keep It Simple, Stupid!）原则一样适应于架构设计。</p>
<p><strong>演化原则</strong></p>
<p><strong>演化原则宣言：“演化优于一步到位”。</strong></p>
<p>软件架构从字面意思理解和建筑结构非常类似，事实上“架构”这个词就是建筑领域的专业名词，维基百科对“软件架构”的定义中有一段话描述了这种相似性：</p>
<pre><code>从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。</code></pre><p>例如，软件架构描述的是一个软件系统的结构，包括各个模块，以及这些模块的关系；建筑架构描述的是一幢建筑的结构，包括各个部件，以及这些部件如何有机地组成成一幢完美的建筑。</p>
<p>然而，字面意思上的相似性却掩盖了一个本质上的差异：建筑一旦完成（甚至一旦开建）就不可再变，而软件却需要根据业务的发展不断地变化！</p>
<pre><code>对于建筑来说，永恒是主题；而对于软件来说，变化才是主题。</code></pre><p>考虑到软件架构需要根据业务发展不断变化这个本质特点，<strong>软件架构设计其实更加类似于大自然“设计”一个生物，通过演化让生物适应环境，逐步变得更加强大：</strong></p>
<p>首先，生物要适应当时的环境。</p>
<p>其次，生物需要不断地繁殖，将有利的基因传递下去，将不利的基因剔除或者修复。</p>
<p>第三，当环境变化时，生物要能够快速改变以适应环境变化；如果生物无法调整就被自然淘汰；新的生物会保留一部分原来被淘汰生物的基因。</p>
<p>软件架构设计同样是类似的过程：</p>
<p>首先，设计出来的架构要满足当时的业务需要。</p>
<p>其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。</p>
<p>第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。</p>
<p>架构师在进行架构设计时需要牢记这个原则，时刻提醒自己不要贪大求全，或者盲目照搬大公司的做法。应该认真分析当前业务的特点，明确业务面临的主要问题，设计合理的架构，快速落地以满足业务需要，然后在运行过程中不断完善架构，不断随着业务演化架构。</p>
<p>即使是大公司的团队，在设计一个新系统的架构时，也需要遵循演化的原则，而不应该认为团队人员多、资源多，不管什么系统上来就要一步到位，因为业务的发展和变化是很快的，不管多牛的团队，也不可能完美预测所有的业务发展和变化路径。</p>
<h1 id="09-架构设计原则案例"><a href="#09-架构设计原则案例" class="headerlink" title="09 | 架构设计原则案例"></a>09 | 架构设计原则案例</h1><p>淘宝注：</p>
<p>淘宝技术发展主要经历了“个人网站”→“Oracle/ 支付宝 / 旺旺”→“Java 时代 1.0”→“Java 时代 2.0”→“Java 时代 3.0”→“分布式时代”。我们看看每个阶段的主要驱动力是什么。</p>
<p>买一个系统是为了“快速可用”，而买一个轻量级的系统是为了“快速开发”。</p>
<p><img src="/.io//369c79010ebbdea7fbc787a9f8388yyd.jpg" alt="img"></p>
<p><img src="/.io//c735c053a4765c0739e2c5b3ef1b962e.jpg" alt="img"></p>
<p><img src="/.io//9558b5cbb1yyf77154e4172ceb66b92c.jpg" alt="img"></p>
<p><img src="/.io//84818454a50bc4ca97fdf3d152cbb45b.jpg" alt="img"></p>
<p>手机 QQ</p>
<p>手机 QQ 的发展历程按照用户规模可以粗略划分为 4 个阶段：十万级、百万级、千万级、亿级，不同的用户规模，IM 后台的架构也不同，而且基本上都是用户规模先上去，然后产生各种问题，倒逼技术架构升级。</p>
<p>今天我给你讲了淘宝和手机 QQ 两个典型互联网业务的架构发展历程，通过这两个案例我们可以看出，即使是现在非常复杂、非常强大的架构，也并不是一开始就进行了复杂设计，而是首先采取了简单的方式（简单原则），满足了当时的业务需要（合适原则），随着业务的发展逐步演化而来的（演化原则）。罗马不是一天建成的，架构也不是一开始就设计成完美的样子，然后可以一劳永逸一直用下去。</p>
<h1 id="10-架构设计流程：识别复杂度"><a href="#10-架构设计流程：识别复杂度" class="headerlink" title="10 | 架构设计流程：识别复杂度"></a>10 | 架构设计流程：识别复杂度</h1><p>从今天开始，我将分 4 期，结合复杂度来源和架构设计原则，通过一个模拟的设计场景“前浪微博”，和你一起看看在实践中究竟如何进行架构设计。今天先来看<strong>架构设计流程第 1 步：识别复杂度。</strong></p>
<p>架构设计第 1 步：<strong>识别复杂度</strong></p>
<pre><code>架构设计的目的就是为了解决软件系统的复杂度 一般复杂度会来源于：高可用、扩展性、高性能、安全性、逻辑复杂耦合性</code></pre><p>我在前面讲过，架构设计的本质目的是为了解决软件系统的复杂性，所以在我们设计架构时，首先就要分析系统的复杂性。只有正确分析出了系统的复杂性，后续的架构设计方案才不会偏离方向；否则，如果对系统的复杂性判断错误，即使后续的架构设计方案再完美再先进，都是南辕北辙，做的越好，错的越多、越离谱。</p>
<p>架构的复杂度主要来源于“高性能”“高可用”“可扩展”等几个方面，但架构师在具体判断复杂性的时候，不能生搬硬套，认为任何时候架构都必须同时满足这三方面的要求。实际上大部分场景下，复杂度只是其中的某一个，少数情况下包含其中两个，如果真的出现同时需要解决三个或者三个以上的复杂度，要么说明这个系统之前设计的有问题，要么可能就是架构师的判断出现了失误，即使真的认为要同时满足这三方面的要求，也必须要进行优先级排序。</p>
<p>因此，正确的做法是<strong>将主要的复杂度问题列出来，然后根据业务、技术、团队等综合情况进行排序，优先解决当前面临的最主要的复杂度问题</strong>。“亿级用户平台”这个案例，团队就优先选择将子系统的数量降下来，后来发现子系统数量降下来后，不但开发效率提升了，原来经常发生的小问题也基本消失了，于是团队再在这个基础上做了异地多活方案，也取得了非常好的效果。</p>
<p>即使架构师决定要推倒重来，这个新的方案也必须能够同时解决已经被解决的复杂度问题，一般来说能够达到这种理想状态的方案基本都是依靠新技术的引入。例如，Hadoop 能够将高可用、高性能、大容量三个大数据处理的复杂度问题同时解决。</p>
<p>识别复杂度对架构师来说是一项挑战，因为原始的需求中并没有哪个地方会明确地说明复杂度在哪里，需要架构师在理解需求的基础上进行分析。有经验的架构师可能一看需求就知道复杂度大概在哪里；如果经验不足，那只能采取“排查法”，从不同的角度逐一进行分析</p>
<p><strong>识别复杂度实战</strong></p>
<p>我们假想一个创业公司，名称叫作“前浪微博”。前浪微博的业务发展很快，系统也越来越多，系统间协作的效率很低，例如：</p>
<p>针对前浪微博的消息队列系统，采用“排查法”来分析复杂度，具体分析过程是：</p>
<p>这个消息队列是否需要高性能</p>
<p>​    : 对于架构师来说，常见系统的性能量级需要烂熟于心，例如nginx负载均衡性能是3万左右，mc的读取性能5万左右，kafka号称百万级，zookeeper写入读取2万以上，http请求访问大概在2万左右。</p>
<p>这个消息队列是否需要高可用性</p>
<p>​    消息队列需要高可用性，包括消息写入、消息存储、消息读取都需要保证高可用性。</p>
<p>这个消息队列是否需要高可扩展性</p>
<p>​    消息队列的功能很明确，基本无须扩展，因此可扩展性不是这个消息队列的复杂度关键。</p>
<p>综合分析下来，消息队列的复杂性主要体现在这几个方面：高性能消息读取、高可用消息写入、高可用消息存储、高可用消息读取。</p>
<h1 id="11-架构设计流程：设计备选方案"><a href="#11-架构设计流程：设计备选方案" class="headerlink" title="11 | 架构设计流程：设计备选方案"></a>11 | 架构设计流程：设计备选方案</h1><p><strong>架构设计第 2 步：设计备选方案、</strong></p>
<p>架构师的工作并不神秘，成熟的架构师需要对已经存在的技术非常熟悉，对已经经过验证的架构模式烂熟于心，然后根据自己对业务的理解，挑选合适的架构模式进行组合，再对组合后的方案进行修改和调整。</p>
<p>虽然软件技术经过几十年的发展，新技术层出不穷，但是经过时间考验，已经被各种场景验证过的成熟技术其实更多。例如，高可用的主备方案、集群方案，高性能的负载均衡、多路复用，可扩展的分层、插件化等技术，绝大部分时候我们有了明确的目标后，按图索骥就能够找到可选的解决方案。</p>
<p>只有当这种方式完全无法满足需求的时候，才会考虑进行方案的创新，而事实上方案的创新绝大部分情况下也都是基于已有的成熟技术。</p>
<p>NoSQL：Key-Value 的存储和数据库的索引其实是类似的，</p>
<p>Memcache 只是把数据库的索引独立出来做成了一个缓存系统。</p>
<p>Hadoop 大文件存储方案，基础其实是集群方案 + 数据复制方案。</p>
<p>Docker 虚拟化，基础是 LXC（Linux Containers）。</p>
<p>LevelDB 的文件存储结构是 Skip List。</p>
<p>在《技术的本质》一书中，</p>
<p>对技术的组合有清晰的阐述：</p>
<pre><code>新技术都是在现有技术的基础上发展起来的，现有技术又来源于先前的技术。将技术进行功能性分组，可以大大简化设计过程，这是技术“模块化”的首要原因。技术的“组合”和“递归”特征，将彻底改变我们对技术本质的认识。</code></pre><p>虽说基于已有的技术或者架构模式进行组合，然后调整，大部分情况下就能够得到我们需要的方案，但并不意味着架构设计是一件很简单的事情。因为可选的模式有很多，组合的方案更多，往往一个问题的解决方案有很多个；如果再在组合的方案上进行一些创新，解决方案会更多。因此，如何设计最终的方案，并不是一件容易的事情，这个阶段也是很多架构师容易犯错的地方。</p>
<p>第一种常见的错误：设计最优秀的方案。</p>
<p>​        很多架构师在设计架构方案时，心里会默认有一种技术情结：我要设计一个优秀的架构，才能体现我的技术能力！例如，高可用的方案中，集群方案明显比主备方案要优秀和强大；高性能的方案中，淘宝的 XX 方案是业界领先的方案……</p>
<p>第二种常见的错误：只做一个方案。</p>
<p>​        很多架构师在做方案设计时，可能心里会简单地对几个方案进行初步的设想，再简单地判断哪个最好，然后就基于这个判断开始进行详细的架构设计了。</p>
<p>这样做有很多弊端：</p>
<p>心里评估过于简单，可能没有想得全面，只是因为某一个缺点就把某个方案给否决了，而实际上没有哪个方案是完美的，某个地方有缺点的方案可能是综合来看最好的方案。</p>
<p>架构师再怎么牛，经验知识和技能也有局限，有可能某个评估的标准或者经验是不正确的，或者是老的经验不适合新的情况，甚至有的评估标准是架构师自己原来就理解错了。</p>
<p>单一方案设计会出现过度辩护的情况，即架构评审时，针对方案存在的问题和疑问，架构师会竭尽全力去为自己的设计进行辩护，经验不足的设计人员可能会强词夺理。</p>
<p>因此，架构师需要设计多个备选方案，但方案的数量可以说是无穷无尽的，架构师也不可能穷举所有方案，那合理的做法应该是什么样的呢？</p>
<p><strong>备选方案的数量以 3 ~ 5 个为最佳。</strong></p>
<p>少于 3 个方案可能是因为思维狭隘，考虑不周全；多于 5 个则需要耗费大量的精力和时间，并且方案之间的差别可能不明显。</p>
<p><strong>备选方案的差异要比较明显。</strong></p>
<p>例如，主备方案和集群方案差异就很明显，或者同样是主备方案，用 ZooKeeper 做主备决策和用 Keepalived 做主备决策的差异也很明显。但是都用 ZooKeeper 做主备决策，一个检测周期是 1 分钟，一个检测周期是 5 分钟，这就不是架构上的差异，而是细节上的差异了，不适合做成两个方案。</p>
<p><strong>备选方案的技术不要只局限于已经熟悉的技术。</strong></p>
<p>设计架构时，架构师需要将视野放宽，考虑更多可能性。很多架构师或者设计师积累了一些成功的经验，出于快速完成任务和降低风险的目的，可能自觉或者不自觉地倾向于使用自己已经熟悉的技术，对于新的技术有一种不放心的感觉。就像那句俗语说的：“如果你手里有一把锤子，所有的问题在你看来都是钉子”。例如，架构师对 MySQL 很熟悉，因此不管什么存储都基于 MySQL 去设计方案，系统性能不够了，首先考虑的就是 MySQL 分库分表，而事实上也许引入一个 Memcache 缓存就能够解决问题。</p>
<p>第三种常见的错误：备选方案过于详细。</p>
<p>有的架构师或者设计师在写备选方案时，错误地将备选方案等同于最终的方案，每个备选方案都写得很细。这样做的弊端显而易见：</p>
<p>耗费了大量的时间和精力。</p>
<p>将注意力集中到细节中，忽略了整体的技术设计，导致备选方案数量不够或者差异不大。</p>
<p>评审的时候其他人会被很多细节给绕进去，评审效果很差。例如，评审的时候针对某个定时器应该是 1 分钟还是 30 秒，争论得不可开交。</p>
<p>正确的做法是备选阶段关注的是技术选型，而不是技术细节，技术选型的差异要比较明显。例如，采用 ZooKeeper 和 Keepalived 两种不同的技术来实现主备，差异就很大；而同样都采用 ZooKeeper，一个方案的节点设计是 /service/node/master，另一个方案的节点设计是 /company/service/master，这两个方案并无明显差异，无须在备选方案设计阶段作为两个不同的备选方案，至于节点路径究竟如何设计，只要在最终的方案中挑选一个进行细化即可。</p>
<p><strong>设计备选方案实战</strong></p>
<p>还是回到“前浪微博”的场景，上期我们通过“排查法”识别了消息队列的复杂性主要体现在：高性能消息读取、高可用消息写入、高可用消息存储、高可用消息读取。接下来进行第 2 步，设计备选方案。</p>
<ol>
<li><p>备选方案 1：采用开源的 Kafka</p>
<p>​    Kafka 是成熟的开源消息队列方案，功能强大，性能非常高，而且已经比较成熟，很多大公司都在使用。</p>
</li>
<li><p>备选方案 2：集群 + MySQL 存储</p>
<p>​    首先考虑单服务器高性能。高性能消息读取属于“计算高可用”的范畴，单服务器高性能备选方案有很多种。考虑到团队的开发语言是 Java，虽然有人觉得 C/C++ 语言更加适合写高性能的中间件系统，但架构师综合来看，认为无须为了语言的性能优势而让整个团队切换语言，消息队列系统继续用 Java 开发。由于 Netty 是 Java 领域成熟的高性能网络库，因此架构师选择基于 Netty 开发消息队列系统。</p>
</li>
<li><p>备选方案 3：集群 + 自研存储方案</p>
<p>​    在备选方案 2 的基础上，将 MySQL 存储替换为自研实现存储方案，因为 MySQL 的关系型数据库的特点并不是很契合消息队列的数据特点，参考 Kafka 的做法，可以自己实现一套文件存储和复制方案（此处省略具体的方案描述，实际设计时需要给出方案）。</p>
</li>
</ol>
<p>可以看出，高性能消息读取单机系统设计这部分时并没有多个备选方案可选，备选方案 2 和备选方案 3 都采取基于 Netty 的网络库，用 Java 语言开发，原因就在于团队的 Java 背景约束了备选的范围。通常情况下，成熟的团队不会轻易改变技术栈，反而是新成立的技术团队更加倾向于采用新技术。上面简单地给出了 3 个备选方案用来示范如何操作，实践中要比上述方案复杂一些。架构师的技术储备越丰富、经验越多，备选方案也会更多，从而才能更好地设计备选方案。例如，开源方案选择可能就包括 Kafka、ActiveMQ、RabbitMQ；集群方案的存储既可以考虑用 MySQL，也可以考虑用 HBase，还可以考虑用 Redis 与 MySQL 结合等；自研文件系统也可以有多个，可以参考 Kafka，也可以参考 LevelDB，还可以参考 HBase 等。限于篇幅，这里就不一一展开了。</p>
<h1 id="12-架构设计流程：评估和选择备选方案"><a href="#12-架构设计流程：评估和选择备选方案" class="headerlink" title="12 | 架构设计流程：评估和选择备选方案"></a>12 | 架构设计流程：评估和选择备选方案</h1><p>上一期我讲了设计备选方案，在完成备选方案设计后，如何挑选出最终的方案也是一个很大的挑战，主要原因有：</p>
<p>每个方案都是可行的，如果方案不可行就根本不应该作为备选方案。</p>
<p>没有哪个方案是完美的。例如，A 方案有性能的缺点，B 方案有成本的缺点，C 方案有新技术不成熟的风险。</p>
<p>评价标准主观性比较强，比如设计师说 A 方案比 B 方案复杂，但另外一个设计师可能会认为差不多，因为比较难将“复杂”一词进行量化。因此，方案评审的时候我们经常会遇到几个设计师针对某个方案或者某个技术点争论得面红耳赤。</p>
<p>正因为选择备选方案存在这些困难，所以实践中很多设计师或者架构师就采取了下面几种指导思想：</p>
<p><strong>最简派</strong></p>
<p>设计师挑选一个看起来最简单的方案。例如，我们要做全文搜索功能，方案 1 基于 MySQL，方案 2 基于 Elasticsearch。MySQL 的查询功能比较简单，而 Elasticsearch 的倒排索引设计要复杂得多，写入数据到 Elasticsearch，要设计 Elasticsearch 的索引，要设计 Elasticsearch 的分布式……全套下来复杂度很高，所以干脆就挑选 MySQL 来做吧。</p>
<p><strong>最牛派</strong></p>
<p>最牛派的做法和最简派正好相反，设计师会倾向于挑选技术上看起来最牛的方案。例如，性能最高的、可用性最好的、功能最强大的，或者淘宝用的、微信开源的、Google 出品的等。</p>
<p>我们以缓存方案中的 Memcache 和 Redis 为例，假如我们要挑选一个搭配 MySQL 使用的缓存，Memcache 是纯内存缓存，支持基于一致性 hash 的集群；而 Redis 同时支持持久化、支持数据字典、支持主备、支持集群，看起来比 Memcache 好很多啊，所以就选 Redis 好了。</p>
<p><strong>最熟派</strong></p>
<p>设计师基于自己的过往经验，挑选自己最熟悉的方案。我以编程语言为例，假如设计师曾经是一个 C++ 经验丰富的开发人员，现在要设计一个运维管理系统，由于对 Python 或者 Ruby on Rails 不熟悉，因此继续选择 C++ 来做运维管理系统。</p>
<p><strong>领导派</strong></p>
<p>领导派就更加聪明了，列出备选方案，设计师自己拿捏不定，然后就让领导来定夺，反正最后方案选的对那是领导厉害，方案选的不对怎么办？那也是领导“背锅”。</p>
<p>其实这些不同的做法本身并不存在绝对的正确或者绝对的错误，关键是不同的场景应该采取不同的方式。也就是说，有时候我们要挑选最简单的方案，有时候要挑选最优秀的方案，有时候要挑选最熟悉的方案，甚至有时候真的要领导拍板。因此关键问题是：这里的“有时候”到底应该怎么判断？今天我就来讲讲架构设计流程的第 3 步：评估和选择备选方案。</p>
<p><strong>架构设计第 3 步：评估和选择备选方案</strong></p>
<p>前面提到了那么多指导思想，真正应该选择哪种方法来评估和选择备选方案呢？我的答案就是“360 度环评”！具体的操作方式为：<strong>列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。</strong></p>
<p>常见的方案质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性等。在评估这些质量属性时，需要遵循架构设计原则 1“合适原则”和原则 2“简单原则”，避免贪大求全，基本上某个质量属性能够满足一定时期内业务发展就可以了。</p>
<p>面临这种选择上的困难，有几种看似正确但实际错误的做法</p>
<p>​    数量对比法：简单地看哪个方案的优点多就选哪</p>
<p>​    加权法：每个质量属性给一个权重</p>
<p>正确的做法是<strong>按优先级选择</strong>，即架构师综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序，首先挑选满足第一优先级的，如果方案都满足，那就再看第二优先级……以此类推。那会不会出现两个或者多个方案，每个质量属性的优缺点都一样的情况呢？理论上是可能的，但实际上是不可能的。前面我提到，在做备选方案设计时，不同的备选方案之间的差异要比较明显，差异明显的备选方案不可能所有的优缺点都是一样的。</p>
<p><strong>评估和选择备选方案实战</strong></p>
<p>再回到我们设计的场景“前浪微博”。针对上期提出的 3 个备选方案，架构师组织了备选方案评审会议，参加的人有研发、测试、运维、还有几个核心业务的主管。</p>
<ol>
<li><p>备选方案 1：采用开源 Kafka 方案</p>
<p>业务主管倾向于采用 Kafka 方案，因为 Kafka 已经比较成熟，各个业务团队或多或少都了解过 Kafka。</p>
<p>中间件团队部分研发人员也支持使用 Kafka，因为使用 Kafka 能节省大量的开发投入；但部分人员认为 Kafka 可能并不适合我们的业务场景，因为 Kafka 的设计目的是为了支撑大容量的日志消息传输，而我们的消息队列是为了业务数据的可靠传输。</p>
<p>运维代表提出了强烈的反对意见：首先，Kafka 是 Scala 语言编写的，运维团队没有维护 Scala 语言开发的系统的经验，出问题后很难快速处理；其次，目前运维团队已经有一套成熟的运维体系，包括部署、监控、应急等，使用 Kafka 无法融入这套体系，需要单独投入运维人力。</p>
<p>测试代表也倾向于引入 Kafka，因为 Kafka 比较成熟，无须太多测试投入。</p>
</li>
<li><h6 id="备选方案-2：集群-MySQL-存储"><a href="#备选方案-2：集群-MySQL-存储" class="headerlink" title="备选方案 2：集群 + MySQL 存储"></a>备选方案 2：集群 + MySQL 存储</h6><p>中间件团队的研发人员认为这个方案比较简单，但部分研发人员对于这个方案的性能持怀疑态度，毕竟使用 MySQL 来存储消息数据，性能肯定不如使用文件系统；并且有的研发人员担心做这样的方案是否会影响中间件团队的技术声誉，毕竟用 MySQL 来做消息队列，看起来比较“土”、比较另类。</p>
<p>运维代表赞同这个方案，因为这个方案可以融入到现有的运维体系中，而且使用 MySQL 存储数据，可靠性有保证，运维团队也有丰富的 MySQL 运维经验；但运维团队认为这个方案的成本比较高，一个数据分组就需要 4 台机器（2 台服务器 + 2 台数据库）。</p>
<p>测试代表认为这个方案测试人力投入较大，包括功能测试、性能测试、可靠性测试等都需要大量地投入人力。</p>
<p>业务主管对这个方案既不肯定也不否定，因为反正都不是业务团队来投入人力来开发，系统维护也是中间件团队负责，对业务团队来说，只要保证消息队列系统稳定和可靠即可。</p>
</li>
<li><p>备选方案 3：集群 + 自研存储系统</p>
<p>中间件团队部分研发人员认为这是一个很好的方案，既能够展现中间件团队的技术实力，性能上相比 MySQL 也要高；但另外的研发人员认为这个方案复杂度太高，按照目前的团队人力和技术实力，要做到稳定可靠的存储系统，需要耗时较长的迭代，这个过程中消息队列系统可能因为存储出现严重问题，例如文件损坏导致丢失大量数据。</p>
<p>运维代表不太赞成这个方案，因为运维之前遇到过几次类似的存储系统故障导致数据丢失的问题，损失惨重。例如，MongoDB 丢数据、Tokyo Tyrant 丢数据无法恢复等。运维团队并不相信目前的中间件团队的技术实力足以支撑自己研发一个存储系统（这让中间件团队的人员感觉有点不爽）。</p>
<p>测试代表赞同运维代表的意见，并且自研存储系统的测试难度也很高，投入也很大。</p>
<p>业务主管对自研存储系统也持保留意见，因为从历史经验来看，新系统上线肯定有 bug，而存储系统出 bug 是最严重的，一旦出 bug 导致大量消息丢失，对系统的影响会严重。</p>
</li>
</ol>
<p>   针对 3 个备选方案的讨论初步完成后，架构师列出了 3 个方案的 360 度环评表：</p>
<p>   <img src="/.io//7de80a7501627b02ba0288f8f725a68c.jpg" alt="img"></p>
<p>列出这个表格后，无法一眼看出具体哪个方案更合适，于是大家都把目光投向架构师，决策的压力现在集中在架构师身上了。</p>
<p>架构师经过思考后，给出了最终选择备选方案 2，原因有：</p>
<p>排除备选方案 1 的主要原因是可运维性，因为再成熟的系统，上线后都可能出问题，如果出问题无法快速解决，则无法满足业务的需求；并且 Kafka 的主要设计目标是高性能日志传输，而我们的消息队列设计的主要目标是业务消息的可靠传输。</p>
<p>排除备选方案 3 的主要原因是复杂度，目前团队技术实力和人员规模（总共 6 人，还有其他中间件系统需要开发和维护）无法支撑自研存储系统（参考架构设计原则 2：简单原则）。</p>
<p>备选方案 2 的优点就是复杂度不高，也可以很好地融入现有运维体系，可靠性也有保障。</p>
<p>针对备选方案 2 的缺点，架构师解释是：</p>
<p>备选方案 2 的第一个缺点是性能，业务目前需要的性能并不是非常高，方案 2 能够满足，即使后面性能需求增加，方案 2 的数据分组方案也能够平行扩展进行支撑（参考架构设计原则 3：演化原则）。</p>
<p>备选方案 2 的第二个缺点是成本，一个分组就需要 4 台机器，支撑目前的业务需求可能需要 12 台服务器，但实际上备机（包括服务器和数据库）主要用作备份，可以和其他系统并行部署在同一台机器上。</p>
<p>备选方案 2 的第三个缺点是技术上看起来并不很优越，但我们的设计目的不是为了证明自己（参考架构设计原则 1：合适原则），而是更快更好地满足业务需求。</p>
<p>最后，大家针对一些细节再次讨论后，确定了选择备选方案 2。通过“前浪微博”这个案例我们可以看出，备选方案的选择和很多因素相关，并不单单考虑性能高低、技术是否优越这些纯技术因素。业务的需求特点、运维团队的经验、已有的技术体系、团队人员的技术水平都会影响备选方案的选择。因此，同样是上述 3 个备选方案，有的团队会选择引入 Kafka（例如，很多创业公司的初创团队，人手不够，需要快速上线支撑业务），有的会选择自研存储系统（例如，阿里开发了 RocketMQ，人多力量大，业务复杂是主要原因）。</p>
<h1 id="13-架构设计流程：详细方案设计"><a href="#13-架构设计流程：详细方案设计" class="headerlink" title="13 | 架构设计流程：详细方案设计"></a>13 | 架构设计流程：详细方案设计</h1><p>完成备选方案的设计和选择后，我们终于可以长出一口气，因为整个架构设计最难的一步已经完成了，但整体方案尚未完成，架构师还需继续努力。接下来我们需要再接再励，将最终确定的备选方案进行细化，使得备选方案变成一个可以落地的设计方案。所以今天我来讲讲架构设计流程第 4 步：详细方案设计。</p>
<p><strong>架构设计第 4 步：详细方案设计</strong></p>
<p>简单来说，详细方案设计就是将方案涉及的关键技术细节给确定下来。</p>
<p>假如我们确定使用 Elasticsearch 来做全文搜索，那么就需要确定 Elasticsearch 的索引是按照业务划分，还是一个大索引就可以了；副本数量是 2 个、3 个还是 4 个，集群节点数量是 3 个还是 6 个等。</p>
<p>假如我们确定使用 MySQL 分库分表，那么就需要确定哪些表要分库分表，按照什么维度来分库分表，分库分表后联合查询怎么处理等。</p>
<p>假如我们确定引入 Nginx 来做负载均衡，那么 Nginx 的主备怎么做，Nginx 的负载均衡策略用哪个（权重分配？轮询？ip_hash？）等。</p>
<p>可以看到，详细设计方案里面其实也有一些技术点和备选方案类似。例如，Nginx 的负载均衡策略，备选有轮询、权重分配、ip_hash、fair、url_hash 五个，具体选哪个呢？看起来和备选方案阶段面临的问题类似，但实际上这里的技术方案选择是很轻量级的，我们无须像备选方案阶段那样操作，而只需要简单根据这些技术的适用场景选择就可以了。例如，Nginx 的负载均衡策略，简单按照下面的规则选择就可以了。</p>
<p>这几个策略的适用场景区别还是比较明显的，根据我们的业务需要，挑选一个合适的即可。例如，比如一个电商架构，由于和 session 比较强相关，因此如果用 Nginx 来做集群负载均衡，那么选择 ip_hash 策略是比较合适的。</p>
<p><strong>详细设计方案阶段可能遇到的一种极端情况就是在详细设计阶段发现备选方案不可行，一般情况下主要的原因是备选方案设计时遗漏了某个关键技术点或者关键的质量属性。</strong>例如，我曾经参与过一个项目，在备选方案阶段确定是可行的，但在详细方案设计阶段，发现由于细节点太多，方案非常庞大，整个项目可能要开发长达 1 年时间，最后只得废弃原来的备选方案，重新调整项目目标、计划和方案。这个项目的主要失误就是在备选方案评估时忽略了开发周期这个质量属性。</p>
<p><strong>架构师不但要进行备选方案设计和选型，还需要对备选方案的关键细节有较深入的理解。</strong>例如，架构师选择了 Elasticsearch 作为全文搜索解决方案，前提必须是架构师自己对 Elasticsearch 的设计原理有深入的理解，比如索引、副本、集群等技术点；而不能道听途说 Elasticsearch 很牛，所以选择它，更不能成为把“细节我们不讨论”这句话挂在嘴边的“PPT 架构师”。</p>
<p><strong>通过分步骤、分阶段、分系统等方式，尽量降低方案复杂度</strong>，方案本身的复杂度越高，某个细节推翻整个方案的可能性就越高，适当降低复杂性，可以减少这种风险</p>
<p>如果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长，汇集大家的智慧和经验，防止只有 1~2 个架构师可能出现的思维盲点或者经验盲区。</p>
<p><strong>详细方案设计实战</strong></p>
<p>详细方案设计实战</p>
<p>虽然我们上期在“前浪微博”消息队列的架构设计挑选了备选方案 2 作为最终方案，但备选方案设计阶段的方案粒度还比较粗，无法真正指导开发人员进行后续的设计和开发，因此需要在备选方案的基础上进一步细化。</p>
<p>下面我列出一些备选方案 2 典型的需要细化的点供参考，有兴趣的同学可以自己尝试细化更多的设计点。</p>
<ol>
<li><p>细化设计点 1：数据库表如何设计？</p>
<p>数据库设计两类表，一类是日志表，用于消息写入时快速存储到 MySQL 中；另一类是消息表，每个消息队列一张表。</p>
<p>业务系统发布消息时，首先写入到日志表，日志表写入成功就代表消息写入成功；后台线程再从日志表中读取消息写入记录，将消息内容写入到消息表中。</p>
<p>业务系统读取消息时，从消息表中读取。</p>
<p>日志表表名为 MQ_LOG，包含的字段：日志 ID、发布者信息、发布时间、队列名称、消息内容。</p>
<p>消息表表名就是队列名称，包含的字段：消息 ID（递增生成）、消息内容、消息发布时间、消息发布者。</p>
<p>日志表需要及时清除已经写入消息表的日志数据，消息表最多保存 30 天的消息数据。</p>
</li>
</ol>
<ol start="2">
<li>细化设计点 2：数据如何复制？</li>
</ol>
<p>​        直接采用 MySQL 主从复制即可，只复制消息存储表，不复制日志表。</p>
<ol start="3">
<li><p>细化设计点 3：主备服务器如何倒换？</p>
<p>​    采用 ZooKeeper 来做主备决策，主备服务器都连接到 ZooKeeper 建立自己的节点，主服务器的路径规则为“/MQ/server/ 分区编号 /master”，备机为“/MQ/server/ 分区编号 /slave”，节点类型为 EPHEMERAL。备机监听主机的节点消息，当发现主服务器节点断连后，备服务器修改自己的状态，对外提供消息读取服务。</p>
</li>
</ol>
<ol start="4">
<li><p>细化设计点 4：业务服务器如何写入消息？</p>
<p>​    消息队列系统设计两个角色：生产者和消费者，每个角色都有唯一的名称。</p>
<p>​    消息队列系统提供 SDK 供各业务系统调用，SDK 从配置中读取所有消息队列系统的服务器信息，SDK 采取轮询算法发起消息写入请求给主服务器。如果某个主服务器无响应或者返回错误，SDK 将发起请求发送到下一台服务器。</p>
</li>
<li><p>细化设计点 5：业务服务器如何读取消息？</p>
<p>​    消息队列系统提供 SDK 供各业务系统调用，SDK 从配置中读取所有消息队列系统的服务器信息，轮流向所有服务器发起消息读取请求。</p>
<p>​    消息队列服务器需要记录每个消费者的消费状态，即当前消费者已经读取到了哪条消息，当收到消息读取请求时，返回下一条未被读取的消息给消费者。</p>
</li>
</ol>
<ol start="6">
<li><p>细化设计点 6：业务服务器和消息队列服务器之间的通信协议如何设计？</p>
<p>考虑到消息队列系统后续可能会对接多种不同编程语言编写的系统，为了提升兼容性，传输协议用 TCP，数据格式为 ProtocolBuffer。</p>
</li>
</ol>
<hr>
<h1 id="14-高性能数据库集群：读写分离"><a href="#14-高性能数据库集群：读写分离" class="headerlink" title="14 | 高性能数据库集群：读写分离"></a>14 | 高性能数据库集群：读写分离</h1>]]></content>
      <categories>
        <category>设计</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-image</title>
    <url>/2021/10/23/%E5%B7%A5%E5%85%B7/hexo-image/</url>
    <content><![CDATA[<p>HEXO插入图片（详细版）</p>
<p>菜鸟一枚，插入图片的时候走了不少弯路，写篇blog记录一下。</p>
<p>第一步：安装插件，在hexo根目录打开Git Bash,执行</p>
<pre><code>npm install hexo-asset-image --save</code></pre><p>第二步：打开hexo的配置文件_config.yml<br>_</p>
<pre><code>找到 post_asset_folder，把这个选项从false改成true</code></pre><p>_<br>第三步：打开</p>
<pre><code>/node_modules/hexo-asset-image/index.js</code></pre><p>将内容更换为下面的代码<br>（在此感谢Ericam_ 大神：<a href="https://blog.csdn.net/xjm850552586）">https://blog.csdn.net/xjm850552586）</a></p>
<pre><code>
&#39;use strict&#39;;
var cheerio = require(&#39;cheerio&#39;);

// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string
function getPosition(str, m, i) &#123;
  return str.split(m, i).join(m).length;
&#125;

var version = String(hexo.version).split(&#39;.&#39;);
hexo.extend.filter.register(&#39;after_post_render&#39;, function(data)&#123;
  var config = hexo.config;
  if(config.post_asset_folder)&#123;
        var link = data.permalink;
    if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3)
       var beginPos = getPosition(link, &#39;/&#39;, 1) + 1;
    else
       var beginPos = getPosition(link, &#39;/&#39;, 3) + 1;
    // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.
    var endPos = link.lastIndexOf(&#39;/&#39;) + 1;
    link = link.substring(beginPos, endPos);

    var toprocess = [&#39;excerpt&#39;, &#39;more&#39;, &#39;content&#39;];
    for(var i = 0; i &lt; toprocess.length; i++)&#123;
      var key = toprocess[i];

      var $ = cheerio.load(data[key], &#123;
        ignoreWhitespace: false,
        xmlMode: false,
        lowerCaseTags: false,
        decodeEntities: false
      &#125;);

      $(&#39;img&#39;).each(function()&#123;
        if ($(this).attr(&#39;src&#39;))&#123;
            // For windows style path, we replace &#39;\&#39; to &#39;/&#39;.
            var src = $(this).attr(&#39;src&#39;).replace(&#39;\\&#39;, &#39;/&#39;);
            if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp;
               !/^\s*\//.test(src)) &#123;
              // For &quot;about&quot; page, the first part of &quot;src&quot; can&#39;t be removed.
              // In addition, to support multi-level local directory.
              var linkArray = link.split(&#39;/&#39;).filter(function(elem)&#123;
                return elem != &#39;&#39;;
              &#125;);
              var srcArray = src.split(&#39;/&#39;).filter(function(elem)&#123;
                return elem != &#39;&#39; &amp;&amp; elem != &#39;.&#39;;
              &#125;);
              if(srcArray.length &gt; 1)
                srcArray.shift();
              src = srcArray.join(&#39;/&#39;);
              $(this).attr(&#39;src&#39;, config.root + link + src);
              console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src);
            &#125;
        &#125;else&#123;
            console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;);
            console.info&amp;&amp;console.info($(this));
        &#125;
      &#125;);
      data[key] = $.html();
    &#125;
  &#125;
&#125;);</code></pre><p>第四步：现在就可以插入图片了，比如</p>
<pre><code>hexo new post photo</code></pre><p>之后就在source/_posts生成photo.md文件和photo文件夹，我们把要插入的图片复制到photo文件夹内，<br>在photo.md文件里面按markdown的标准写,（我的文件名是head.jpeg）比如</p>
<pre><code>![这是代替图片的文字，随便写](head.jpeg)</code></pre><p>参考链接：<br><a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a><br><a href="https://blog.csdn.net/qq_38148394/article/details/79997971">https://blog.csdn.net/qq_38148394/article/details/79997971</a></p>
]]></content>
  </entry>
</search>
